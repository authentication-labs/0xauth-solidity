{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/_testContracts/VerifierUser.sol": {
      "content": "/* solhint-disable */\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../verifiers/Verifier.sol\";\n\ncontract VerifierUser is Verifier {\n\tconstructor() Verifier() {}\n\n\tfunction doSomething() public onlyVerifiedSender {}\n}\n"
    },
    "src/ClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./Identity.sol\";\n\ncontract ClaimIssuer is IClaimIssuer, Identity {\n\tmapping(bytes => bool) public revokedClaims;\n\n\t// solhint-disable-next-line no-empty-blocks\n\tconstructor(address initialManagementKey) Identity(initialManagementKey, false) {}\n\n\t/**\n\t *  @dev See {IClaimIssuer-revokeClaimBySignature}.\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external override delegatedOnly onlyManager {\n\t\trequire(!revokedClaims[signature], \"Conflict: Claim already revoked\");\n\n\t\trevokedClaims[signature] = true;\n\n\t\temit ClaimRevoked(signature);\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-revokeClaim}.\n\t */\n\tfunction revokeClaim(\n\t\tbytes32 _claimId,\n\t\taddress _identity\n\t) external override delegatedOnly onlyManager returns (bool) {\n\t\tuint256 foundClaimTopic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes memory sig;\n\t\tbytes memory data;\n\n\t\t(foundClaimTopic, scheme, issuer, sig, data, ) = Identity(_identity).getClaim(_claimId);\n\n\t\trequire(!revokedClaims[sig], \"Conflict: Claim already revoked\");\n\n\t\trevokedClaims[sig] = true;\n\t\temit ClaimRevoked(sig);\n\t\treturn true;\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-isClaimValid}.\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes memory sig,\n\t\tbytes memory data\n\t) public view override(Identity, IClaimIssuer) returns (bool claimValid) {\n\t\tbytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n\t\t// Use abi.encodePacked to concatenate the message prefix and the message to sign.\n\t\tbytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n\t\t// Recover address of data signer\n\t\taddress recovered = getRecoveredAddress(sig, prefixedHash);\n\n\t\t// Take hash of recovered address\n\t\tbytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n\t\t// Does the trusted identifier have they key which signed the user's claim?\n\t\t//  && (isClaimRevoked(_claimId) == false)\n\t\tif (keyHasPurpose(hashedAddr, 3) && (isClaimRevoked(sig) == false)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-isClaimRevoked}.\n\t */\n\tfunction isClaimRevoked(bytes memory _sig) public view override returns (bool) {\n\t\tif (revokedClaims[_sig]) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n"
    },
    "src/factory/IdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../proxy/IdentityProxy.sol\";\nimport \"./IIdFactory.sol\";\nimport \"../interface/IERC734.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract IdFactory is IIdFactory, Ownable {\n\tmapping(address => bool) private _tokenFactories;\n\n\t// address of the _implementationAuthority contract making the link to the implementation contract\n\taddress private immutable _implementationAuthority;\n\n\t// as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\n\t// salt is taken and which is not\n\tmapping(string => bool) private _saltTaken;\n\n\t// ONCHAINID of the wallet owner\n\tmapping(address => address) private _userIdentity;\n\n\t// wallets currently linked to an ONCHAINID\n\tmapping(address => address[]) private _wallets;\n\n\t// ONCHAINID of the token\n\tmapping(address => address) private _tokenIdentity;\n\n\t// token linked to an ONCHAINID\n\tmapping(address => address) private _tokenAddress;\n\n\t// setting\n\tconstructor(address implementationAuthority) {\n\t\trequire(implementationAuthority != address(0), \"invalid argument - zero address\");\n\t\t_implementationAuthority = implementationAuthority;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-addTokenFactory}.\n\t */\n\tfunction addTokenFactory(address _factory) external override onlyOwner {\n\t\trequire(_factory != address(0), \"invalid argument - zero address\");\n\t\trequire(!isTokenFactory(_factory), \"already a factory\");\n\t\t_tokenFactories[_factory] = true;\n\t\temit TokenFactoryAdded(_factory);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-removeTokenFactory}.\n\t */\n\tfunction removeTokenFactory(address _factory) external override onlyOwner {\n\t\trequire(_factory != address(0), \"invalid argument - zero address\");\n\t\trequire(isTokenFactory(_factory), \"not a factory\");\n\t\t_tokenFactories[_factory] = false;\n\t\temit TokenFactoryRemoved(_factory);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createIdentity}.\n\t */\n\tfunction createIdentity(address _wallet, string memory _salt) external override onlyOwner returns (address) {\n\t\trequire(_wallet != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory oidSalt = string.concat(\"OID\", _salt);\n\t\trequire(!_saltTaken[oidSalt], \"salt already taken\");\n\t\trequire(_userIdentity[_wallet] == address(0), \"wallet already linked to an identity\");\n\t\taddress identity = _deployIdentity(oidSalt, _implementationAuthority, _wallet);\n\t\t_saltTaken[oidSalt] = true;\n\t\t_userIdentity[_wallet] = identity;\n\t\t_wallets[identity].push(_wallet);\n\t\temit WalletLinked(_wallet, identity);\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createIdentityWithManagementKeys}.\n\t */\n\tfunction createIdentityWithManagementKeys(\n\t\taddress _wallet,\n\t\tstring memory _salt,\n\t\tbytes32[] memory _managementKeys\n\t) external override onlyOwner returns (address) {\n\t\trequire(_wallet != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory oidSalt = string.concat(\"OID\", _salt);\n\t\trequire(!_saltTaken[oidSalt], \"salt already taken\");\n\t\trequire(_userIdentity[_wallet] == address(0), \"wallet already linked to an identity\");\n\t\trequire(_managementKeys.length > 0, \"invalid argument - empty list of keys\");\n\n\t\taddress identity = _deployIdentity(oidSalt, _implementationAuthority, address(this));\n\n\t\tfor (uint i = 0; i < _managementKeys.length; i++) {\n\t\t\trequire(\n\t\t\t\t_managementKeys[i] != keccak256(abi.encode(_wallet)),\n\t\t\t\t\"invalid argument - wallet is also listed in management keys\"\n\t\t\t);\n\t\t\tIERC734(identity).addKey(_managementKeys[i], 1, 1);\n\t\t}\n\n\t\tIERC734(identity).removeKey(keccak256(abi.encode(address(this))), 1);\n\n\t\t_saltTaken[oidSalt] = true;\n\t\t_userIdentity[_wallet] = identity;\n\t\t_wallets[identity].push(_wallet);\n\t\temit WalletLinked(_wallet, identity);\n\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createTokenIdentity}.\n\t */\n\tfunction createTokenIdentity(\n\t\taddress _token,\n\t\taddress _tokenOwner,\n\t\tstring memory _salt\n\t) external override returns (address) {\n\t\trequire(isTokenFactory(msg.sender) || msg.sender == owner(), \"only Factory or owner can call\");\n\t\trequire(_token != address(0), \"invalid argument - zero address\");\n\t\trequire(_tokenOwner != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory tokenIdSalt = string.concat(\"Token\", _salt);\n\t\trequire(!_saltTaken[tokenIdSalt], \"salt already taken\");\n\t\trequire(_tokenIdentity[_token] == address(0), \"token already linked to an identity\");\n\t\taddress identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\n\t\t_saltTaken[tokenIdSalt] = true;\n\t\t_tokenIdentity[_token] = identity;\n\t\t_tokenAddress[identity] = _token;\n\t\temit TokenLinked(_token, identity);\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-linkWallet}.\n\t */\n\tfunction linkWallet(address _newWallet) external override {\n\t\trequire(_newWallet != address(0), \"invalid argument - zero address\");\n\t\trequire(_userIdentity[msg.sender] != address(0), \"wallet not linked to an identity contract\");\n\t\trequire(_userIdentity[_newWallet] == address(0), \"new wallet already linked\");\n\t\trequire(_tokenIdentity[_newWallet] == address(0), \"invalid argument - token address\");\n\t\taddress identity = _userIdentity[msg.sender];\n\t\trequire(_wallets[identity].length < 101, \"max amount of wallets per ID exceeded\");\n\t\t_userIdentity[_newWallet] = identity;\n\t\t_wallets[identity].push(_newWallet);\n\t\temit WalletLinked(_newWallet, identity);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-unlinkWallet}.\n\t */\n\tfunction unlinkWallet(address _oldWallet) external override {\n\t\trequire(_oldWallet != address(0), \"invalid argument - zero address\");\n\t\trequire(_oldWallet != msg.sender, \"cannot be called on sender address\");\n\t\trequire(_userIdentity[msg.sender] == _userIdentity[_oldWallet], \"only a linked wallet can unlink\");\n\t\taddress _identity = _userIdentity[_oldWallet];\n\t\tdelete _userIdentity[_oldWallet];\n\t\tuint256 length = _wallets[_identity].length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (_wallets[_identity][i] == _oldWallet) {\n\t\t\t\t_wallets[_identity][i] = _wallets[_identity][length - 1];\n\t\t\t\t_wallets[_identity].pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\temit WalletUnlinked(_oldWallet, _identity);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getIdentity}.\n\t */\n\tfunction getIdentity(address _wallet) external view override returns (address) {\n\t\tif (_tokenIdentity[_wallet] != address(0)) {\n\t\t\treturn _tokenIdentity[_wallet];\n\t\t} else {\n\t\t\treturn _userIdentity[_wallet];\n\t\t}\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-isSaltTaken}.\n\t */\n\tfunction isSaltTaken(string calldata _salt) external view override returns (bool) {\n\t\treturn _saltTaken[_salt];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getWallets}.\n\t */\n\tfunction getWallets(address _identity) external view override returns (address[] memory) {\n\t\treturn _wallets[_identity];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getToken}.\n\t */\n\tfunction getToken(address _identity) external view override returns (address) {\n\t\treturn _tokenAddress[_identity];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-isTokenFactory}.\n\t */\n\tfunction isTokenFactory(address _factory) public view override returns (bool) {\n\t\treturn _tokenFactories[_factory];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-implementationAuthority}.\n\t */\n\tfunction implementationAuthority() public view override returns (address) {\n\t\treturn _implementationAuthority;\n\t}\n\n\t// deploy function with create2 opcode call\n\t// returns the address of the contract created\n\tfunction _deploy(string memory salt, bytes memory bytecode) private returns (address) {\n\t\tbytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\n\t\taddress addr;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tlet encoded_data := add(0x20, bytecode) // load initialization code.\n\t\t\tlet encoded_size := mload(bytecode) // load init code's length.\n\t\t\taddr := create2(0, encoded_data, encoded_size, saltBytes)\n\t\t\tif iszero(extcodesize(addr)) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\t\t}\n\t\temit Deployed(addr);\n\t\treturn addr;\n\t}\n\n\t// function used to deploy an identity using CREATE2\n\tfunction _deployIdentity(\n\t\tstring memory _salt,\n\t\taddress implementationAuthority,\n\t\taddress _wallet\n\t) private returns (address) {\n\t\tbytes memory _code = type(IdentityProxy).creationCode;\n\t\tbytes memory _constructData = abi.encode(implementationAuthority, _wallet);\n\t\tbytes memory bytecode = abi.encodePacked(_code, _constructData);\n\t\treturn _deploy(_salt, bytecode);\n\t}\n}\n"
    },
    "src/factory/IIdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ninterface IIdFactory {\n\t/// events\n\n\t// event emitted whenever a single contract is deployed by the factory\n\tevent Deployed(address indexed _addr);\n\n\t// event emitted when a wallet is linked to an ONCHAINID contract\n\tevent WalletLinked(address indexed wallet, address indexed identity);\n\n\t// event emitted when a token is linked to an ONCHAINID contract\n\tevent TokenLinked(address indexed token, address indexed identity);\n\n\t// event emitted when a wallet is unlinked from an ONCHAINID contract\n\tevent WalletUnlinked(address indexed wallet, address indexed identity);\n\n\t// event emitted when an address is registered on the factory as a Token\n\t// factory address, granting this address the privilege to issue\n\t// Onchain identities for tokens\n\tevent TokenFactoryAdded(address indexed factory);\n\n\t// event emitted when a previously recorded token factory address is removed\n\tevent TokenFactoryRemoved(address indexed factory);\n\n\t/// functions\n\n\t/**\n\t *  @dev function used to create a new Identity proxy from the factory\n\t *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  requires a new salt for each deployment\n\t *  _wallet cannot be linked to another ONCHAINID\n\t *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n\t *  of the function, including calls to oracles for multichain\n\t *  deployment security (avoid identity theft), defining payment requirements, etc.\n\t */\n\tfunction createIdentity(address _wallet, string memory _salt) external returns (address);\n\n\t/**\n\t *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\n\t * MANAGEMENT keys.\n\t *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\n\t *  requires a new salt for each deployment\n\t *  _wallet cannot be linked to another ONCHAINID\n\t *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n\t *  of the function, including calls to oracles for multichain\n\t *  deployment security (avoid identity theft), defining payment requirements, etc.\n\t */\n\tfunction createIdentityWithManagementKeys(\n\t\taddress _wallet,\n\t\tstring memory _salt,\n\t\tbytes32[] memory _managementKeys\n\t) external returns (address);\n\n\t/**\n\t *  @dev function used to create a new Token Identity proxy from the factory\n\t *  @param _token the address of the token contract\n\t *  @param _tokenOwner the owner address of the token\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  requires a new salt for each deployment\n\t *  _token cannot be linked to another ONCHAINID\n\t *  only Token factory or owner can call (owner should only use its privilege\n\t *  for tokens not issued by a Token factory onchain\n\t */\n\tfunction createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\n\n\t/**\n\t *  @dev function used to link a new wallet to an existing identity\n\t *  @param _newWallet the address of the wallet to link\n\t *  requires msg.sender to be linked to an existing onchainid\n\t *  the _newWallet will be linked to the same OID contract as msg.sender\n\t *  _newWallet cannot be linked to an OID yet\n\t *  _newWallet cannot be address 0\n\t *  cannot link more than 100 wallets to an OID, for gas consumption reason\n\t */\n\tfunction linkWallet(address _newWallet) external;\n\n\t/**\n\t *  @dev function used to unlink a wallet from an existing identity\n\t *  @param _oldWallet the address of the wallet to unlink\n\t *  requires msg.sender to be linked to the same onchainid as _oldWallet\n\t *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\n\t *  _oldWallet cannot be address 0\n\t */\n\tfunction unlinkWallet(address _oldWallet) external;\n\n\t/**\n\t *  @dev function used to register an address as a token factory\n\t *  @param _factory the address of the token factory\n\t *  can be called only by Owner\n\t *  _factory cannot be registered yet\n\t *  once the factory has been registered it can deploy token identities\n\t */\n\tfunction addTokenFactory(address _factory) external;\n\n\t/**\n\t *  @dev function used to unregister an address previously registered as a token factory\n\t *  @param _factory the address of the token factory\n\t *  can be called only by Owner\n\t *  _factory has to be registered previously\n\t *  once the factory has been unregistered it cannot deploy token identities anymore\n\t */\n\tfunction removeTokenFactory(address _factory) external;\n\n\t/**\n\t *  @dev getter for OID contract corresponding to a wallet/token\n\t *  @param _wallet the wallet/token address\n\t */\n\tfunction getIdentity(address _wallet) external view returns (address);\n\n\t/**\n\t *  @dev getter to fetch the array of wallets linked to an OID contract\n\t *  @param _identity the address of the OID contract\n\t *  returns an array of addresses linked to the OID\n\t */\n\tfunction getWallets(address _identity) external view returns (address[] memory);\n\n\t/**\n\t *  @dev getter to fetch the token address linked to an OID contract\n\t *  @param _identity the address of the OID contract\n\t *  returns the address linked to the OID\n\t */\n\tfunction getToken(address _identity) external view returns (address);\n\n\t/**\n\t *  @dev getter to know if an address is registered as token factory or not\n\t *  @param _factory the address of the factory\n\t *  returns true if the address corresponds to a registered factory\n\t */\n\tfunction isTokenFactory(address _factory) external view returns (bool);\n\n\t/**\n\t *  @dev getter to know if a salt is taken for the create2 deployment\n\t *  @param _salt the salt used for deployment\n\t */\n\tfunction isSaltTaken(string calldata _salt) external view returns (bool);\n\n\t/**\n\t * @dev getter for the implementation authority used by this factory.\n\t */\n\tfunction implementationAuthority() external view returns (address);\n}\n"
    },
    "src/Identity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IIdentity.sol\";\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./version/Version.sol\";\nimport \"./storage/Storage.sol\";\n\n/**\n * @dev Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces\n * into a common Identity Contract.\n * This implementation has a separate contract were it declares all storage,\n * allowing for it to be used as an upgradable logic contract.\n */\ncontract Identity is Storage, IIdentity, Version {\n\t/**\n\t * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\n\t */\n\tmodifier delegatedOnly() {\n\t\trequire(_canInteract == true, \"Interacting with the library contract is forbidden.\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice requires management key to call this function, or internal call\n\t */\n\tmodifier onlyManager() {\n\t\trequire(\n\t\t\tmsg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 1),\n\t\t\t\"Permissions: Sender does not have management key\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice requires claim key to call this function, or internal call\n\t */\n\tmodifier onlyClaimKey() {\n\t\trequire(\n\t\t\tmsg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 3),\n\t\t\t\"Permissions: Sender does not have claim signer key\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice constructor of the Identity contract\n\t * @param initialManagementKey the address of the management key at deployment\n\t * @param _isLibrary boolean value stating if the contract is library or not\n\t * calls __Identity_init if contract is not library\n\t */\n\tconstructor(address initialManagementKey, bool _isLibrary) {\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\n\t\tif (!_isLibrary) {\n\t\t\t__Identity_init(initialManagementKey);\n\t\t} else {\n\t\t\t_initialized = true;\n\t\t}\n\t}\n\n\t/**\n\t * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\n\t *\n\t * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n\t */\n\tfunction initialize(address initialManagementKey) external {\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\t\t__Identity_init(initialManagementKey);\n\t}\n\n\t/**\n\t * @dev See {IERC734-execute}.\n\t * @notice Passes an execution instruction to the keymanager.\n\t * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n\t * execution is immediately approved and performed.\n\t * If the destination address is the identity itself, then the execution would be performed immediately only if\n\t * the sender is a MANAGEMENT key.\n\t * Otherwise the execution request must be approved via the `approve` method.\n\t * @return executionId to use in the approve function, to approve or reject this execution.\n\t */\n\tfunction execute(\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tbytes memory _data\n\t) external payable override delegatedOnly returns (uint256 executionId) {\n\t\tuint256 _executionId = _executionNonce;\n\t\t_executions[_executionId].to = _to;\n\t\t_executions[_executionId].value = _value;\n\t\t_executions[_executionId].data = _data;\n\t\t_executionNonce++;\n\n\t\temit ExecutionRequested(_executionId, _to, _value, _data);\n\n\t\tif (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\n\t\t\tapprove(_executionId, true);\n\t\t} else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)) {\n\t\t\tapprove(_executionId, true);\n\t\t}\n\n\t\treturn _executionId;\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKey}.\n\t * @notice Implementation of the getKey function from the ERC-734 standard\n\t * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n\t * @return purposes Returns the full key data, if present in the identity.\n\t * @return keyType Returns the full key data, if present in the identity.\n\t * @return key Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(\n\t\tbytes32 _key\n\t) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n\t\treturn (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKeyPurposes}.\n\t * @notice gets the purposes of a key\n\t * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n\t * @return _purposes Returns the purposes of the specified key\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n\t\treturn (_keys[_key].purposes);\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKeysByPurpose}.\n\t * @notice gets all the keys with a specific purpose from an identity\n\t * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n\t * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory keys) {\n\t\treturn _keysByPurpose[_purpose];\n\t}\n\n\t/**\n\t * @dev See {IERC735-getClaimIdsByTopic}.\n\t * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\n\t * used to get all the claims from the specified topic\n\t * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t * @return claimIds Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds) {\n\t\treturn _claimsByTopic[_topic];\n\t}\n\n\t/**\n\t * @notice implementation of the addKey function of the ERC-734 standard\n\t * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\n\t * 1: MANAGEMENT keys, which can manage the identity\n\t * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n\t * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n\t * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n\t * MUST only be done by keys of purpose 1, or the identity itself.\n\t * If its the identity itself, the approval process will determine its approval.\n\t * @param _key keccak256 representation of an ethereum address\n\t * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n\t * @return success Returns TRUE if the addition was successful and FALSE if not\n\t */\n\tfunction addKey(\n\t\tbytes32 _key,\n\t\tuint256 _purpose,\n\t\tuint256 _type\n\t) public override delegatedOnly onlyManager returns (bool success) {\n\t\tif (_keys[_key].key == _key) {\n\t\t\tuint256[] memory _purposes = _keys[_key].purposes;\n\t\t\tfor (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\n\t\t\t\tuint256 purpose = _purposes[keyPurposeIndex];\n\n\t\t\t\tif (purpose == _purpose) {\n\t\t\t\t\trevert(\"Conflict: Key already has purpose\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_keys[_key].purposes.push(_purpose);\n\t\t} else {\n\t\t\t_keys[_key].key = _key;\n\t\t\t_keys[_key].purposes = [_purpose];\n\t\t\t_keys[_key].keyType = _type;\n\t\t}\n\n\t\t_keysByPurpose[_purpose].push(_key);\n\n\t\temit KeyAdded(_key, _purpose, _type);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *  @dev See {IERC734-approve}.\n\t *  @notice Approves an execution.\n\t *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n\t *  approval is authorized and the operation would be performed.\n\t *  If the destination address is the identity itself, then the execution would be authorized and performed only\n\t *  if the sender is a MANAGEMENT key.\n\t */\n\tfunction approve(uint256 _id, bool _approve) public override delegatedOnly returns (bool success) {\n\t\trequire(_id < _executionNonce, \"Cannot approve a non-existing execution\");\n\t\trequire(!_executions[_id].executed, \"Request already executed\");\n\n\t\tif (_executions[_id].to == address(this)) {\n\t\t\trequire(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), \"Sender does not have management key\");\n\t\t} else {\n\t\t\trequire(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), \"Sender does not have action key\");\n\t\t}\n\n\t\temit Approved(_id, _approve);\n\n\t\tif (_approve == true) {\n\t\t\t_executions[_id].approved = true;\n\n\t\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t\t(success, ) = _executions[_id].to.call{value: (_executions[_id].value)}(_executions[_id].data);\n\n\t\t\tif (success) {\n\t\t\t\t_executions[_id].executed = true;\n\n\t\t\t\temit Executed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\temit ExecutionFailed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t_executions[_id].approved = false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev See {IERC734-removeKey}.\n\t * @notice Remove the purpose from a key.\n\t */\n\tfunction removeKey(\n\t\tbytes32 _key,\n\t\tuint256 _purpose\n\t) public override delegatedOnly onlyManager returns (bool success) {\n\t\trequire(_keys[_key].key == _key, \"NonExisting: Key isn't registered\");\n\t\tuint256[] memory _purposes = _keys[_key].purposes;\n\n\t\tuint purposeIndex = 0;\n\t\twhile (_purposes[purposeIndex] != _purpose) {\n\t\t\tpurposeIndex++;\n\n\t\t\tif (purposeIndex == _purposes.length) {\n\t\t\t\trevert(\"NonExisting: Key doesn't have such purpose\");\n\t\t\t}\n\t\t}\n\n\t\t_purposes[purposeIndex] = _purposes[_purposes.length - 1];\n\t\t_keys[_key].purposes = _purposes;\n\t\t_keys[_key].purposes.pop();\n\n\t\tuint keyIndex = 0;\n\t\tuint arrayLength = _keysByPurpose[_purpose].length;\n\n\t\twhile (_keysByPurpose[_purpose][keyIndex] != _key) {\n\t\t\tkeyIndex++;\n\n\t\t\tif (keyIndex >= arrayLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t_keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\n\t\t_keysByPurpose[_purpose].pop();\n\n\t\tuint keyType = _keys[_key].keyType;\n\n\t\tif (_purposes.length - 1 == 0) {\n\t\t\tdelete _keys[_key];\n\t\t}\n\n\t\temit KeyRemoved(_key, _purpose, keyType);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC735-addClaim}.\n\t * @notice Implementation of the addClaim function from the ERC-735 standard\n\t *  Require that the msg.sender has claim signer key.\n\t *\n\t * @param _topic The type of claim\n\t * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\n\t * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\n\t * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\n\t * it MUST be a signed message of the following structure:\n\t * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\n\t * @param _data The hash of the claim data, sitting in another\n\t * location, a bit-mask, call data, or actual data based on the claim scheme.\n\t * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t *\n\t * @return claimRequestId Returns claimRequestId: COULD be\n\t * send to the approve function, to approve or reject this claim.\n\t * triggers ClaimAdded event.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) public override delegatedOnly onlyClaimKey returns (bytes32 claimRequestId) {\n\t\tif (_issuer != address(this)) {\n\t\t\trequire(\n\t\t\t\tIClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data),\n\t\t\t\t\"invalid claim\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 claimId = keccak256(abi.encode(_issuer, _topic));\n\t\t_claims[claimId].topic = _topic;\n\t\t_claims[claimId].scheme = _scheme;\n\t\t_claims[claimId].signature = _signature;\n\t\t_claims[claimId].data = _data;\n\t\t_claims[claimId].uri = _uri;\n\n\t\tif (_claims[claimId].issuer != _issuer) {\n\t\t\t_claimsByTopic[_topic].push(claimId);\n\t\t\t_claims[claimId].issuer = _issuer;\n\n\t\t\temit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\t\t} else {\n\t\t\temit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\t\t}\n\t\treturn claimId;\n\t}\n\n\t/**\n\t * @dev See {IERC735-removeClaim}.\n\t * @notice Implementation of the removeClaim function from the ERC-735 standard\n\t * Require that the msg.sender has management key.\n\t * Can only be removed by the claim issuer, or the claim holder itself.\n\t *\n\t * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t *\n\t * @return success Returns TRUE when the claim was removed.\n\t * triggers ClaimRemoved event\n\t */\n\tfunction removeClaim(bytes32 _claimId) public override delegatedOnly onlyClaimKey returns (bool success) {\n\t\tuint256 _topic = _claims[_claimId].topic;\n\t\tif (_topic == 0) {\n\t\t\trevert(\"NonExisting: There is no claim with this ID\");\n\t\t}\n\n\t\tuint claimIndex = 0;\n\t\tuint arrayLength = _claimsByTopic[_topic].length;\n\t\twhile (_claimsByTopic[_topic][claimIndex] != _claimId) {\n\t\t\tclaimIndex++;\n\n\t\t\tif (claimIndex >= arrayLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t_claimsByTopic[_topic][claimIndex] = _claimsByTopic[_topic][arrayLength - 1];\n\t\t_claimsByTopic[_topic].pop();\n\n\t\temit ClaimRemoved(\n\t\t\t_claimId,\n\t\t\t_topic,\n\t\t\t_claims[_claimId].scheme,\n\t\t\t_claims[_claimId].issuer,\n\t\t\t_claims[_claimId].signature,\n\t\t\t_claims[_claimId].data,\n\t\t\t_claims[_claimId].uri\n\t\t);\n\n\t\tdelete _claims[_claimId];\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC735-getClaim}.\n\t * @notice Implementation of the getClaim function from the ERC-735 standard.\n\t *\n\t * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t *\n\t * @return topic Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return scheme Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return issuer Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return signature Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return data Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return uri Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t)\n\t{\n\t\treturn (\n\t\t\t_claims[_claimId].topic,\n\t\t\t_claims[_claimId].scheme,\n\t\t\t_claims[_claimId].issuer,\n\t\t\t_claims[_claimId].signature,\n\t\t\t_claims[_claimId].data,\n\t\t\t_claims[_claimId].uri\n\t\t);\n\t}\n\n\t/**\n\t * @dev See {IERC734-keyHasPurpose}.\n\t * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) public view override returns (bool result) {\n\t\tKey memory key = _keys[_key];\n\t\tif (key.key == 0) return false;\n\n\t\tfor (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\n\t\t\tuint256 purpose = key.purposes[keyPurposeIndex];\n\n\t\t\tif (purpose == 1 || purpose == _purpose) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\n\t * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\n\t * stored by the identity contract.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes memory sig,\n\t\tbytes memory data\n\t) public view virtual override returns (bool claimValid) {\n\t\tbytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n\t\t// Use abi.encodePacked to concatenate the message prefix and the message to sign.\n\t\tbytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n\t\t// Recover address of data signer\n\t\taddress recovered = getRecoveredAddress(sig, prefixedHash);\n\n\t\t// Take hash of recovered address\n\t\tbytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n\t\t// Does the trusted identifier have they key which signed the user's claim?\n\t\t//  && (isClaimRevoked(_claimId) == false)\n\t\tif (keyHasPurpose(hashedAddr, 3)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev returns the address that signed the given data\n\t * @param sig the signature of the data\n\t * @param dataHash the data that was signed\n\t * returns the address that signed dataHash and created the signature sig\n\t */\n\tfunction getRecoveredAddress(bytes memory sig, bytes32 dataHash) public pure returns (address addr) {\n\t\tbytes32 ra;\n\t\tbytes32 sa;\n\t\tuint8 va;\n\n\t\t// Check the signature length\n\t\tif (sig.length != 65) {\n\t\t\treturn address(0);\n\t\t}\n\n\t\t// Divide the signature in r, s and v variables\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tra := mload(add(sig, 32))\n\t\t\tsa := mload(add(sig, 64))\n\t\t\tva := byte(0, mload(add(sig, 96)))\n\t\t}\n\n\t\tif (va < 27) {\n\t\t\tva += 27;\n\t\t}\n\n\t\taddress recoveredAddress = ecrecover(dataHash, va, ra, sa);\n\n\t\treturn (recoveredAddress);\n\t}\n\n\t/**\n\t * @notice Initializer internal function for the Identity contract.\n\t *\n\t * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n\t */\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __Identity_init(address initialManagementKey) internal {\n\t\trequire(!_initialized || _isConstructor(), \"Initial key was already setup.\");\n\t\t_initialized = true;\n\t\t_canInteract = true;\n\n\t\tbytes32 _key = keccak256(abi.encode(initialManagementKey));\n\t\t_keys[_key].key = _key;\n\t\t_keys[_key].purposes = [1];\n\t\t_keys[_key].keyType = 1;\n\t\t_keysByPurpose[1].push(_key);\n\t\temit KeyAdded(_key, 1, 1);\n\t}\n\n\t/**\n\t * @notice Computes if the context in which the function is called is a constructor or not.\n\t *\n\t * @return true if the context is a constructor.\n\t */\n\tfunction _isConstructor() private view returns (bool) {\n\t\taddress self = address(this);\n\t\tuint256 cs;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcs := extcodesize(self)\n\t\t}\n\t\treturn cs == 0;\n\t}\n}\n"
    },
    "src/interface/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\t/**\n\t * @dev Emitted when a claim is revoked.\n\t *\n\t * Specification: MUST be triggered when revoking a claim.\n\t */\n\tevent ClaimRevoked(bytes indexed signature);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @notice will fetch the claim from the identity contract (unsafe).\n\t * @param _claimId the id of the claim\n\t * @param _identity the address of the identity contract\n\t * @return isRevoked true when the claim is revoked\n\t */\n\tfunction revokeClaim(bytes32 _claimId, address _identity) external returns (bool);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @param signature the signature of the claim\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external;\n\n\t/**\n\t * @dev Returns revocation status of a claim.\n\t * @param _sig the signature of the claim\n\t * @return isRevoked true if the claim is revoked and false otherwise\n\t */\n\tfunction isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\t/**\n\t * @dev Emitted when an execution request was approved.\n\t *\n\t * Specification: MUST be triggered when approve was successfully called.\n\t */\n\tevent Approved(uint256 indexed executionId, bool approved);\n\n\t/**\n\t * @dev Emitted when an execute operation was approved and successfully performed.\n\t *\n\t * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n\t */\n\tevent Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execution request was performed via `execute`.\n\t *\n\t * Specification: MUST be triggered when execute was successfully called.\n\t */\n\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execute operation was called and failed\n\t *\n\t * Specification: MUST be triggered when execute call failed\n\t */\n\tevent ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when a key was added to the Identity.\n\t *\n\t * Specification: MUST be triggered when addKey was successfully called.\n\t */\n\tevent KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Emitted when a key was removed from the Identity.\n\t *\n\t * Specification: MUST be triggered when removeKey was successfully called.\n\t */\n\tevent KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n\t *\n\t * Triggers Event: `KeyAdded`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity\n\t * itself. If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n\t/**\n\t * @dev Approves an execution.\n\t *\n\t * Triggers Event: `Approved`\n\t * Triggers on execution successful Event: `Executed`\n\t * Triggers on execution failure Event: `ExecutionFailed`\n\t */\n\tfunction approve(uint256 _id, bool _approve) external returns (bool success);\n\n\t/**\n\t * @dev Removes _purpose for _key from the identity.\n\t *\n\t * Triggers Event: `KeyRemoved`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n\t * If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n\t/**\n\t * @dev Passes an execution instruction to an ERC734 identity.\n\t * How the execution is handled is up to the identity implementation:\n\t * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n\t * approve this execution.\n\t * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n\t *\n\t * Triggers Event: ExecutionRequested\n\t * Triggers on direct execution Event: Executed\n\t */\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n\t/**\n\t * @dev Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n\t/**\n\t * @dev Returns the list of purposes associated with a key.\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view returns (uint256[] memory _purposes);\n\n\t/**\n\t * @dev Returns an array of public key bytes32 held by this identity.\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n\t/**\n\t * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"
    },
    "src/interface/IERC735.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\t/**\n\t * @dev Emitted when a claim was added.\n\t *\n\t * Specification: MUST be triggered when a claim was successfully added.\n\t */\n\tevent ClaimAdded(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was removed.\n\t *\n\t * Specification: MUST be triggered when removeClaim was successfully called.\n\t */\n\tevent ClaimRemoved(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was changed.\n\t *\n\t * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n\t */\n\tevent ClaimChanged(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Add or update a claim.\n\t *\n\t * Triggers Event: `ClaimAdded`, `ClaimChanged`\n\t *\n\t * Specification: Add or update a claim from an issuer.\n\t *\n\t * _signature is a signed message of the following structure:\n\t * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress issuer,\n\t\tbytes calldata _signature,\n\t\tbytes calldata _data,\n\t\tstring calldata _uri\n\t) external returns (bytes32 claimRequestId);\n\n\t/**\n\t * @dev Removes a claim.\n\t *\n\t * Triggers Event: `ClaimRemoved`\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction removeClaim(bytes32 _claimId) external returns (bool success);\n\n\t/**\n\t * @dev Get a claim by its ID.\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t);\n\n\t/**\n\t * @dev Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view returns (bytes32[] memory claimIds);\n}\n"
    },
    "src/interface/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IImplementationAuthority {\n\t// event emitted when the implementation contract is updated\n\tevent UpdatedImplementation(address newAddress);\n\n\t/**\n\t * @dev updates the address used as implementation by the proxies linked\n\t * to this ImplementationAuthority contract\n\t * @param _newImplementation the address of the new implementation contract\n\t * only Owner can call\n\t */\n\tfunction updateImplementation(address _newImplementation) external;\n\n\t/**\n\t * @dev returns the address of the implementation\n\t */\n\tfunction getImplementation() external view returns (address);\n}\n"
    },
    "src/proxy/IdentityProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"../interface/IImplementationAuthority.sol\";\n\ncontract IdentityProxy {\n\t/**\n\t *  @dev constructor of the proxy Identity contract\n\t *  @param _implementationAuthority the implementation Authority contract address\n\t *  @param initialManagementKey the management key at deployment\n\t *  the proxy is going to use the logic deployed on the implementation contract\n\t *  deployed at an address listed in the ImplementationAuthority contract\n\t */\n\tconstructor(address _implementationAuthority, address initialManagementKey) {\n\t\trequire(_implementationAuthority != address(0), \"invalid argument - zero address\");\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tsstore(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc, _implementationAuthority)\n\t\t}\n\n\t\taddress logic = IImplementationAuthority(_implementationAuthority).getImplementation();\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, ) = logic.delegatecall(abi.encodeWithSignature(\"initialize(address)\", initialManagementKey));\n\t\trequire(success, \"Initialization failed.\");\n\t}\n\n\t/**\n\t *  @dev fallback proxy function used for any transaction call that is made using\n\t *  the Identity contract ABI and called on the proxy contract\n\t *  The proxy will update its local storage depending on the behaviour requested\n\t *  by the implementation contract given by the Implementation Authority\n\t */\n\t// solhint-disable-next-line no-complex-fallback\n\tfallback() external payable {\n\t\taddress logic = IImplementationAuthority(implementationAuthority()).getImplementation();\n\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcalldatacopy(0x0, 0x0, calldatasize())\n\t\t\tlet success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\n\t\t\tlet retSz := returndatasize()\n\t\t\treturndatacopy(0, 0, retSz)\n\t\t\tswitch success\n\t\t\tcase 0 {\n\t\t\t\trevert(0, retSz)\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, retSz)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction implementationAuthority() public view returns (address) {\n\t\taddress implemAuth;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\timplemAuth := sload(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc)\n\t\t}\n\t\treturn implemAuth;\n\t}\n}\n"
    },
    "src/proxy/ImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"../interface/IImplementationAuthority.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ImplementationAuthority is IImplementationAuthority, Ownable {\n\t// the address of implementation of ONCHAINID\n\taddress internal _implementation;\n\n\tconstructor(address implementation) {\n\t\trequire(implementation != address(0), \"invalid argument - zero address\");\n\t\t_implementation = implementation;\n\t\temit UpdatedImplementation(implementation);\n\t}\n\n\t/**\n\t *  @dev See {IImplementationAuthority-updateImplementation}.\n\t */\n\tfunction updateImplementation(address _newImplementation) external override onlyOwner {\n\t\trequire(_newImplementation != address(0), \"invalid argument - zero address\");\n\t\t_implementation = _newImplementation;\n\t\temit UpdatedImplementation(_newImplementation);\n\t}\n\n\t/**\n\t *  @dev See {IImplementationAuthority-getImplementation}.\n\t */\n\tfunction getImplementation() external view override returns (address) {\n\t\treturn _implementation;\n\t}\n}\n"
    },
    "src/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\nimport \"./Structs.sol\";\n\ncontract Storage is Structs {\n\t// nonce used by the execute/approve function\n\tuint256 internal _executionNonce;\n\n\t// keys as defined by IERC734\n\tmapping(bytes32 => Key) internal _keys;\n\n\t// keys for a given purpose\n\t// purpose 1 = MANAGEMENT\n\t// purpose 2 = ACTION\n\t// purpose 3 = CLAIM\n\tmapping(uint256 => bytes32[]) internal _keysByPurpose;\n\n\t// execution data\n\tmapping(uint256 => Execution) internal _executions;\n\n\t// claims held by the ONCHAINID\n\tmapping(bytes32 => Claim) internal _claims;\n\n\t// array of claims for a given topic\n\tmapping(uint256 => bytes32[]) internal _claimsByTopic;\n\n\t// status on initialization\n\tbool internal _initialized = false;\n\n\t// status on potential interactions with the contract\n\tbool internal _canInteract = false;\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "src/storage/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract Structs {\n\t/**\n\t *  @dev Definition of the structure of a Key.\n\t *\n\t *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\n\t *  The structure should be as follows:\n\t *  key: A public key owned by this identity\n\t *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\n\t *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  key: bytes32 The public key. // Its the Keccak256 hash of the key\n\t */\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of an Execution\n\t *\n\t *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\n\t *  to: address of contract to interact with, can be address(this)\n\t *  value: ETH to transfer with the transaction\n\t *  data: payload of the transaction to execute\n\t *  approved: approval status of the Execution\n\t *  executed: execution status of the Execution (set as false when the Execution is created\n\t *  and updated to true when the Execution is processed)\n\t */\n\tstruct Execution {\n\t\taddress to;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool approved;\n\t\tbool executed;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of a Claim.\n\t *\n\t *  Specification: Claims are information an issuer has about the identity holder.\n\t *  The structure should be as follows:\n\t *  claim: A claim published for the Identity.\n\t *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\n\t *  number schemes, sub topics based on number ranges??))\n\t *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\n\t *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\n\t *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  (ToBeDefined)\n\t *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\n\t *  identity contract, it should hold the key with which the above message was signed, if the key is not present\n\t *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\n\t *  claim can be verified using the call data.\n\t *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\n\t *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\n\t *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\n\t *  the claim scheme.\n\t *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t */\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n}\n"
    },
    "src/Test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract Test {\n\n} // solhint-disable-line\n"
    },
    "src/verifiers/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interface/IClaimIssuer.sol\";\n\ncontract Verifier is Ownable {\n\t/// @dev All topics of claims required to pass verification.\n\tuint256[] public requiredClaimTopics;\n\n\t/// @dev Array containing all TrustedIssuers identity contract address allowed to issue claims required.\n\tIClaimIssuer[] public trustedIssuers;\n\n\t/// @dev Mapping between a trusted issuer address and the topics of claims they are trusted for.\n\tmapping(address => uint256[]) public trustedIssuerClaimTopics;\n\n\t/// @dev Mapping between a claim topic and the trusted issuers trusted for it.\n\tmapping(uint256 => IClaimIssuer[]) public claimTopicsToTrustedIssuers;\n\n\t/**\n\t *  this event is emitted when a claim topic has been added to the requirement list\n\t *  the event is emitted by the 'addClaimTopic' function\n\t *  `claimTopic` is the required claim topic added\n\t */\n\tevent ClaimTopicAdded(uint256 indexed claimTopic);\n\n\t/**\n\t *  this event is emitted when a claim topic has been removed from the requirement list\n\t *  the event is emitted by the 'removeClaimTopic' function\n\t *  `claimTopic` is the required claim removed\n\t */\n\tevent ClaimTopicRemoved(uint256 indexed claimTopic);\n\n\t/**\n\t *  this event is emitted when an issuer is added to the trusted list.\n\t *  the event is emitted by the addTrustedIssuer function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\n\t */\n\tevent TrustedIssuerAdded(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\n\n\t/**\n\t *  this event is emitted when an issuer is removed from the trusted list.\n\t *  the event is emitted by the removeTrustedIssuer function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t */\n\tevent TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);\n\n\t/**\n\t *  this event is emitted when the set of claim topics is changed for a given trusted issuer.\n\t *  the event is emitted by the updateIssuerClaimTopics function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\n\t */\n\tevent ClaimTopicsUpdated(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\n\n\tmodifier onlyVerifiedSender() {\n\t\trequire(verify(_msgSender()), \"sender is not verified\");\n\t\t_;\n\t}\n\n\t/**\n\t *  @dev See {IClaimTopicsRegistry-removeClaimTopic}.\n\t */\n\tfunction addClaimTopic(uint256 claimTopic) public onlyOwner {\n\t\tuint256 length = requiredClaimTopics.length;\n\t\trequire(length < 15, \"cannot require more than 15 topics\");\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\trequire(requiredClaimTopics[i] != claimTopic, \"claimTopic already exists\");\n\t\t}\n\t\trequiredClaimTopics.push(claimTopic);\n\t\temit ClaimTopicAdded(claimTopic);\n\t}\n\n\t/**\n\t *  @dev See {IClaimTopicsRegistry-getClaimTopics}.\n\t */\n\tfunction removeClaimTopic(uint256 claimTopic) public onlyOwner {\n\t\tuint256 length = requiredClaimTopics.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (requiredClaimTopics[i] == claimTopic) {\n\t\t\t\trequiredClaimTopics[i] = requiredClaimTopics[length - 1];\n\t\t\t\trequiredClaimTopics.pop();\n\t\t\t\temit ClaimTopicRemoved(claimTopic);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-addTrustedIssuer}.\n\t */\n\tfunction addTrustedIssuer(IClaimIssuer trustedIssuer, uint256[] calldata claimTopics) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length == 0, \"trusted Issuer already exists\");\n\t\trequire(claimTopics.length > 0, \"trusted claim topics cannot be empty\");\n\t\trequire(claimTopics.length <= 15, \"cannot have more than 15 claim topics\");\n\t\trequire(trustedIssuers.length < 50, \"cannot have more than 50 trusted issuers\");\n\t\ttrustedIssuers.push(trustedIssuer);\n\t\ttrustedIssuerClaimTopics[address(trustedIssuer)] = claimTopics;\n\t\tfor (uint256 i = 0; i < claimTopics.length; i++) {\n\t\t\tclaimTopicsToTrustedIssuers[claimTopics[i]].push(trustedIssuer);\n\t\t}\n\t\temit TrustedIssuerAdded(trustedIssuer, claimTopics);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-removeTrustedIssuer}.\n\t */\n\tfunction removeTrustedIssuer(IClaimIssuer trustedIssuer) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"NOT a trusted issuer\");\n\t\tuint256 length = trustedIssuers.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (trustedIssuers[i] == trustedIssuer) {\n\t\t\t\ttrustedIssuers[i] = trustedIssuers[length - 1];\n\t\t\t\ttrustedIssuers.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (\n\t\t\tuint256 claimTopicIndex = 0;\n\t\t\tclaimTopicIndex < trustedIssuerClaimTopics[address(trustedIssuer)].length;\n\t\t\tclaimTopicIndex++\n\t\t) {\n\t\t\tuint256 claimTopic = trustedIssuerClaimTopics[address(trustedIssuer)][claimTopicIndex];\n\t\t\tuint256 topicsLength = claimTopicsToTrustedIssuers[claimTopic].length;\n\t\t\tfor (uint256 i = 0; i < topicsLength; i++) {\n\t\t\t\tif (claimTopicsToTrustedIssuers[claimTopic][i] == trustedIssuer) {\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic][i] = claimTopicsToTrustedIssuers[claimTopic][\n\t\t\t\t\t\ttopicsLength - 1\n\t\t\t\t\t];\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic].pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdelete trustedIssuerClaimTopics[address(trustedIssuer)];\n\t\temit TrustedIssuerRemoved(trustedIssuer);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-updateIssuerClaimTopics}.\n\t */\n\tfunction updateIssuerClaimTopics(IClaimIssuer trustedIssuer, uint256[] calldata newClaimTopics) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"NOT a trusted issuer\");\n\t\trequire(newClaimTopics.length <= 15, \"cannot have more than 15 claim topics\");\n\t\trequire(newClaimTopics.length > 0, \"claim topics cannot be empty\");\n\n\t\tfor (uint256 i = 0; i < trustedIssuerClaimTopics[address(trustedIssuer)].length; i++) {\n\t\t\tuint256 claimTopic = trustedIssuerClaimTopics[address(trustedIssuer)][i];\n\t\t\tuint256 topicsLength = claimTopicsToTrustedIssuers[claimTopic].length;\n\t\t\tfor (uint256 j = 0; j < topicsLength; j++) {\n\t\t\t\tif (claimTopicsToTrustedIssuers[claimTopic][j] == trustedIssuer) {\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic][j] = claimTopicsToTrustedIssuers[claimTopic][\n\t\t\t\t\t\ttopicsLength - 1\n\t\t\t\t\t];\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic].pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrustedIssuerClaimTopics[address(trustedIssuer)] = newClaimTopics;\n\t\tfor (uint256 i = 0; i < newClaimTopics.length; i++) {\n\t\t\tclaimTopicsToTrustedIssuers[newClaimTopics[i]].push(trustedIssuer);\n\t\t}\n\t\temit ClaimTopicsUpdated(trustedIssuer, newClaimTopics);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuers}.\n\t */\n\tfunction getTrustedIssuers() public view returns (IClaimIssuer[] memory) {\n\t\treturn trustedIssuers;\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuersForClaimTopic}.\n\t */\n\tfunction getTrustedIssuersForClaimTopic(uint256 claimTopic) public view returns (IClaimIssuer[] memory) {\n\t\treturn claimTopicsToTrustedIssuers[claimTopic];\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-isTrustedIssuer}.\n\t */\n\tfunction isTrustedIssuer(address issuer) public view returns (bool) {\n\t\tif (trustedIssuerClaimTopics[issuer].length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuerClaimTopics}.\n\t */\n\tfunction getTrustedIssuerClaimTopics(IClaimIssuer trustedIssuer) public view returns (uint256[] memory) {\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"trusted Issuer doesn't exist\");\n\t\treturn trustedIssuerClaimTopics[address(trustedIssuer)];\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-hasClaimTopic}.\n\t */\n\tfunction hasClaimTopic(address issuer, uint256 claimTopic) public view returns (bool) {\n\t\tuint256[] memory claimTopics = trustedIssuerClaimTopics[issuer];\n\t\tuint256 length = claimTopics.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (claimTopics[i] == claimTopic) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction isClaimTopicRequired(uint256 claimTopic) public view returns (bool) {\n\t\tuint256 length = requiredClaimTopics.length;\n\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (requiredClaimTopics[i] == claimTopic) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev Verify an identity (ONCHAINID) by checking if the identity has at least one valid claim from a trusted\n\t * issuer for each required claim topic. Returns true if the identity is compliant, false otherwise.\n\t */\n\tfunction verify(address identity) public view returns (bool isVerified) {\n\t\tif (requiredClaimTopics.length == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tuint256 foundClaimTopic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes memory sig;\n\t\tbytes memory data;\n\t\tuint256 claimTopic;\n\t\tfor (claimTopic = 0; claimTopic < requiredClaimTopics.length; claimTopic++) {\n\t\t\tIClaimIssuer[] memory trustedIssuersForClaimTopic = this.getTrustedIssuersForClaimTopic(\n\t\t\t\trequiredClaimTopics[claimTopic]\n\t\t\t);\n\n\t\t\tif (trustedIssuersForClaimTopic.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbytes32[] memory claimIds = new bytes32[](trustedIssuersForClaimTopic.length);\n\t\t\tfor (uint256 i = 0; i < trustedIssuersForClaimTopic.length; i++) {\n\t\t\t\tclaimIds[i] = keccak256(abi.encode(trustedIssuersForClaimTopic[i], requiredClaimTopics[claimTopic]));\n\t\t\t}\n\n\t\t\tfor (uint256 j = 0; j < claimIds.length; j++) {\n\t\t\t\t(foundClaimTopic, scheme, issuer, sig, data, ) = IIdentity(identity).getClaim(claimIds[j]);\n\n\t\t\t\tif (foundClaimTopic == requiredClaimTopics[claimTopic]) {\n\t\t\t\t\ttry\n\t\t\t\t\t\tIClaimIssuer(issuer).isClaimValid(\n\t\t\t\t\t\t\tIIdentity(identity),\n\t\t\t\t\t\t\trequiredClaimTopics[claimTopic],\n\t\t\t\t\t\t\tsig,\n\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t)\n\t\t\t\t\treturns (bool _validity) {\n\t\t\t\t\t\tif (_validity) {\n\t\t\t\t\t\t\tj = claimIds.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!_validity && j == (claimIds.length - 1)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tif (j == (claimIds.length - 1)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (j == (claimIds.length - 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"
    },
    "src/version/Version.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\n/**\n * @dev Version contract gives the versioning information of the implementation contract\n */\ncontract Version {\n\t/**\n\t * @dev Returns the string of the current version.\n\t */\n\tfunction version() external pure returns (string memory) {\n\t\t// version 2.2.0\n\t\treturn \"2.2.1\";\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}