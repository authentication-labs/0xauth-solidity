{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    },
    "src/bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Chainlink\nimport { IRouterClient } from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol';\nimport { CCIPReceiver } from '@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol';\nimport { Client } from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\n// OpenZeppelin\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n// Interfaces\nimport { IIdentity } from '../interface/IIdentity.sol';\nimport { Gateway } from '../gateway/Gateway.sol';\nimport '../factory/IIdFactory.sol';\n\ncontract CrossChainBridge is CCIPReceiver, ReentrancyGuard {\n  /// @notice REMOVE for prod\n  string public ccipMessage;\n\n  address immutable i_router;\n  address public idFactoryAddress;\n\n  // Map to store the messageIds of the messages sent\n  mapping(bytes32 => bool) public messageIds;\n\n  // Map to store allowedContracts\n  mapping(address => bool) public isAllowedContract;\n\n  // Map to store onlyManagers\n  mapping(address => bool) public isManager;\n\n  // Define the enum\n  enum AccessAddressTypes {\n    CONTRACT,\n    MANAGER\n  }\n\n  modifier onlyAllowedSender {\n    require(\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\n      'Permissions: Sender is not a allowed'\n    );\n    _;\n  }\n\n  modifier onlyAllowedContract() {\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\n    _;\n  }\n\n  modifier onlyManager() {\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\n    _;\n  }\n\n  modifier onlyAllowedIdentity(address _identity) {\n    IIdFactory idFactory = IIdFactory(idFactoryAddress);\n    require(idFactory.identityIsCreated(_identity), 'Permissions: idFactory marks this address as not identity');\n    _;\n  }\n\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\n\n  event MessageSent(bytes32 indexed messageId);\n  event MessageReceived(\n    bytes32 messageId,\n    uint64 indexed sourceChainSelector,\n    address indexed sender,\n    string indexed action\n  );\n  event IdFactoryUpdated(address indexed sender, address indexed newAddress);\n\n  constructor(address _router) CCIPReceiver(_router) {\n    i_router = _router;\n    isManager[msg.sender] = true;\n    emit AllowedAddress(msg.sender, uint64(AccessAddressTypes.MANAGER), true);\n  }\n\n  receive() external payable {}\n\n  function setFactoryAddress(address _idFactoryAddress) external onlyManager {\n    idFactoryAddress = _idFactoryAddress;\n    emit IdFactoryUpdated(msg.sender, _idFactoryAddress);\n  }\n\n  function sendAddClaim(\n    uint64 destinationChainSelector,\n    address receiver,\n    uint256 topic,\n    uint256 scheme,\n    address issuer,\n    bytes memory signature,\n    bytes memory data,\n    string memory uri\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, topic, scheme, issuer, signature, data, uri);\n    bytes memory metaPayload = abi.encode('AddClaim', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendRemoveClaim(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 claimId\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, claimId);\n    bytes memory metaPayload = abi.encode('RemoveClaim',_payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendAddKey(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 key,\n    uint256 purpose,\n    uint256 keyType\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, key, purpose, keyType);\n    bytes memory metaPayload = abi.encode('AddKey', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendRemoveKey(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 key,\n    uint256 purpose\n  ) external onlyAllowedIdentity(msg.sender) {\n     bytes memory _payload = abi.encode(msg.sender, key, purpose);\n    bytes memory metaPayload = abi.encode('RemoveKey', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendCreateIdentity(\n    uint64 destinationChainSelector,\n    address receiver,\n    address gateway,\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) external onlyAllowedSender {\n    bytes memory _payload = abi.encode(gateway, identityOwner, salt, managementKeys);\n    bytes memory metaPayload = abi.encode('CreateIdentity', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function _sendMessage(uint64 destinationChainSelector, address receiver, bytes memory payload) internal nonReentrant {\n    (uint256 fee, Client.EVM2AnyMessage memory message) = calculateFeeAndMessage(\n      destinationChainSelector,\n      receiver,\n      payload\n    );\n\n    bytes32 messageId = IRouterClient(i_router).ccipSend{ value: fee }(destinationChainSelector, message);\n\n    emit MessageSent(messageId);\n  }\n\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal override {\n    // Check if the message was already processed\n    require(!messageIds[message.messageId], 'Message already processed');\n    messageIds[message.messageId] = true;\n    // Decode the message data\n    (string memory action, bytes memory _payload) = abi.decode(message.data, (string, bytes));\n    if (keccak256(bytes(action)) == keccak256(bytes('AddClaim'))) {\n        (\n          address targetContract,\n          uint256 topic,\n          uint256 scheme,\n          address issuer,\n          bytes memory signature,\n          bytes memory decodedData,\n          string memory uri\n        ) = abi.decode(_payload, (address, uint256, uint256, address, bytes, bytes, string));\n        IIdentity(targetContract).addClaim(topic, scheme, issuer, signature, decodedData, uri);\n      } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveClaim'))) {\n        (address targetIdentity, bytes32 claimId) = abi.decode(_payload, (address,bytes32));\n        IIdentity(targetIdentity).removeClaim(claimId);\n    } else if (keccak256(bytes(action)) == keccak256(bytes('AddKey'))) {\n      (address targetIdentity, bytes32 key, uint256 purpose, uint256 keyType) = abi.decode(\n        _payload,\n        (address, bytes32, uint256, uint256)\n      );\n      IIdentity(targetIdentity).addKey(key, purpose, keyType);\n      } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveKey'))) {\n        (address targetIdentity, bytes32 key, uint256 purpose) = abi.decode(_payload, (address, bytes32, uint256));\n        IIdentity(targetIdentity).removeKey(key, purpose);\n    } else if (keccak256(bytes(action)) == keccak256(bytes('CreateIdentity'))) {\n      (address targetContract, address identityOwner, string memory salt, bytes32[] memory managementKeys) = abi.decode(\n        _payload,\n        (address, address, string, bytes32[])\n      );\n      Gateway(targetContract).deployIdentity(identityOwner, salt, managementKeys);\n    } else {\n      revert('Unknown action');\n    }\n    emit MessageReceived(message.messageId, message.sourceChainSelector, abi.decode(message.sender, (address)), action);\n  }\n\n  // Function to set allowed contracts\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\n    if (_status == true) {\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\n    }\n    isAllowedContract[_contract] = _status;\n\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\n  }\n\n  // Function to set manager status\n  function setManager(address _manager, bool _status) external onlyManager {\n    isManager[_manager] = _status;\n\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\n  }\n\n  /// @notice REMOVE for prod\n  function testSendMessage(\n    uint64 _destinationChainSelector,\n    address _receiver,\n    string memory _message\n  ) public onlyAllowedSender {\n    bytes memory payload = abi.encode(_message);\n    _sendMessage(_destinationChainSelector, _receiver, payload);\n  }\n\n  /// @notice REMOVE for prod\n  function _testRecieveMessage(Client.Any2EVMMessage memory any2EvmMessage) internal {\n    bytes32 s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\n    ccipMessage = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\n    emit MessageReceived(s_lastReceivedMessageId, 0, msg.sender, ccipMessage);\n  }\n\n  function calculateFeeAndMessage(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes memory payload\n  ) public view returns (uint256 fee, Client.EVM2AnyMessage memory message) {\n    message = Client.EVM2AnyMessage({\n      receiver: abi.encode(receiver),\n      data: payload,\n      tokenAmounts: new Client.EVMTokenAmount[](0),\n      extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: 1000000 })),\n      feeToken: address(0) // Use native token\n    });\n    fee = IRouterClient(i_router).getFee(destinationChainSelector, message);\n    return (fee, message);\n  }\n\n  // Function to withdraw native token from the contract\n  function withdraw(address _to, uint256 _amount) external onlyManager nonReentrant {\n    require(address(this).balance >= _amount, 'Insufficient balance');\n    Address.sendValue(payable(_to), _amount);\n  }\n}\n"
    },
    "src/ClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport './interface/IClaimIssuer.sol';\nimport './Identity.sol';\n\ncontract ClaimIssuer is IClaimIssuer, Identity {\n  mapping(bytes => bool) public revokedClaims;\n\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address initialManagementKey, address _idFactory) Identity(initialManagementKey, false, _idFactory) {}\n\n  /**\n   *  @dev See {IClaimIssuer-revokeClaimBySignature}.\n   */\n  function revokeClaimBySignature(bytes calldata signature) external override delegatedOnly onlyManager {\n    require(!revokedClaims[signature], 'Conflict: Claim already revoked');\n\n    revokedClaims[signature] = true;\n\n    emit ClaimRevoked(signature);\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-revokeClaim}.\n   */\n  function revokeClaim(bytes32 _claimId, address _identity) external override delegatedOnly onlyManager returns (bool) {\n    uint256 foundClaimTopic;\n    uint256 scheme;\n    address issuer;\n    bytes memory sig;\n    bytes memory data;\n\n    (foundClaimTopic, scheme, issuer, sig, data, ) = Identity(_identity).getClaim(_claimId);\n\n    require(!revokedClaims[sig], 'Conflict: Claim already revoked');\n\n    revokedClaims[sig] = true;\n    emit ClaimRevoked(sig);\n    return true;\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-isClaimValid}.\n   */\n  function isClaimValid(\n    IIdentity _identity,\n    uint256 claimTopic,\n    bytes memory sig,\n    bytes memory data\n  ) public view override(Identity, IClaimIssuer) returns (bool claimValid) {\n    bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n    // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n    bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', dataHash));\n\n    // Recover address of data signer\n    address recovered = getRecoveredAddress(sig, prefixedHash);\n\n    // Take hash of recovered address\n    bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n    // Does the trusted identifier have they key which signed the user's claim?\n    //  && (isClaimRevoked(_claimId) == false)\n    if (keyHasPurpose(hashedAddr, 3) && (isClaimRevoked(sig) == false)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-isClaimRevoked}.\n   */\n  function isClaimRevoked(bytes memory _sig) public view override returns (bool) {\n    if (revokedClaims[_sig]) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"
    },
    "src/factory/IdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport '../proxy/IdentityProxy.sol';\nimport './IIdFactory.sol';\nimport '../interface/IERC734.sol';\nimport { CrossChainBridge } from '../bridge/Bridge.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n/// @notice REMOVE in prod\nimport 'hardhat/console.sol';\n\ncontract IdFactory is IIdFactory, Ownable {\n  mapping(address => bool) private _tokenFactories;\n\n  // address of the _implementationAuthority contract making the link to the implementation contract\n  address private immutable _implementationAuthority;\n\n  // as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\n  // salt is taken and which is not\n  mapping(string => bool) private _saltTaken;\n\n  // ONCHAINID of the wallet owner\n  mapping(address => address) private _userIdentity;\n  mapping(address => address) private _identityWallet;\n\n  // wallets currently linked to an ONCHAINID\n  mapping(address => address[]) private _wallets;\n\n  // ONCHAINID of the token\n  mapping(address => address) private _tokenIdentity;\n\n  // token linked to an ONCHAINID\n  mapping(address => address) private _tokenAddress;\n\n  // flag to check if the contract is on the home chain\n  bool public _isHomeChain;\n\n  // DetinationChainSelectors and Receivers address (Receiver is the Bridge contract on the destination chain)\n  mapping(uint64 => address) public destinationChainSelectorToReceiver;\n  mapping(uint64 => address) public destinationChainSelectorToGateway;\n  uint64[] private chainSelectors;\n\n  // CrossChainBridge address\n  address public bridge;\n\n  // Map to store allowedContracts\n  mapping(address => bool) public isAllowedContract;\n\n  // Map to store onlyManagers\n  mapping(address => bool) public isManager;\n\n  // Map to store created identities\n  mapping(address => bool) public isCreatedIdentity;\n\n  // Define the enum\n  enum AccessAddressTypes {\n    CONTRACT,\n    MANAGER\n  }\n\n  modifier onlyAllowedSender() {\n    require(\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\n      'Permissions: Sender is not a allowed'\n    );\n    _;\n  }\n\n  modifier onlyAllowedContract() {\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\n    _;\n  }\n\n  modifier onlyManager() {\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\n    _;\n  }\n\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\n\n  // setting\n  constructor(address _owner, address implementationAuthority, bool isHomeChain) {\n    require(implementationAuthority != address(0), 'invalid argument - zero address');\n    require(_owner != address(0), 'invalid argument - zero address');\n\n    _implementationAuthority = implementationAuthority;\n    _isHomeChain = isHomeChain;\n    isManager[_owner] = true;\n    _transferOwnership(_owner);\n    emit AllowedAddress(_owner, uint64(AccessAddressTypes.MANAGER), true);\n  }\n\n  /**\n   *  @dev See {IdFactory-addTokenFactory}.\n   */\n  function addTokenFactory(address _factory) external override onlyOwner {\n    require(_factory != address(0), 'invalid argument - zero address');\n    require(!isTokenFactory(_factory), 'already a factory');\n    _tokenFactories[_factory] = true;\n    emit TokenFactoryAdded(_factory);\n  }\n\n  /**\n   *  @dev See {IdFactory-removeTokenFactory}.\n   */\n  function removeTokenFactory(address _factory) external override onlyOwner {\n    require(_factory != address(0), 'invalid argument - zero address');\n    require(isTokenFactory(_factory), 'not a factory');\n    _tokenFactories[_factory] = false;\n    emit TokenFactoryRemoved(_factory);\n  }\n\n  /**\n   *  @dev See {IdFactory-createIdentity}.\n   */\n  function createIdentity(\n    address _wallet,\n    string memory _salt\n  ) external override onlyAllowedSender returns (address identity) {\n    require(_wallet != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    require(!_saltTaken[_salt], 'salt already taken');\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\n    identity = _deployIdentity(_salt, _implementationAuthority, _wallet);\n    _saltTaken[_salt] = true;\n    _userIdentity[_wallet] = identity;\n    _identityWallet[identity] = _wallet;\n    _wallets[identity].push(_wallet);\n    emit WalletLinked(_wallet, identity);\n\n    isCreatedIdentity[identity] = true;\n    if (_isHomeChain == true) {\n      bytes32[] memory _keys;\n      _bridgeCreateIdentity(_wallet, _salt, _keys);\n    }\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-createIdentityWithManagementKeys}.\n   */\n  function createIdentityWithManagementKeys(\n    address _wallet,\n    string memory _salt,\n    bytes32[] memory _managementKeys\n  ) external override onlyAllowedSender returns (address) {\n    require(_wallet != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    string memory oidSalt = string.concat('OID', _salt);\n    require(!_saltTaken[oidSalt], 'salt already taken');\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\n    require(_managementKeys.length > 0, 'invalid argument - empty list of keys');\n\n    address identity = _deployIdentity(oidSalt, _implementationAuthority, address(this));\n\n    _saltTaken[oidSalt] = true;\n    _userIdentity[_wallet] = identity;\n    _identityWallet[identity] = _wallet;\n    _wallets[identity].push(_wallet);\n    isCreatedIdentity[identity] = true;\n    if (_isHomeChain == true) {\n      _bridgeCreateIdentity(_wallet, _salt, _managementKeys);\n    }\n    for (uint i = 0; i < _managementKeys.length; i++) {\n      require(\n        _managementKeys[i] != keccak256(abi.encode(_wallet)),\n        'invalid argument - wallet is also listed in management keys'\n      );\n      IERC734(identity).addKey(_managementKeys[i], 1, 1);\n    }\n\n    IERC734(identity).removeKey(keccak256(abi.encode(address(this))), 1);\n\n    emit WalletLinked(_wallet, identity);\n\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-createTokenIdentity}.\n   */\n  function createTokenIdentity(\n    address _token,\n    address _tokenOwner,\n    string memory _salt\n  ) external override returns (address) {\n    require(isTokenFactory(msg.sender) || msg.sender == owner(), 'only Factory or owner can call');\n    require(_token != address(0), 'invalid argument - zero address');\n    require(_tokenOwner != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    string memory tokenIdSalt = string.concat('Token', _salt);\n    require(!_saltTaken[tokenIdSalt], 'salt already taken');\n    require(_tokenIdentity[_token] == address(0), 'token already linked to an identity');\n    address identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\n    _saltTaken[tokenIdSalt] = true;\n    _tokenIdentity[_token] = identity;\n    _tokenAddress[identity] = _token;\n    emit TokenLinked(_token, identity);\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-linkWallet}.\n   */\n  function linkWallet(address _newWallet) external override {\n    require(_newWallet != address(0), 'invalid argument - zero address');\n    require(_userIdentity[msg.sender] != address(0), 'wallet not linked to an identity contract');\n    require(_userIdentity[_newWallet] == address(0), 'new wallet already linked');\n    require(_tokenIdentity[_newWallet] == address(0), 'invalid argument - token address');\n    address identity = _userIdentity[msg.sender];\n    require(_wallets[identity].length < 101, 'max amount of wallets per ID exceeded');\n    _userIdentity[_newWallet] = identity;\n    _wallets[identity].push(_newWallet);\n    emit WalletLinked(_newWallet, identity);\n  }\n\n  /**\n   *  @dev See {IdFactory-unlinkWallet}.\n   */\n  function unlinkWallet(address _oldWallet) external override {\n    require(_oldWallet != address(0), 'invalid argument - zero address');\n    require(_oldWallet != msg.sender, 'cannot be called on sender address');\n    require(_userIdentity[msg.sender] == _userIdentity[_oldWallet], 'only a linked wallet can unlink');\n    address _identity = _userIdentity[_oldWallet];\n    delete _userIdentity[_oldWallet];\n    uint256 length = _wallets[_identity].length;\n    for (uint256 i = 0; i < length; i++) {\n      if (_wallets[_identity][i] == _oldWallet) {\n        _wallets[_identity][i] = _wallets[_identity][length - 1];\n        _wallets[_identity].pop();\n        break;\n      }\n    }\n    emit WalletUnlinked(_oldWallet, _identity);\n  }\n\n  /**\n   *  @dev See {IdFactory-addReceiver}.\n   */\n\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external override onlyOwner {\n    require(_receiver != address(0), 'invalid argument - zero address');\n    require(destinationChainSelectorToReceiver[_chainSelector] == address(0), 'receiver already added');\n    require(destinationChainSelectorToGateway[_chainSelector] == address(0), 'gateway already added');\n\n    destinationChainSelectorToReceiver[_chainSelector] = _receiver;\n    destinationChainSelectorToGateway[_chainSelector] = _gateway;\n\n    chainSelectors.push(_chainSelector);\n    emit ReceiverAdded(_chainSelector, _receiver, _gateway);\n  }\n\n  /**\n   *  @dev See {IdFactory-removeReceiver}.\n   */\n\n  function removeReceiver(uint64 _chainSelector) external override onlyOwner {\n    require(destinationChainSelectorToReceiver[_chainSelector] != address(0), 'receiver not added');\n    delete destinationChainSelectorToReceiver[_chainSelector];\n    delete destinationChainSelectorToGateway[_chainSelector];\n\n    uint256 length = chainSelectors.length;\n    for (uint256 i = 0; i < length; i++) {\n      if (chainSelectors[i] == _chainSelector) {\n        chainSelectors[i] = chainSelectors[length - 1];\n        chainSelectors.pop();\n        break;\n      }\n    }\n    emit ReceiverRemoved(_chainSelector);\n  }\n\n  /**\n   *  @dev See {IdFactory-getChainSelectors}.\n   */\n\n  function getChainSelectors() external view override returns (uint64[] memory) {\n    return chainSelectors;\n  }\n\n  /**\n   *  @dev See {IdFactory-getReceiver}.\n   */\n\n  function getReceiver(uint64 _chainSelector) external view override returns (address) {\n    return destinationChainSelectorToReceiver[_chainSelector];\n  }\n\n  function getGateway(uint64 _chainSelector) external view returns (address) {\n    return destinationChainSelectorToGateway[_chainSelector];\n  }\n\n  /**\n   *  @dev See {IdFactory-getReceivers}.\n   */\n\n  function getReceivers() external view override returns (address[] memory) {\n    address[] memory receivers = new address[](chainSelectors.length);\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\n      receivers[i] = destinationChainSelectorToReceiver[chainSelectors[i]];\n    }\n    return receivers;\n  }\n\n  /**\n   *  @dev See {IdFactory-getIdentity}.\n   */\n  function getIdentity(address _wallet) public view override returns (address) {\n    if (_tokenIdentity[_wallet] != address(0)) {\n      return _tokenIdentity[_wallet];\n    } else {\n      return _userIdentity[_wallet];\n    }\n  }\n\n  /**\n   *  @dev See {IdFactory-isSaltTaken}.\n   */\n  function isSaltTaken(string calldata _salt) external view override returns (bool) {\n    return _saltTaken[_salt];\n  }\n\n  /**\n   *  @dev See {IdFactory-getWallets}.\n   */\n  function getWallets(address _identity) external view override returns (address[] memory) {\n    return _wallets[_identity];\n  }\n\n  /**\n   *  @dev See {IdFactory-getToken}.\n   */\n  function getToken(address _identity) external view override returns (address) {\n    return _tokenAddress[_identity];\n  }\n\n  /**\n   *  @dev See {IdFactory-isTokenFactory}.\n   */\n  function isTokenFactory(address _factory) public view override returns (bool) {\n    return _tokenFactories[_factory];\n  }\n\n  /**\n   *  @dev See {IdFactory-implementationAuthority}.\n   */\n  function implementationAuthority() public view override returns (address) {\n    return _implementationAuthority;\n  }\n\n  /**\n   *\n   * @param _bridge the address of the bridge contract\n   */\n  function setBridge(address _bridge) external onlyOwner {\n    require(_bridge != address(0), 'invalid argument - zero address');\n    bridge = _bridge;\n  }\n\n  /**\n   *  @dev get bridge address\n   */\n  function getBridge() external view returns (address) {\n    return bridge;\n  }\n\n  // deploy function with create2 opcode call\n  // returns the address of the contract created\n  function _deploy(string memory salt, bytes memory bytecode) private returns (address) {\n    bytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\n    address addr;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let encoded_data := add(0x20, bytecode) // load initialization code.\n      let encoded_size := mload(bytecode) // load init code's length.\n      addr := create2(0, encoded_data, encoded_size, saltBytes)\n      if iszero(extcodesize(addr)) {\n        revert(0, 0)\n      }\n    }\n    emit Deployed(addr);\n    return addr;\n  }\n\n  // function used to deploy an identity using CREATE2\n  function _deployIdentity(\n    string memory _salt,\n    address implementationAuthority,\n    address _wallet\n  ) private returns (address) {\n    bytes memory _code = type(IdentityProxy).creationCode;\n    bytes memory _constructData = abi.encode(implementationAuthority, _wallet, address(this));\n    bytes memory bytecode = abi.encodePacked(_code, _constructData);\n    return _deploy(_salt, bytecode);\n  }\n\n  function _bridgeCreateIdentity(\n    address _wallet,\n    string memory oidSalt,\n    bytes32[] memory managementKeys // uint256 signatureExpiry, // bytes calldata signature\n  ) internal {\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\n      CrossChainBridge bridgeContract = CrossChainBridge(payable(bridge));\n      bridgeContract.sendCreateIdentity(\n        chainSelectors[i],\n        destinationChainSelectorToReceiver[chainSelectors[i]],\n        destinationChainSelectorToGateway[chainSelectors[i]],\n        _wallet,\n        oidSalt,\n        managementKeys\n        // signatureExpiry,\n        // signature\n      );\n    }\n  }\n\n  // Function to set allowed contracts\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\n    if (_status == true) {\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\n    }\n    isAllowedContract[_contract] = _status;\n\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\n  }\n\n  // Function to set manager status\n  function setManager(address _manager, bool _status) external onlyManager {\n    isManager[_manager] = _status;\n\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\n  }\n\n  function identityIsCreated(address _identity) external view returns (bool) {\n    return isCreatedIdentity[_identity];\n  }\n\n  function addedKey(\n    bool isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) public {\n      \n    require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n    emit AddedKey(_identityWallet[msg.sender], _key, _purpose, _type);\n    IERC734(msg.sender).isComingFromIdentity(false);\n\n  }\n\n    function addedClaim(\n    bool isTrue,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) public {\n    \n    // require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n    emit AddedClaim(_identityWallet[msg.sender],_topic, _scheme, _issuer, _signature, _data, _uri);\n    IERC734(msg.sender).isComingFromIdentity(false);\n\n  }\n\n\n  function removedKey(\n    bool isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) public {\n      \n    // require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n    emit RemovedKey(_identityWallet[msg.sender], _key, _purpose, _type);\n    IERC734(msg.sender).isComingFromIdentity(false);\n\n  }\n\n    function removedClaim(\n    bool isTrue,\n    bytes32 _claimId,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) public {\n    \n    // require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n    emit RemovedClaim(_identityWallet[msg.sender], _claimId,_topic, _scheme, _issuer, _signature, _data, _uri);\n    IERC734(msg.sender).isComingFromIdentity(false);\n\n  }\n\n}"
    },
    "src/factory/IIdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ninterface IIdFactory {\n  /// events\n\n\t// AddedKey to notify everyone when key added without listening to long list of identity addresses\n\tevent AddedKey(address user, bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n  // RemovedKey to notify everyone when key removed without listening to long list of identity addresses\n\tevent RemovedKey(address user, bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\n\t// AddedClaim to notify everyone when claim added without listening to long list of identity addresses\n\tevent AddedClaim(\n    address indexed user,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\tevent RemovedClaim(\n    address user,\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n  // event emitted whenever a single contract is deployed by the factory\n  event Deployed(address indexed _addr);\n\n  // event emitted when a wallet is linked to an ONCHAINID contract\n  event WalletLinked(address indexed wallet, address indexed identity);\n\n  // event emitted when a token is linked to an ONCHAINID contract\n  event TokenLinked(address indexed token, address indexed identity);\n\n  // event emitted when a wallet is unlinked from an ONCHAINID contract\n  event WalletUnlinked(address indexed wallet, address indexed identity);\n\n  // event emitted when an address is registered on the factory as a Token\n  // factory address, granting this address the privilege to issue\n  // Onchain identities for tokens\n  event TokenFactoryAdded(address indexed factory);\n\n  // event emitted when a previously recorded token factory address is removed\n  event TokenFactoryRemoved(address indexed factory);\n\n  // event emitted when a receiver is added for a chainSelector\n  event ReceiverAdded(uint64 chainSelector, address receiver, address gateway);\n\n  // event emitted when a receiver is removed for a chainSelector\n  event ReceiverRemoved(uint64 chainSelector);\n\n  /// functions\n\n  /**\n   *  @dev function used to create a new Identity proxy from the factory\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n   *  @param _salt the salt used by create2 to issue the contract\n   *  requires a new salt for each deployment\n   *  _wallet cannot be linked to another ONCHAINID\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n   *  of the function, including calls to oracles for multichain\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\n   */\n  function createIdentity(address _wallet, string memory _salt) external returns (address);\n\n  /**\n   *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\n   * MANAGEMENT keys.\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n   *  @param _salt the salt used by create2 to issue the contract\n   *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\n   *  requires a new salt for each deployment\n   *  _wallet cannot be linked to another ONCHAINID\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n   *  of the function, including calls to oracles for multichain\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\n   */\n  function createIdentityWithManagementKeys(\n    address _wallet,\n    string memory _salt,\n    bytes32[] memory _managementKeys\n  ) external returns (address);\n\n  /**\n   *  @dev function used to create a new Token Identity proxy from the factory\n   *  @param _token the address of the token contract\n   *  @param _tokenOwner the owner address of the token\n   *  @param _salt the salt used by create2 to issue the contract\n   *  requires a new salt for each deployment\n   *  _token cannot be linked to another ONCHAINID\n   *  only Token factory or owner can call (owner should only use its privilege\n   *  for tokens not issued by a Token factory onchain\n   */\n  function createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\n\n  /**\n   * @dev function used to update bridge contract address\n   * @param _bridge the address of the bridge contract\n   * can be called only by Owner\n   */\n\n  function setBridge(address _bridge) external;\n\n  /**\n   *  @dev function used to link a new wallet to an existing identity\n   *  @param _newWallet the address of the wallet to link\n   *  requires msg.sender to be linked to an existing onchainid\n   *  the _newWallet will be linked to the same OID contract as msg.sender\n   *  _newWallet cannot be linked to an OID yet\n   *  _newWallet cannot be address 0\n   *  cannot link more than 100 wallets to an OID, for gas consumption reason\n   */\n  function linkWallet(address _newWallet) external;\n\n  /**\n   *  @dev function used to unlink a wallet from an existing identity\n   *  @param _oldWallet the address of the wallet to unlink\n   *  requires msg.sender to be linked to the same onchainid as _oldWallet\n   *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\n   *  _oldWallet cannot be address 0\n   */\n  function unlinkWallet(address _oldWallet) external;\n\n  /**\n   *  @dev function used to register an address as a token factory\n   *  @param _factory the address of the token factory\n   *  can be called only by Owner\n   *  _factory cannot be registered yet\n   *  once the factory has been registered it can deploy token identities\n   */\n  function addTokenFactory(address _factory) external;\n\n  /**\n   *  @dev function used to unregister an address previously registered as a token factory\n   *  @param _factory the address of the token factory\n   *  can be called only by Owner\n   *  _factory has to be registered previously\n   *  once the factory has been unregistered it cannot deploy token identities anymore\n   */\n  function removeTokenFactory(address _factory) external;\n\n  /**\n   *  @dev function used to add a receiver for a chainSelector\n   *  @param _chainSelector the chainSelector for which the receiver is added\n   *  @param _receiver the address of the receiver\n   *  @param _gateway the address of the gateway\n   *  can be called only by Owner\n   *  _receiver cannot be registered yet\n   *  once the receiver has been registered it can receive messages from the chainSelector\n   */\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external;\n\n  /**\n   *  @dev function used to remove a receiver for a chainSelector\n   *  @param _chainSelector the chainSelector for which the receiver is removed\n   *  can be called only by Owner\n   *  _receiver has to be registered previously\n   *  once the receiver has been removed it cannot receive messages from the chainSelector anymore\n   */\n  function removeReceiver(uint64 _chainSelector) external;\n\n  /**\n   *  @dev getter for OID contract corresponding to a wallet/token\n   *  @param _wallet the wallet/token address\n   */\n  function getIdentity(address _wallet) external view returns (address);\n\n  /**\n   *  @dev getter to fetch the array of wallets linked to an OID contract\n   *  @param _identity the address of the OID contract\n   *  returns an array of addresses linked to the OID\n   */\n  function getWallets(address _identity) external view returns (address[] memory);\n\n  /**\n   *  @dev getter to fetch the token address linked to an OID contract\n   *  @param _identity the address of the OID contract\n   *  returns the address linked to the OID\n   */\n  function getToken(address _identity) external view returns (address);\n\n  /**\n   *  @dev getter to know if an address is registered as token factory or not\n   *  @param _factory the address of the factory\n   *  returns true if the address corresponds to a registered factory\n   */\n  function isTokenFactory(address _factory) external view returns (bool);\n\n  /**\n   *  @dev getter to know if a salt is taken for the create2 deployment\n   *  @param _salt the salt used for deployment\n   */\n  function isSaltTaken(string calldata _salt) external view returns (bool);\n\n  /**\n   * @dev getter for the implementation authority used by this factory.\n   */\n  function implementationAuthority() external view returns (address);\n\n  /**\n   * @dev getter for the receiver of a chainSelector\n   * @param _chainSelector the chainSelector for which the receiver is fetched\n   */\n  function getReceiver(uint64 _chainSelector) external view returns (address);\n\n  /**\n   * @dev getter for the list of chainSelectors\n   */\n  function getChainSelectors() external view returns (uint64[] memory);\n\n  /**\n   * @dev getter for the list of receivers\n   */\n  function getReceivers() external view returns (address[] memory);\n\n  /**\n   * @dev getter for the bridge contract address\n   */\n  function bridge() external view returns (address);\n\n  /**\n   * @dev getter for the created Identites\n   */\n  function identityIsCreated(address identity) external view returns (bool);\n\n  function addedKey(\n    bool _isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) external;\n\n    function addedClaim(\n    bool _isTrue,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) external;\n\n\n  function removedKey(\n    bool _isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) external;\n\n    function removedClaim(\n    bool _isTrue,\n    bytes32 _claimId,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) external;\n\n\n}\n"
    },
    "src/factory/IssuerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n\nimport \"../ClaimIssuer.sol\";\n\n\ncontract IssuerFactory {\n    event Deployed(address addr, bytes32 salt);\n\n    mapping(bytes32 => bool) private _saltUsed;\n\n    function _deploy(string memory salt, bytes memory bytecode) public returns (address) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        require(!_saltUsed[saltBytes], \"Salt already used\");\n\n        address addr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, bytecode) // load initialization code.\n            let encoded_size := mload(bytecode) // load init code's length.\n            addr := create2(0, encoded_data, encoded_size, saltBytes)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        emit Deployed(addr, saltBytes);\n        _saltUsed[saltBytes] = true;\n        return addr;\n    }\n\n    function deployClaimIssuer(\n        string memory salt,\n        address implementationAuthority,\n        address wallet\n    ) public returns (address) {\n        bytes memory code = type(ClaimIssuer).creationCode;\n        bytes memory constructData = abi.encode(implementationAuthority, wallet);\n        bytes memory bytecode = abi.encodePacked(code, constructData);\n        return _deploy(salt, bytecode);\n    }\n\n    function isSaltUsed(string memory salt) public view returns (bool) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        return _saltUsed[saltBytes];\n    }\n}"
    },
    "src/gateway/Gateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '../factory/IdFactory.sol';\n// import '../bridge/Bridge.sol';\n\nusing ECDSA for bytes32;\n\n/// A required parameter was set to the Zero address.\nerror ZeroAddress();\n/// The maximum number of signers was reached at deployment.\nerror TooManySigners();\n/// The signed attempted to add was already approved.\nerror SignerAlreadyApproved(address signer);\n/// The signed attempted to remove was not approved.\nerror SignerAlreadyNotApproved(address signer);\n/// A requested ONCHAINID deployment was requested without a valid signature while the Gateway requires one.\nerror UnsignedDeployment();\n/// A requested ONCHAINID deployment was requested and signer by a non approved signer.\nerror UnapprovedSigner(address signer);\n/// A requested ONCHAINID deployment was requested with a signature revoked.\nerror RevokedSignature(bytes signature);\n/// A requested ONCHAINID deployment was requested with a signature that expired.\nerror ExpiredSignature(bytes signature);\n/// Attempted to revoke a signature that was already revoked.\nerror SignatureAlreadyRevoked(bytes signature);\n/// Attempted to approve a signature that was not revoked.\nerror SignatureNotRevoked(bytes signature);\n\ncontract Gateway is Ownable {\n  IdFactory public idFactory;\n  mapping(address => bool) public approvedSigners;\n  mapping(bytes => bool) public revokedSignatures;\n\n  event SignerApproved(address indexed signer);\n  event SignerRevoked(address indexed signer);\n  event SignatureRevoked(bytes indexed signature);\n  event SignatureApproved(bytes indexed signature);\n\n  /**\n   *  @dev Constructor for the ONCHAINID Factory Gateway.\n   *  @param idFactoryAddress the address of the factory to operate (the Gateway must be owner of the Factory).\n   */\n  constructor(address idFactoryAddress, address[] memory signersToApprove) Ownable() {\n    if (idFactoryAddress == address(0)) {\n      revert ZeroAddress();\n    }\n    if (signersToApprove.length > 10) {\n      revert TooManySigners();\n    }\n\n    for (uint i = 0; i < signersToApprove.length; i++) {\n      approvedSigners[signersToApprove[i]] = true;\n    }\n\n    idFactory = IdFactory(idFactoryAddress);\n  }\n\n  /**\n   *  @dev Approve a signer to sign ONCHAINID deployments. If the Gateway is setup to require signature, only\n   *  deployments requested with a valid signature from an approved signer will be accepted.\n   *  If the gateway does not require a signature,\n   *  @param signer the signer address to approve.\n   */\n  function approveSigner(address signer) external onlyOwner {\n    if (signer == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (approvedSigners[signer]) {\n      revert SignerAlreadyApproved(signer);\n    }\n\n    approvedSigners[signer] = true;\n\n    emit SignerApproved(signer);\n  }\n\n  /**\n   *  @dev Revoke a signer to sign ONCHAINID deployments.\n   *  @param signer the signer address to revoke.\n   */\n  function revokeSigner(address signer) external onlyOwner {\n    if (signer == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[signer]) {\n      revert SignerAlreadyNotApproved(signer);\n    }\n\n    delete approvedSigners[signer];\n\n    emit SignerRevoked(signer);\n  }\n\n  function deployIdentity(\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) public returns (address) {\n    if (managementKeys.length == 0) {\n      return deployIdentityWithSalt(identityOwner, salt);\n    } else {\n      return deployIdentityWithSaltAndManagementKeys(identityOwner, salt, managementKeys);\n    }\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt.\n   *  @param identityOwner the address to set as a management key.\n   *  @param salt to use for the deployment.\n   */\n  function deployIdentityWithSalt(address identityOwner, string memory salt) public returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[msg.sender]) {\n      revert UnapprovedSigner(msg.sender);\n    }\n\n    return idFactory.createIdentity(identityOwner, salt);\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt and a custom list of\n   *  management keys. Note that the identity Owner address won't be added as a management keys, if this is desired,\n   *  the key hash must be listed in the managementKeys array.\n   *  @param identityOwner the address to set as a management key.\n   *  @param salt to use for the deployment.\n   *  @param managementKeys the list of management keys to add to the ONCHAINID.\n   */\n  function deployIdentityWithSaltAndManagementKeys(\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) public returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[msg.sender]) {\n      revert UnapprovedSigner(msg.sender);\n    }\n\n    address identity = idFactory.createIdentityWithManagementKeys(identityOwner, salt, managementKeys);\n\n    // bool isHomeChain = idFactory._isHomeChain();\n\n    // if (isHomeChain) {\n    //   address bridgeAddress = idFactory.getBridge();\n    //   // Explicit conversion to payable address and then to CrossChainBridge\n    //   CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n    //   // Get Destination Chain Selectors and their receivers\n    //   address[] memory receivers = idFactory.getReceivers();\n    //   uint64[] memory chainSelectors = idFactory.getChainSelectors();\n    // Send the CreateIdentity message to the bridge\n    //   for (uint i = 0; i < receivers.length; i++) {\n    //     if (receivers[i] != address(bridge)) {\n    //       bridge.sendCreateIdentity(\n    //         chainSelectors[i],\n    //         receivers[i],\n    //         address(this),\n    //         identityOwner,\n    //         salt,\n    //         managementKeys,\n    //         signatureExpiry,\n    //         signature\n    //       );\n    //     }\n    //   }\n    // }\n\n    return identity;\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory using the identityOwner address as salt.\n   *  @param identityOwner the address to set as a management key.\n   */\n  function deployIdentityForWallet(address identityOwner) external returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    return idFactory.createIdentity(identityOwner, Strings.toHexString(identityOwner));\n  }\n\n  /**\n   *  @dev Revoke a signature, if the signature is used to deploy an ONCHAINID, the deployment would be rejected.\n   *  @param signature the signature to revoke.\n   */\n  function revokeSignature(bytes calldata signature) external onlyOwner {\n    if (revokedSignatures[signature]) {\n      revert SignatureAlreadyRevoked(signature);\n    }\n\n    revokedSignatures[signature] = true;\n\n    emit SignatureRevoked(signature);\n  }\n\n  /**\n   *  @dev Remove a signature from the revoke list.\n   *  @param signature the signature to approve.\n   */\n  function approveSignature(bytes calldata signature) external onlyOwner {\n    if (!revokedSignatures[signature]) {\n      revert SignatureNotRevoked(signature);\n    }\n\n    delete revokedSignatures[signature];\n\n    emit SignatureApproved(signature);\n  }\n\n  /**\n   *  @dev Transfer the ownership of the factory to a new owner.\n   *  @param newOwner the new owner of the factory.\n   */\n  function transferFactoryOwnership(address newOwner) external onlyOwner {\n    idFactory.transferOwnership(newOwner);\n  }\n\n  /**\n   *  @dev Call a function on the factory. Only the owner of the Gateway can call this method.\n   *  @param data the data to call on the factory.\n   */\n  function callFactory(bytes memory data) external onlyOwner {\n    (bool success, ) = address(idFactory).call(data);\n    require(success, 'Gateway: call to factory failed');\n  }\n}\n"
    },
    "src/Identity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport './interface/IIdentity.sol';\nimport './interface/IClaimIssuer.sol';\nimport './version/Version.sol';\nimport './storage/Storage.sol';\nimport { CrossChainBridge } from './bridge/Bridge.sol';\n\n/**\n * @dev Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces\n * into a common Identity Contract.\n * This implementation has a separate contract were it declares all storage,\n * allowing for it to be used as an upgradable logic contract.\n */\ncontract Identity is Storage, IIdentity, Version {\n  /**\n   * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\n   */\n  modifier delegatedOnly() {\n    require(_canInteract == true, 'Interacting with the library contract is forbidden.');\n    _;\n  }\n\n  /**\n   * @notice requires management key to call this function, or internal call\n   */\n  modifier onlyManager() {\n    require(\n      msg.sender == address(this) ||\n        msg.sender == idFactory.getBridge() ||\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 1),\n      'Permissions: Sender does not have management key'\n    );\n    _;\n  }\n\n  /**\n   * @notice requires claim key to call this function, or internal call\n   */\n  modifier onlyClaimKey() {\n    require(\n      msg.sender == address(this) ||\n        msg.sender == idFactory.getBridge() ||\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 3),\n      'Permissions: Sender does not have claim signer key'\n    );\n    _;\n  }\n\n  /**\n   * @notice constructor of the Identity contract\n   * @param initialManagementKey the address of the management key at deployment\n   * @param _isLibrary boolean value stating if the contract is library or not\n   * calls __Identity_init if contract is not library\n   */\n  constructor(address initialManagementKey, bool _isLibrary, address idFactoryAddress) {\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n\n    if (!_isLibrary) {\n      __Identity_init(initialManagementKey, idFactoryAddress);\n    } else {\n      _initialized = true;\n    }\n    userWallet = initialManagementKey;\n    idFactory = IdFactory(idFactoryAddress);\n  }\n\n  /**\n   * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\n   *\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n   */\n  function initialize(address initialManagementKey, address _idFactoryAddress) external {\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n    __Identity_init(initialManagementKey, _idFactoryAddress);\n  }\n\n  /**\n   * @dev See {IERC734-execute}.\n   * @notice Passes an execution instruction to the keymanager.\n   * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n   * execution is immediately approved and performed.\n   * If the destination address is the identity itself, then the execution would be performed immediately only if\n   * the sender is a MANAGEMENT key.\n   * Otherwise the execution request must be approved via the `approve` method.\n   * @return executionId to use in the approve function, to approve or reject this execution.\n   */\n  function execute(\n    address _to,\n    uint256 _value,\n    bytes memory _data\n  ) external payable override delegatedOnly returns (uint256 executionId) {\n    uint256 _executionId = _executionNonce;\n    _executions[_executionId].to = _to;\n    _executions[_executionId].value = _value;\n    _executions[_executionId].data = _data;\n    _executionNonce++;\n\n    emit ExecutionRequested(_executionId, _to, _value, _data);\n\n    if (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\n      approve(_executionId, true);\n    } else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)) {\n      approve(_executionId, true);\n    }\n\n    return _executionId;\n  }\n\n  /**\n   * @dev See {IERC734-getKey}.\n   * @notice Implementation of the getKey function from the ERC-734 standard\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n   * @return purposes Returns the full key data, if present in the identity.\n   * @return keyType Returns the full key data, if present in the identity.\n   * @return key Returns the full key data, if present in the identity.\n   */\n  function getKey(\n    bytes32 _key\n  ) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n    return (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\n  }\n\n  /**\n   * @dev See {IERC734-getKeyPurposes}.\n   * @notice gets the purposes of a key\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n   * @return _purposes Returns the purposes of the specified key\n   */\n  function getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n    return (_keys[_key].purposes);\n  }\n\n  /**\n   * @dev See {IERC734-getKeysByPurpose}.\n   * @notice gets all the keys with a specific purpose from an identity\n   * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n   * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\n   */\n  function getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory keys) {\n    return _keysByPurpose[_purpose];\n  }\n\n  /**\n   * @dev See {IERC735-getClaimIdsByTopic}.\n   * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\n   * used to get all the claims from the specified topic\n   * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   * @return claimIds Returns an array of claim IDs by topic.\n   */\n  function getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds) {\n    return _claimsByTopic[_topic];\n  }\n\n  function isComingFromIdentity(bool done) public returns (bool) {\n    if (msg.sender == address(idFactory) && done == false) {\n      isComing = false;\n    }\n    return isComing;\n  }\n\n  /**\n   * @notice implementation of the addKey function of the ERC-734 standard\n   * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\n   * 1: MANAGEMENT keys, which can manage the identity\n   * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n   * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n   * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n   * MUST only be done by keys of purpose 1, or the identity itself.\n   * If its the identity itself, the approval process will determine its approval.\n   * @param _key keccak256 representation of an ethereum address\n   * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n   * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n   * @return success Returns TRUE if the addition was successful and FALSE if not\n   */\n  function addKey(\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n  ) public override delegatedOnly onlyManager returns (bool success) {\n    if (_keys[_key].key == _key) {\n      uint256[] memory _purposes = _keys[_key].purposes;\n      for (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\n        uint256 purpose = _purposes[keyPurposeIndex];\n\n        if (purpose == _purpose) {\n          revert('Conflict: Key already has purpose');\n        }\n      }\n\n      _keys[_key].purposes.push(_purpose);\n    } else {\n      _keys[_key].key = _key;\n      _keys[_key].purposes = [_purpose];\n      _keys[_key].keyType = _type;\n    }\n\n    _keysByPurpose[_purpose].push(_key);\n    \n    emit KeyAdded(_key, _purpose, _type);\n\n    // So OZ Defender doesn't initiate stellar transactions when creating Identity With Management Keys\n    if (msg.sender != address(idFactory)) {      \n      isComing = true;\n      idFactory.addedKey(\n      isComing,\n      _key,\n      _purpose,\n      _type\n      );\n    }\n\n    isComing = false;\n\n    bool isHomeChain = idFactory._isHomeChain();\n    // Don't send message when calling via createIdentityWithManagementKeys\n    if (isHomeChain && msg.sender != address(idFactory)) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendAddKey(chainSelectors[i], receivers[i], _key, _purpose, _type);\n      }\n    } else {}\n\n    return true;\n  }\n\n  /**\n   *  @dev See {IERC734-approve}.\n   *  @notice Approves an execution.\n   *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n   *  approval is authorized and the operation would be performed.\n   *  If the destination address is the identity itself, then the execution would be authorized and performed only\n   *  if the sender is a MANAGEMENT key.\n   */\n  function approve(uint256 _id, bool _approve) public override delegatedOnly returns (bool success) {\n    require(_id < _executionNonce, 'Cannot approve a non-existing execution');\n    require(!_executions[_id].executed, 'Request already executed');\n\n    if (_executions[_id].to == address(this)) {\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), 'Sender does not have management key');\n    } else {\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), 'Sender does not have action key');\n    }\n\n    emit Approved(_id, _approve);\n\n    if (_approve == true) {\n      _executions[_id].approved = true;\n\n      // solhint-disable-next-line avoid-low-level-calls\n      (success, ) = _executions[_id].to.call{ value: (_executions[_id].value) }(_executions[_id].data);\n\n      if (success) {\n        _executions[_id].executed = true;\n\n        emit Executed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n        return true;\n      } else {\n        emit ExecutionFailed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n        return false;\n      }\n    } else {\n      _executions[_id].approved = false;\n    }\n    return false;\n  }\n\n  /**\n   * @dev See {IERC734-removeKey}.\n   * @notice Remove the purpose from a key.\n   */\n  function removeKey(bytes32 _key, uint256 _purpose) public override delegatedOnly onlyManager returns (bool success) {\n    require(_keys[_key].key == _key, \"NonExisting: Key isn't registered\");\n    uint256[] memory _purposes = _keys[_key].purposes;\n\n    uint purposeIndex = 0;\n    while (_purposes[purposeIndex] != _purpose) {\n      purposeIndex++;\n\n      if (purposeIndex == _purposes.length) {\n        revert(\"NonExisting: Key doesn't have such purpose\");\n      }\n    }\n\n    _purposes[purposeIndex] = _purposes[_purposes.length - 1];\n    _keys[_key].purposes = _purposes;\n    _keys[_key].purposes.pop();\n\n    uint keyIndex = 0;\n    uint arrayLength = _keysByPurpose[_purpose].length;\n\n    while (_keysByPurpose[_purpose][keyIndex] != _key) {\n      keyIndex++;\n\n      if (keyIndex >= arrayLength) {\n        break;\n      }\n    }\n\n    _keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\n    _keysByPurpose[_purpose].pop();\n\n    uint keyType = _keys[_key].keyType;\n\n    if (_purposes.length - 1 == 0) {\n      delete _keys[_key];\n    }\n\n    emit KeyRemoved(_key, _purpose, keyType);\n\n    // So OZ Defender doesn't initiate stellar transactions when creating Identity With Management Keys\n    if (msg.sender != address(idFactory)) {      \n      isComing = true;\n      idFactory.removedKey(\n      isComing,\n      _key,\n      _purpose,\n      keyType\n      );\n    }\n\n    isComing = false;\n\n    bool isHomeChain = idFactory._isHomeChain();\n    // Don't send message when calling via createIdentityWithManagementKeys\n    if (isHomeChain && msg.sender != address(idFactory)) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendRemoveKey(chainSelectors[i], receivers[i], _key, _purpose);    \n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev See {IERC735-addClaim}.\n   * @notice Implementation of the addClaim function from the ERC-735 standard\n   *  Require that the msg.sender has claim signer key.\n   *\n   * @param _topic The type of claim\n   * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\n   * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\n   * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\n   * it MUST be a signed message of the following structure:\n   * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\n   * @param _data The hash of the claim data, sitting in another\n   * location, a bit-mask, call data, or actual data based on the claim scheme.\n   * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n   *\n   * @return claimRequestId Returns claimRequestId: COULD be\n   * send to the approve function, to approve or reject this claim.\n   * triggers ClaimAdded event.\n   */\n  function addClaim(\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n  ) public override delegatedOnly onlyClaimKey returns (bytes32 claimRequestId) {\n    if (_issuer != address(this)) {\n      require(IClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data), 'invalid claim');\n    }\n\n    bytes32 claimId = keccak256(abi.encode(_issuer, _topic));\n    _claims[claimId].topic = _topic;\n    _claims[claimId].scheme = _scheme;\n    _claims[claimId].signature = _signature;\n    _claims[claimId].data = _data;\n    _claims[claimId].uri = _uri;\n\n    if (_claims[claimId].issuer != _issuer) {\n      _claimsByTopic[_topic].push(claimId);\n      _claims[claimId].issuer = _issuer;\n\n      // Call Factory, Get Bridge\n      // Call Bridge, Send Claim\n\n      emit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n    } else {\n      emit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n    }\n    isComing = true;\n    idFactory.addedClaim(isComing, _topic, _scheme, _issuer, _signature, _data, _uri);\n    isComing = false;\n\n    bool isHomeChain = idFactory._isHomeChain();\n    if (isHomeChain) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors andand their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n          bridge.sendAddClaim(\n            chainSelectors[i],\n            receivers[i],\n            _topic,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n          );\n        }\n      }\n\n    return claimId;\n  }\n\n  /**\n   * @dev See {IERC735-removeClaim}.\n   * @notice Implementation of the removeClaim function from the ERC-735 standard\n   * Require that the msg.sender has management key.\n   * Can only be removed by the claim issuer, or the claim holder itself.\n   *\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   *\n   * @return success Returns TRUE when the claim was removed.\n   * triggers ClaimRemoved event\n   */\n  function removeClaim(bytes32 _claimId) public override delegatedOnly onlyClaimKey returns (bool success) {\n    uint256 _topic = _claims[_claimId].topic;\n    if (_topic == 0) {\n      revert('NonExisting: There is no claim with this ID');\n    }\n\n    uint claimIndex = 0;\n    uint arrayLength = _claimsByTopic[_topic].length;\n    while (_claimsByTopic[_topic][claimIndex] != _claimId) {\n      claimIndex++;\n\n      if (claimIndex >= arrayLength) {\n        break;\n      }\n    }\n\n    _claimsByTopic[_topic][claimIndex] = _claimsByTopic[_topic][arrayLength - 1];\n    _claimsByTopic[_topic].pop();\n\n    emit ClaimRemoved(\n      _claimId,\n      _topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n\n    delete _claims[_claimId];\n\n    isComing = true;\n    idFactory.removedClaim(\n      isComing,\n      _claimId,\n      _topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n    isComing = false;\n\n    bool isHomeChain = idFactory._isHomeChain();\n    if (isHomeChain) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendRemoveClaim(chainSelectors[i], receivers[i], _claimId);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev See {IERC735-getClaim}.\n   * @notice Implementation of the getClaim function from the ERC-735 standard.\n   *\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   *\n   * @return topic Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return scheme Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return issuer Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return signature Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return data Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return uri Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   */\n  function getClaim(\n    bytes32 _claimId\n  )\n    public\n    view\n    override\n    returns (\n      uint256 topic,\n      uint256 scheme,\n      address issuer,\n      bytes memory signature,\n      bytes memory data,\n      string memory uri\n    )\n  {\n    return (\n      _claims[_claimId].topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n  }\n\n  /**\n   * @dev See {IERC734-keyHasPurpose}.\n   * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\n   */\n  function keyHasPurpose(bytes32 _key, uint256 _purpose) public view override returns (bool result) {\n    Key memory key = _keys[_key];\n    if (key.key == 0) return false;\n\n    for (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\n      uint256 purpose = key.purposes[keyPurposeIndex];\n\n      if (purpose == 1 || purpose == _purpose) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\n   * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\n   * stored by the identity contract.\n   * @param _identity the identity contract related to the claim\n   * @param claimTopic the claim topic of the claim\n   * @param sig the signature of the claim\n   * @param data the data field of the claim\n   * @return claimValid true if the claim is valid, false otherwise\n   */\n  function isClaimValid(\n    IIdentity _identity,\n    uint256 claimTopic,\n    bytes memory sig,\n    bytes memory data\n  ) public view virtual override returns (bool claimValid) {\n    bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n    // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n    bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', dataHash));\n\n    // Recover address of data signer\n    address recovered = getRecoveredAddress(sig, prefixedHash);\n\n    // Take hash of recovered address\n    bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n    // Does the trusted identifier have they key which signed the user's claim?\n    //  && (isClaimRevoked(_claimId) == false)\n    if (keyHasPurpose(hashedAddr, 3)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @dev returns the address that signed the given data\n   * @param sig the signature of the data\n   * @param dataHash the data that was signed\n   * returns the address that signed dataHash and created the signature sig\n   */\n  function getRecoveredAddress(bytes memory sig, bytes32 dataHash) public pure returns (address addr) {\n    bytes32 ra;\n    bytes32 sa;\n    uint8 va;\n\n    // Check the signature length\n    if (sig.length != 65) {\n      return address(0);\n    }\n\n    // Divide the signature in r, s and v variables\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      ra := mload(add(sig, 32))\n      sa := mload(add(sig, 64))\n      va := byte(0, mload(add(sig, 96)))\n    }\n\n    if (va < 27) {\n      va += 27;\n    }\n\n    address recoveredAddress = ecrecover(dataHash, va, ra, sa);\n\n    return (recoveredAddress);\n  }\n\n  /**\n   * @notice Initializer internal function for the Identity contract.\n   *\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __Identity_init(address initialManagementKey, address _idFactoryAddress) internal {\n    require(!_initialized || _isConstructor(), 'Initial key was already setup.');\n    _initialized = true;\n    _canInteract = true;\n    \n    userWallet = initialManagementKey;\n    idFactory = IdFactory(_idFactoryAddress);\n\n    bytes32 _key = keccak256(abi.encode(initialManagementKey));\n    _keys[_key].key = _key;\n    _keys[_key].purposes = [1];\n    _keys[_key].keyType = 1;\n    _keysByPurpose[1].push(_key);\n    emit KeyAdded(_key, 1, 1);\n  }\n\n  /**\n   * @notice Computes if the context in which the function is called is a constructor or not.\n   *\n   * @return true if the context is a constructor.\n   */\n  function _isConstructor() private view returns (bool) {\n    address self = address(this);\n    uint256 cs;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      cs := extcodesize(self)\n    }\n    return cs == 0;\n  }\n}\n"
    },
    "src/interface/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\t/**\n\t * @dev Emitted when a claim is revoked.\n\t *\n\t * Specification: MUST be triggered when revoking a claim.\n\t */\n\tevent ClaimRevoked(bytes indexed signature);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @notice will fetch the claim from the identity contract (unsafe).\n\t * @param _claimId the id of the claim\n\t * @param _identity the address of the identity contract\n\t * @return isRevoked true when the claim is revoked\n\t */\n\tfunction revokeClaim(bytes32 _claimId, address _identity) external returns (bool);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @param signature the signature of the claim\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external;\n\n\t/**\n\t * @dev Returns revocation status of a claim.\n\t * @param _sig the signature of the claim\n\t * @return isRevoked true if the claim is revoked and false otherwise\n\t */\n\tfunction isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\t/**\n\t * @dev Emitted when an execution request was approved.\n\t *\n\t * Specification: MUST be triggered when approve was successfully called.\n\t */\n\tevent Approved(uint256 indexed executionId, bool approved);\n\n\t/**\n\t * @dev Emitted when an execute operation was approved and successfully performed.\n\t *\n\t * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n\t */\n\tevent Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execution request was performed via `execute`.\n\t *\n\t * Specification: MUST be triggered when execute was successfully called.\n\t */\n\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execute operation was called and failed\n\t *\n\t * Specification: MUST be triggered when execute call failed\n\t */\n\tevent ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when a key was added to the Identity.\n\t *\n\t * Specification: MUST be triggered when addKey was successfully called.\n\t */\n\tevent KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Emitted when a key was removed from the Identity.\n\t *\n\t * Specification: MUST be triggered when removeKey was successfully called.\n\t */\n\tevent KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\n\t/**\n\t * \n\t * @dev Returns True if call is coming from Identity Contract\n\t */\n\tfunction isComingFromIdentity(bool done) external returns (bool);\n\t\n\t/**\n\t * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n\t *\n\t * Triggers Event: `KeyAdded`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity\n\t * itself. If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n\t/**\n\t * @dev Approves an execution.\n\t *\n\t * Triggers Event: `Approved`\n\t * Triggers on execution successful Event: `Executed`\n\t * Triggers on execution failure Event: `ExecutionFailed`\n\t */\n\tfunction approve(uint256 _id, bool _approve) external returns (bool success);\n\n\t/**\n\t * @dev Removes _purpose for _key from the identity.\n\t *\n\t * Triggers Event: `KeyRemoved`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n\t * If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n\t/**\n\t * @dev Passes an execution instruction to an ERC734 identity.\n\t * How the execution is handled is up to the identity implementation:\n\t * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n\t * approve this execution.\n\t * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n\t *\n\t * Triggers Event: ExecutionRequested\n\t * Triggers on direct execution Event: Executed\n\t */\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n\t/**\n\t * @dev Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n\t/**\n\t * @dev Returns the list of purposes associated with a key.\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view returns (uint256[] memory _purposes);\n\n\t/**\n\t * @dev Returns an array of public key bytes32 held by this identity.\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n\t/**\n\t * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"
    },
    "src/interface/IERC735.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\t/**\n\t * @dev Emitted when a claim was added.\n\t *\n\t * Specification: MUST be triggered when a claim was successfully added.\n\t */\n\tevent ClaimAdded(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was removed.\n\t *\n\t * Specification: MUST be triggered when removeClaim was successfully called.\n\t */\n\tevent ClaimRemoved(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was changed.\n\t *\n\t * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n\t */\n\tevent ClaimChanged(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Add or update a claim.\n\t *\n\t * Triggers Event: `ClaimAdded`, `ClaimChanged`\n\t *\n\t * Specification: Add or update a claim from an issuer.\n\t *\n\t * _signature is a signed message of the following structure:\n\t * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress issuer,\n\t\tbytes calldata _signature,\n\t\tbytes calldata _data,\n\t\tstring calldata _uri\n\t) external returns (bytes32 claimRequestId);\n\n\t/**\n\t * @dev Removes a claim.\n\t *\n\t * Triggers Event: `ClaimRemoved`\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction removeClaim(bytes32 _claimId) external returns (bool success);\n\n\t/**\n\t * @dev Get a claim by its ID.\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t);\n\n\t/**\n\t * @dev Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view returns (bytes32[] memory claimIds);\n}\n"
    },
    "src/interface/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IImplementationAuthority {\n\t// event emitted when the implementation contract is updated\n\tevent UpdatedImplementation(address newAddress);\n\n\t/**\n\t * @dev updates the address used as implementation by the proxies linked\n\t * to this ImplementationAuthority contract\n\t * @param _newImplementation the address of the new implementation contract\n\t * only Owner can call\n\t */\n\tfunction updateImplementation(address _newImplementation) external;\n\n\t/**\n\t * @dev returns the address of the implementation\n\t */\n\tfunction getImplementation() external view returns (address);\n}\n"
    },
    "src/proxy/IdentityProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport '../interface/IImplementationAuthority.sol';\n\ncontract IdentityProxy {\n  /**\n   *  @dev constructor of the proxy Identity contract\n   *  @param _implementationAuthority the implementation Authority contract address\n   *  @param initialManagementKey the management key at deployment\n   *  @param _idFactoryAddress the _idFactoryAddress at deployment\n   *  the proxy is going to use the logic deployed on the implementation contract\n   *  deployed at an address listed in the ImplementationAuthority contract\n   */\n  constructor(address _implementationAuthority, address initialManagementKey, address _idFactoryAddress) {\n    require(_implementationAuthority != address(0), 'invalid argument - zero address');\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc, _implementationAuthority)\n    }\n\n    address logic = IImplementationAuthority(_implementationAuthority).getImplementation();\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, ) = logic.delegatecall(\n      abi.encodeWithSignature('initialize(address,address)', initialManagementKey, _idFactoryAddress)\n    );\n    require(success, 'Initialization failed.');\n  }\n\n  /**\n   *  @dev fallback proxy function used for any transaction call that is made using\n   *  the Identity contract ABI and called on the proxy contract\n   *  The proxy will update its local storage depending on the behaviour requested\n   *  by the implementation contract given by the Implementation Authority\n   */\n  // solhint-disable-next-line no-complex-fallback\n  fallback() external payable {\n    address logic = IImplementationAuthority(implementationAuthority()).getImplementation();\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      calldatacopy(0x0, 0x0, calldatasize())\n      let success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\n      let retSz := returndatasize()\n      returndatacopy(0, 0, retSz)\n      switch success\n      case 0 {\n        revert(0, retSz)\n      }\n      default {\n        return(0, retSz)\n      }\n    }\n  }\n\n  function implementationAuthority() public view returns (address) {\n    address implemAuth;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      implemAuth := sload(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc)\n    }\n    return implemAuth;\n  }\n}\n"
    },
    "src/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\nimport \"./Structs.sol\";\nimport {IdFactory} from \"../factory/IdFactory.sol\";\n\ncontract Storage is Structs {\n\t// factory address\n\tIdFactory public idFactory;\n\n\taddress internal userWallet;\n\n\tbool internal isComing;\n\n\t// nonce used by the execute/approve function\n\tuint256 internal _executionNonce;\n\n\t// keys as defined by IERC734\n\tmapping(bytes32 => Key) internal _keys;\n\n\t// keys for a given purpose\n\t// purpose 1 = MANAGEMENT\n\t// purpose 2 = ACTION\n\t// purpose 3 = CLAIM\n\tmapping(uint256 => bytes32[]) internal _keysByPurpose;\n\n\t// execution data\n\tmapping(uint256 => Execution) internal _executions;\n\n\t// claims held by the ONCHAINID\n\tmapping(bytes32 => Claim) internal _claims;\n\n\t// array of claims for a given topic\n\tmapping(uint256 => bytes32[]) internal _claimsByTopic;\n\n\t// status on initialization\n\tbool internal _initialized = false;\n\n\t// status on potential interactions with the contract\n\tbool internal _canInteract = false;\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "src/storage/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract Structs {\n\t/**\n\t *  @dev Definition of the structure of a Key.\n\t *\n\t *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\n\t *  The structure should be as follows:\n\t *  key: A public key owned by this identity\n\t *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\n\t *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  key: bytes32 The public key. // Its the Keccak256 hash of the key\n\t */\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of an Execution\n\t *\n\t *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\n\t *  to: address of contract to interact with, can be address(this)\n\t *  value: ETH to transfer with the transaction\n\t *  data: payload of the transaction to execute\n\t *  approved: approval status of the Execution\n\t *  executed: execution status of the Execution (set as false when the Execution is created\n\t *  and updated to true when the Execution is processed)\n\t */\n\tstruct Execution {\n\t\taddress to;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool approved;\n\t\tbool executed;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of a Claim.\n\t *\n\t *  Specification: Claims are information an issuer has about the identity holder.\n\t *  The structure should be as follows:\n\t *  claim: A claim published for the Identity.\n\t *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\n\t *  number schemes, sub topics based on number ranges??))\n\t *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\n\t *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\n\t *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  (ToBeDefined)\n\t *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\n\t *  identity contract, it should hold the key with which the above message was signed, if the key is not present\n\t *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\n\t *  claim can be verified using the call data.\n\t *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\n\t *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\n\t *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\n\t *  the claim scheme.\n\t *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t */\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n}\n"
    },
    "src/version/Version.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\n/**\n * @dev Version contract gives the versioning information of the implementation contract\n */\ncontract Version {\n\t/**\n\t * @dev Returns the string of the current version.\n\t */\n\tfunction version() external pure returns (string memory) {\n\t\t// version 2.2.0\n\t\treturn \"2.2.1\";\n\t}\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}