{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "src/bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IIdentity} from \"../interface/IIdentity.sol\";\n\ncontract CrossChainBridge {\n    address immutable i_router;\n\n    // Map to store the messageIds of the messages sent\n    mapping(bytes32 => bool) public messageIds;\n\n    event MessageSent(bytes32 messageId);\n    event MessageReceived(bytes32 messageId, uint64 sourceChainSelector, address sender, string action);\n\n    constructor(address router) {\n        i_router = router;\n    }\n\n    receive() external payable {}\n\n    function sendAddClaim(\n        uint64 destinationChainSelector,\n        address receiver,\n        uint256 topic,\n        uint256 scheme,\n        address issuer,\n        bytes memory signature,\n        bytes memory data,\n        string memory uri\n    ) external {\n        bytes memory payload = abi.encode(\"AddClaim\", topic, scheme, issuer, signature, data, uri);\n        _sendMessage(destinationChainSelector, receiver, payload);\n    }\n\n    function sendRemoveClaim(\n        uint64 destinationChainSelector,\n        address receiver,\n        bytes32 claimId\n    ) external {\n        bytes memory payload = abi.encode(\"RemoveClaim\", claimId);\n        _sendMessage(destinationChainSelector, receiver, payload);\n    }\n\n    function sendAddKey(\n        uint64 destinationChainSelector,\n        address receiver,\n        bytes32 key,\n        uint256 purpose,\n        uint256 keyType\n    ) external {\n        bytes memory payload = abi.encode(\"AddKey\", key, purpose, keyType);\n        _sendMessage(destinationChainSelector, receiver, payload);\n    }\n\n    function sendRemoveKey(\n        uint64 destinationChainSelector,\n        address receiver,\n        bytes32 key,\n        uint256 purpose\n    ) external {\n        bytes memory payload = abi.encode(\"RemoveKey\", key, purpose);\n        _sendMessage(destinationChainSelector, receiver, payload);\n    }\n\n    function _sendMessage(\n        uint64 destinationChainSelector,\n        address receiver,\n        bytes memory payload\n    ) internal {\n\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver),\n            data: payload,\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: \"\",\n            feeToken: address(0) // Use native token\n        });\n\n        uint256 fee = IRouterClient(i_router).getFee(destinationChainSelector, message);\n\n        bytes32 messageId = IRouterClient(i_router).ccipSend{value: fee}(destinationChainSelector, message);\n\n        emit MessageSent(messageId);\n    }\n\n    function handleCrossChainMessage(Client.Any2EVMMessage memory message) external {\n        require(msg.sender == i_router, \"Only router can call this function\");\n\n        // Check if the message was already processed\n        require(!messageIds[message.messageId], \"Message already processed\");\n        messageIds[message.messageId] = true;\n\n        // Decode the message data\n        (address targetIdentity, string memory action, bytes memory data) = abi.decode(message.data, (address, string, bytes));\n\n        if (keccak256(bytes(action)) == keccak256(bytes(\"AddClaim\"))) {\n            (uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory decodedData, string memory uri) = abi.decode(data, (uint256, uint256, address, bytes, bytes, string));\n            IIdentity(targetIdentity).addClaim(topic, scheme, issuer, signature, decodedData, uri);\n        } else if (keccak256(bytes(action)) == keccak256(bytes(\"RemoveClaim\"))) {\n            bytes32 claimId = abi.decode(data, (bytes32));\n            IIdentity(targetIdentity).removeClaim(claimId);\n        } else if (keccak256(bytes(action)) == keccak256(bytes(\"AddKey\"))) {\n            (bytes32 key, uint256 purpose, uint256 keyType) = abi.decode(data, (bytes32, uint256, uint256));\n            IIdentity(targetIdentity).addKey(key, purpose, keyType);\n        } else if (keccak256(bytes(action)) == keccak256(bytes(\"RemoveKey\"))) {\n            (bytes32 key, uint256 purpose) = abi.decode(data, (bytes32, uint256));\n            IIdentity(targetIdentity).removeKey(key, purpose);\n        } else {\n            revert(\"Unknown action\");\n        }\n\n        emit MessageReceived(message.messageId, message.sourceChainSelector, abi.decode(message.sender, (address)), action);\n    }\n}\n"
    },
    "src/ClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./Identity.sol\";\n\ncontract ClaimIssuer is IClaimIssuer, Identity {\n\tmapping(bytes => bool) public revokedClaims;\n\n\t// solhint-disable-next-line no-empty-blocks\n\tconstructor(address initialManagementKey) Identity(initialManagementKey, false) {}\n\n\t/**\n\t *  @dev See {IClaimIssuer-revokeClaimBySignature}.\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external override delegatedOnly onlyManager {\n\t\trequire(!revokedClaims[signature], \"Conflict: Claim already revoked\");\n\n\t\trevokedClaims[signature] = true;\n\n\t\temit ClaimRevoked(signature);\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-revokeClaim}.\n\t */\n\tfunction revokeClaim(\n\t\tbytes32 _claimId,\n\t\taddress _identity\n\t) external override delegatedOnly onlyManager returns (bool) {\n\t\tuint256 foundClaimTopic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes memory sig;\n\t\tbytes memory data;\n\n\t\t(foundClaimTopic, scheme, issuer, sig, data, ) = Identity(_identity).getClaim(_claimId);\n\n\t\trequire(!revokedClaims[sig], \"Conflict: Claim already revoked\");\n\n\t\trevokedClaims[sig] = true;\n\t\temit ClaimRevoked(sig);\n\t\treturn true;\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-isClaimValid}.\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes memory sig,\n\t\tbytes memory data\n\t) public view override(Identity, IClaimIssuer) returns (bool claimValid) {\n\t\tbytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n\t\t// Use abi.encodePacked to concatenate the message prefix and the message to sign.\n\t\tbytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n\t\t// Recover address of data signer\n\t\taddress recovered = getRecoveredAddress(sig, prefixedHash);\n\n\t\t// Take hash of recovered address\n\t\tbytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n\t\t// Does the trusted identifier have they key which signed the user's claim?\n\t\t//  && (isClaimRevoked(_claimId) == false)\n\t\tif (keyHasPurpose(hashedAddr, 3) && (isClaimRevoked(sig) == false)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t *  @dev See {IClaimIssuer-isClaimRevoked}.\n\t */\n\tfunction isClaimRevoked(bytes memory _sig) public view override returns (bool) {\n\t\tif (revokedClaims[_sig]) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n"
    },
    "src/factory/IdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../proxy/IdentityProxy.sol\";\nimport \"./IIdFactory.sol\";\nimport \"../interface/IERC734.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract IdFactory is IIdFactory, Ownable {\n\tmapping(address => bool) private _tokenFactories;\n\n\t// address of the _implementationAuthority contract making the link to the implementation contract\n\taddress private immutable _implementationAuthority;\n\n\t// as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\n\t// salt is taken and which is not\n\tmapping(string => bool) private _saltTaken;\n\n\t// ONCHAINID of the wallet owner\n\tmapping(address => address) private _userIdentity;\n\n\t// wallets currently linked to an ONCHAINID\n\tmapping(address => address[]) private _wallets;\n\n\t// ONCHAINID of the token\n\tmapping(address => address) private _tokenIdentity;\n\n\t// token linked to an ONCHAINID\n\tmapping(address => address) private _tokenAddress;\n\n\t// setting\n\tconstructor(address implementationAuthority) {\n\t\trequire(implementationAuthority != address(0), \"invalid argument - zero address\");\n\t\t_implementationAuthority = implementationAuthority;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-addTokenFactory}.\n\t */\n\tfunction addTokenFactory(address _factory) external override onlyOwner {\n\t\trequire(_factory != address(0), \"invalid argument - zero address\");\n\t\trequire(!isTokenFactory(_factory), \"already a factory\");\n\t\t_tokenFactories[_factory] = true;\n\t\temit TokenFactoryAdded(_factory);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-removeTokenFactory}.\n\t */\n\tfunction removeTokenFactory(address _factory) external override onlyOwner {\n\t\trequire(_factory != address(0), \"invalid argument - zero address\");\n\t\trequire(isTokenFactory(_factory), \"not a factory\");\n\t\t_tokenFactories[_factory] = false;\n\t\temit TokenFactoryRemoved(_factory);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createIdentity}.\n\t */\n\tfunction createIdentity(address _wallet, string memory _salt) external override onlyOwner returns (address) {\n\t\trequire(_wallet != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory oidSalt = string.concat(\"OID\", _salt);\n\t\trequire(!_saltTaken[oidSalt], \"salt already taken\");\n\t\trequire(_userIdentity[_wallet] == address(0), \"wallet already linked to an identity\");\n\t\taddress identity = _deployIdentity(oidSalt, _implementationAuthority, _wallet);\n\t\t_saltTaken[oidSalt] = true;\n\t\t_userIdentity[_wallet] = identity;\n\t\t_wallets[identity].push(_wallet);\n\t\temit WalletLinked(_wallet, identity);\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createIdentityWithManagementKeys}.\n\t */\n\tfunction createIdentityWithManagementKeys(\n\t\taddress _wallet,\n\t\tstring memory _salt,\n\t\tbytes32[] memory _managementKeys\n\t) external override onlyOwner returns (address) {\n\t\trequire(_wallet != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory oidSalt = string.concat(\"OID\", _salt);\n\t\trequire(!_saltTaken[oidSalt], \"salt already taken\");\n\t\trequire(_userIdentity[_wallet] == address(0), \"wallet already linked to an identity\");\n\t\trequire(_managementKeys.length > 0, \"invalid argument - empty list of keys\");\n\n\t\taddress identity = _deployIdentity(oidSalt, _implementationAuthority, address(this));\n\n\t\tfor (uint i = 0; i < _managementKeys.length; i++) {\n\t\t\trequire(\n\t\t\t\t_managementKeys[i] != keccak256(abi.encode(_wallet)),\n\t\t\t\t\"invalid argument - wallet is also listed in management keys\"\n\t\t\t);\n\t\t\tIERC734(identity).addKey(_managementKeys[i], 1, 1);\n\t\t}\n\n\t\tIERC734(identity).removeKey(keccak256(abi.encode(address(this))), 1);\n\n\t\t_saltTaken[oidSalt] = true;\n\t\t_userIdentity[_wallet] = identity;\n\t\t_wallets[identity].push(_wallet);\n\t\temit WalletLinked(_wallet, identity);\n\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-createTokenIdentity}.\n\t */\n\tfunction createTokenIdentity(\n\t\taddress _token,\n\t\taddress _tokenOwner,\n\t\tstring memory _salt\n\t) external override returns (address) {\n\t\trequire(isTokenFactory(msg.sender) || msg.sender == owner(), \"only Factory or owner can call\");\n\t\trequire(_token != address(0), \"invalid argument - zero address\");\n\t\trequire(_tokenOwner != address(0), \"invalid argument - zero address\");\n\t\trequire(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\"\")), \"invalid argument - empty string\");\n\t\tstring memory tokenIdSalt = string.concat(\"Token\", _salt);\n\t\trequire(!_saltTaken[tokenIdSalt], \"salt already taken\");\n\t\trequire(_tokenIdentity[_token] == address(0), \"token already linked to an identity\");\n\t\taddress identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\n\t\t_saltTaken[tokenIdSalt] = true;\n\t\t_tokenIdentity[_token] = identity;\n\t\t_tokenAddress[identity] = _token;\n\t\temit TokenLinked(_token, identity);\n\t\treturn identity;\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-linkWallet}.\n\t */\n\tfunction linkWallet(address _newWallet) external override {\n\t\trequire(_newWallet != address(0), \"invalid argument - zero address\");\n\t\trequire(_userIdentity[msg.sender] != address(0), \"wallet not linked to an identity contract\");\n\t\trequire(_userIdentity[_newWallet] == address(0), \"new wallet already linked\");\n\t\trequire(_tokenIdentity[_newWallet] == address(0), \"invalid argument - token address\");\n\t\taddress identity = _userIdentity[msg.sender];\n\t\trequire(_wallets[identity].length < 101, \"max amount of wallets per ID exceeded\");\n\t\t_userIdentity[_newWallet] = identity;\n\t\t_wallets[identity].push(_newWallet);\n\t\temit WalletLinked(_newWallet, identity);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-unlinkWallet}.\n\t */\n\tfunction unlinkWallet(address _oldWallet) external override {\n\t\trequire(_oldWallet != address(0), \"invalid argument - zero address\");\n\t\trequire(_oldWallet != msg.sender, \"cannot be called on sender address\");\n\t\trequire(_userIdentity[msg.sender] == _userIdentity[_oldWallet], \"only a linked wallet can unlink\");\n\t\taddress _identity = _userIdentity[_oldWallet];\n\t\tdelete _userIdentity[_oldWallet];\n\t\tuint256 length = _wallets[_identity].length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (_wallets[_identity][i] == _oldWallet) {\n\t\t\t\t_wallets[_identity][i] = _wallets[_identity][length - 1];\n\t\t\t\t_wallets[_identity].pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\temit WalletUnlinked(_oldWallet, _identity);\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getIdentity}.\n\t */\n\tfunction getIdentity(address _wallet) external view override returns (address) {\n\t\tif (_tokenIdentity[_wallet] != address(0)) {\n\t\t\treturn _tokenIdentity[_wallet];\n\t\t} else {\n\t\t\treturn _userIdentity[_wallet];\n\t\t}\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-isSaltTaken}.\n\t */\n\tfunction isSaltTaken(string calldata _salt) external view override returns (bool) {\n\t\treturn _saltTaken[_salt];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getWallets}.\n\t */\n\tfunction getWallets(address _identity) external view override returns (address[] memory) {\n\t\treturn _wallets[_identity];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-getToken}.\n\t */\n\tfunction getToken(address _identity) external view override returns (address) {\n\t\treturn _tokenAddress[_identity];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-isTokenFactory}.\n\t */\n\tfunction isTokenFactory(address _factory) public view override returns (bool) {\n\t\treturn _tokenFactories[_factory];\n\t}\n\n\t/**\n\t *  @dev See {IdFactory-implementationAuthority}.\n\t */\n\tfunction implementationAuthority() public view override returns (address) {\n\t\treturn _implementationAuthority;\n\t}\n\n\t// deploy function with create2 opcode call\n\t// returns the address of the contract created\n\tfunction _deploy(string memory salt, bytes memory bytecode) private returns (address) {\n\t\tbytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\n\t\taddress addr;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tlet encoded_data := add(0x20, bytecode) // load initialization code.\n\t\t\tlet encoded_size := mload(bytecode) // load init code's length.\n\t\t\taddr := create2(0, encoded_data, encoded_size, saltBytes)\n\t\t\tif iszero(extcodesize(addr)) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\t\t}\n\t\temit Deployed(addr);\n\t\treturn addr;\n\t}\n\n\t// function used to deploy an identity using CREATE2\n\tfunction _deployIdentity(\n\t\tstring memory _salt,\n\t\taddress implementationAuthority,\n\t\taddress _wallet\n\t) private returns (address) {\n\t\tbytes memory _code = type(IdentityProxy).creationCode;\n\t\tbytes memory _constructData = abi.encode(implementationAuthority, _wallet);\n\t\tbytes memory bytecode = abi.encodePacked(_code, _constructData);\n\t\treturn _deploy(_salt, bytecode);\n\t}\n}\n"
    },
    "src/factory/IIdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ninterface IIdFactory {\n\t/// events\n\n\t// event emitted whenever a single contract is deployed by the factory\n\tevent Deployed(address indexed _addr);\n\n\t// event emitted when a wallet is linked to an ONCHAINID contract\n\tevent WalletLinked(address indexed wallet, address indexed identity);\n\n\t// event emitted when a token is linked to an ONCHAINID contract\n\tevent TokenLinked(address indexed token, address indexed identity);\n\n\t// event emitted when a wallet is unlinked from an ONCHAINID contract\n\tevent WalletUnlinked(address indexed wallet, address indexed identity);\n\n\t// event emitted when an address is registered on the factory as a Token\n\t// factory address, granting this address the privilege to issue\n\t// Onchain identities for tokens\n\tevent TokenFactoryAdded(address indexed factory);\n\n\t// event emitted when a previously recorded token factory address is removed\n\tevent TokenFactoryRemoved(address indexed factory);\n\n\t/// functions\n\n\t/**\n\t *  @dev function used to create a new Identity proxy from the factory\n\t *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  requires a new salt for each deployment\n\t *  _wallet cannot be linked to another ONCHAINID\n\t *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n\t *  of the function, including calls to oracles for multichain\n\t *  deployment security (avoid identity theft), defining payment requirements, etc.\n\t */\n\tfunction createIdentity(address _wallet, string memory _salt) external returns (address);\n\n\t/**\n\t *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\n\t * MANAGEMENT keys.\n\t *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\n\t *  requires a new salt for each deployment\n\t *  _wallet cannot be linked to another ONCHAINID\n\t *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n\t *  of the function, including calls to oracles for multichain\n\t *  deployment security (avoid identity theft), defining payment requirements, etc.\n\t */\n\tfunction createIdentityWithManagementKeys(\n\t\taddress _wallet,\n\t\tstring memory _salt,\n\t\tbytes32[] memory _managementKeys\n\t) external returns (address);\n\n\t/**\n\t *  @dev function used to create a new Token Identity proxy from the factory\n\t *  @param _token the address of the token contract\n\t *  @param _tokenOwner the owner address of the token\n\t *  @param _salt the salt used by create2 to issue the contract\n\t *  requires a new salt for each deployment\n\t *  _token cannot be linked to another ONCHAINID\n\t *  only Token factory or owner can call (owner should only use its privilege\n\t *  for tokens not issued by a Token factory onchain\n\t */\n\tfunction createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\n\n\t/**\n\t *  @dev function used to link a new wallet to an existing identity\n\t *  @param _newWallet the address of the wallet to link\n\t *  requires msg.sender to be linked to an existing onchainid\n\t *  the _newWallet will be linked to the same OID contract as msg.sender\n\t *  _newWallet cannot be linked to an OID yet\n\t *  _newWallet cannot be address 0\n\t *  cannot link more than 100 wallets to an OID, for gas consumption reason\n\t */\n\tfunction linkWallet(address _newWallet) external;\n\n\t/**\n\t *  @dev function used to unlink a wallet from an existing identity\n\t *  @param _oldWallet the address of the wallet to unlink\n\t *  requires msg.sender to be linked to the same onchainid as _oldWallet\n\t *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\n\t *  _oldWallet cannot be address 0\n\t */\n\tfunction unlinkWallet(address _oldWallet) external;\n\n\t/**\n\t *  @dev function used to register an address as a token factory\n\t *  @param _factory the address of the token factory\n\t *  can be called only by Owner\n\t *  _factory cannot be registered yet\n\t *  once the factory has been registered it can deploy token identities\n\t */\n\tfunction addTokenFactory(address _factory) external;\n\n\t/**\n\t *  @dev function used to unregister an address previously registered as a token factory\n\t *  @param _factory the address of the token factory\n\t *  can be called only by Owner\n\t *  _factory has to be registered previously\n\t *  once the factory has been unregistered it cannot deploy token identities anymore\n\t */\n\tfunction removeTokenFactory(address _factory) external;\n\n\t/**\n\t *  @dev getter for OID contract corresponding to a wallet/token\n\t *  @param _wallet the wallet/token address\n\t */\n\tfunction getIdentity(address _wallet) external view returns (address);\n\n\t/**\n\t *  @dev getter to fetch the array of wallets linked to an OID contract\n\t *  @param _identity the address of the OID contract\n\t *  returns an array of addresses linked to the OID\n\t */\n\tfunction getWallets(address _identity) external view returns (address[] memory);\n\n\t/**\n\t *  @dev getter to fetch the token address linked to an OID contract\n\t *  @param _identity the address of the OID contract\n\t *  returns the address linked to the OID\n\t */\n\tfunction getToken(address _identity) external view returns (address);\n\n\t/**\n\t *  @dev getter to know if an address is registered as token factory or not\n\t *  @param _factory the address of the factory\n\t *  returns true if the address corresponds to a registered factory\n\t */\n\tfunction isTokenFactory(address _factory) external view returns (bool);\n\n\t/**\n\t *  @dev getter to know if a salt is taken for the create2 deployment\n\t *  @param _salt the salt used for deployment\n\t */\n\tfunction isSaltTaken(string calldata _salt) external view returns (bool);\n\n\t/**\n\t * @dev getter for the implementation authority used by this factory.\n\t */\n\tfunction implementationAuthority() external view returns (address);\n}\n"
    },
    "src/factory/IssuerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n\nimport \"../ClaimIssuer.sol\";\n\n\ncontract IssuerFactory {\n    event Deployed(address addr, bytes32 salt);\n\n    mapping(bytes32 => bool) private _saltUsed;\n\n    function _deploy(string memory salt, bytes memory bytecode) public returns (address) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        require(!_saltUsed[saltBytes], \"Salt already used\");\n\n        address addr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, bytecode) // load initialization code.\n            let encoded_size := mload(bytecode) // load init code's length.\n            addr := create2(0, encoded_data, encoded_size, saltBytes)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        emit Deployed(addr, saltBytes);\n        _saltUsed[saltBytes] = true;\n        return addr;\n    }\n\n    function deployClaimIssuer(\n        string memory salt,\n        address implementationAuthority,\n        address wallet\n    ) public returns (address) {\n        bytes memory code = type(ClaimIssuer).creationCode;\n        bytes memory constructData = abi.encode(implementationAuthority, wallet);\n        bytes memory bytecode = abi.encodePacked(code, constructData);\n        return _deploy(salt, bytecode);\n    }\n\n    function isSaltUsed(string memory salt) public view returns (bool) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        return _saltUsed[saltBytes];\n    }\n}"
    },
    "src/gateway/Gateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../factory/IdFactory.sol\";\n\nusing ECDSA for bytes32;\n\n/// A required parameter was set to the Zero address.\nerror ZeroAddress();\n/// The maximum number of signers was reached at deployment.\nerror TooManySigners();\n/// The signed attempted to add was already approved.\nerror SignerAlreadyApproved(address signer);\n/// The signed attempted to remove was not approved.\nerror SignerAlreadyNotApproved(address signer);\n/// A requested ONCHAINID deployment was requested without a valid signature while the Gateway requires one.\nerror UnsignedDeployment();\n/// A requested ONCHAINID deployment was requested and signer by a non approved signer.\nerror UnapprovedSigner(address signer);\n/// A requested ONCHAINID deployment was requested with a signature revoked.\nerror RevokedSignature(bytes signature);\n/// A requested ONCHAINID deployment was requested with a signature that expired.\nerror ExpiredSignature(bytes signature);\n/// Attempted to revoke a signature that was already revoked.\nerror SignatureAlreadyRevoked(bytes signature);\n/// Attempted to approve a signature that was not revoked.\nerror SignatureNotRevoked(bytes signature);\n\ncontract Gateway is Ownable {\n    IdFactory public idFactory;\n    mapping(address => bool) public approvedSigners;\n    mapping(bytes => bool) public revokedSignatures;\n\n    event SignerApproved(address indexed signer);\n    event SignerRevoked(address indexed signer);\n    event SignatureRevoked(bytes indexed signature);\n    event SignatureApproved(bytes indexed signature);\n\n    /**\n     *  @dev Constructor for the ONCHAINID Factory Gateway.\n     *  @param idFactoryAddress the address of the factory to operate (the Gateway must be owner of the Factory).\n     */\n    constructor(address idFactoryAddress, address[] memory signersToApprove) Ownable() {\n        if (idFactoryAddress == address(0)) {\n            revert ZeroAddress();\n        }\n        if (signersToApprove.length > 10) {\n            revert TooManySigners();\n        }\n\n        for (uint i = 0; i < signersToApprove.length; i++) {\n            approvedSigners[signersToApprove[i]] = true;\n        }\n\n        idFactory = IdFactory(idFactoryAddress);\n    }\n\n    /**\n     *  @dev Approve a signer to sign ONCHAINID deployments. If the Gateway is setup to require signature, only\n     *  deployments requested with a valid signature from an approved signer will be accepted.\n     *  If the gateway does not require a signature,\n     *  @param signer the signer address to approve.\n     */\n    function approveSigner(address signer) external onlyOwner {\n        if (signer == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (approvedSigners[signer]) {\n            revert SignerAlreadyApproved(signer);\n        }\n\n        approvedSigners[signer] = true;\n\n        emit SignerApproved(signer);\n    }\n\n    /**\n     *  @dev Revoke a signer to sign ONCHAINID deployments.\n     *  @param signer the signer address to revoke.\n     */\n    function revokeSigner(address signer) external onlyOwner {\n        if (signer == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (!approvedSigners[signer]) {\n            revert SignerAlreadyNotApproved(signer);\n        }\n\n        delete approvedSigners[signer];\n\n        emit SignerRevoked(signer);\n    }\n\n    /**\n     *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n     *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt.\n     *  @param identityOwner the address to set as a management key.\n     *  @param salt to use for the deployment.\n     *  @param signatureExpiry the block timestamp where the signature will expire.\n     *  @param signature the approval containing the salt and the identityOwner address.\n     */\n    function deployIdentityWithSalt(\n        address identityOwner,\n        string memory salt,\n        uint256 signatureExpiry,\n        bytes calldata signature\n    ) external returns (address) {\n        if (identityOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (signatureExpiry != 0 && signatureExpiry < block.timestamp) {\n            revert ExpiredSignature(signature);\n        }\n\n        address signer = ECDSA.recover(\n            keccak256(\n                abi.encode(\n                    \"Authorize ONCHAINID deployment\",\n                    identityOwner,\n                    salt,\n                    signatureExpiry\n                )\n            ).toEthSignedMessageHash(),\n            signature\n        );\n\n        if (!approvedSigners[signer]) {\n            revert UnapprovedSigner(signer);\n        }\n\n        if (revokedSignatures[signature]) {\n            revert RevokedSignature(signature);\n        }\n\n        return idFactory.createIdentity(identityOwner, salt);\n    }\n\n    /**\n     *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n     *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt and a custom list of\n     *  management keys. Note that the identity Owner address won't be added as a management keys, if this is desired,\n     *  the key hash must be listed in the managementKeys array.\n     *  @param identityOwner the address to set as a management key.\n     *  @param salt to use for the deployment.\n     *  @param managementKeys the list of management keys to add to the ONCHAINID.\n     *  @param signatureExpiry the block timestamp where the signature will expire.\n     *  @param signature the approval containing the salt and the identityOwner address.\n     */\n    function deployIdentityWithSaltAndManagementKeys(\n        address identityOwner,\n        string memory salt,\n        bytes32[] calldata managementKeys,\n        uint256 signatureExpiry,\n        bytes calldata signature\n    ) external returns (address) {\n        if (identityOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        if (signatureExpiry != 0 && signatureExpiry < block.timestamp) {\n            revert ExpiredSignature(signature);\n        }\n\n        address signer = ECDSA.recover(\n            keccak256(\n                abi.encode(\n                    \"Authorize ONCHAINID deployment\",\n                    identityOwner,\n                    salt,\n                    managementKeys,\n                    signatureExpiry\n                )\n            ).toEthSignedMessageHash(),\n            signature\n        );\n\n        if (!approvedSigners[signer]) {\n            revert UnapprovedSigner(signer);\n        }\n\n        if (revokedSignatures[signature]) {\n            revert RevokedSignature(signature);\n        }\n\n        return idFactory.createIdentityWithManagementKeys(identityOwner, salt, managementKeys);\n    }\n\n    /**\n     *  @dev Deploy an ONCHAINID using a factory using the identityOwner address as salt.\n     *  @param identityOwner the address to set as a management key.\n     */\n    function deployIdentityForWallet(address identityOwner) external returns (address) {\n        if (identityOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        return idFactory.createIdentity(identityOwner, Strings.toHexString(identityOwner));\n    }\n\n    /**\n     *  @dev Revoke a signature, if the signature is used to deploy an ONCHAINID, the deployment would be rejected.\n     *  @param signature the signature to revoke.\n     */\n    function revokeSignature(bytes calldata signature) external onlyOwner {\n        if (revokedSignatures[signature]) {\n            revert SignatureAlreadyRevoked(signature);\n        }\n\n        revokedSignatures[signature] = true;\n\n        emit SignatureRevoked(signature);\n    }\n\n    /**\n     *  @dev Remove a signature from the revoke list.\n     *  @param signature the signature to approve.\n     */\n    function approveSignature(bytes calldata signature) external onlyOwner {\n        if (!revokedSignatures[signature]) {\n            revert SignatureNotRevoked(signature);\n        }\n\n        delete revokedSignatures[signature];\n\n        emit SignatureApproved(signature);\n    }\n\n    /**\n     *  @dev Transfer the ownership of the factory to a new owner.\n     *  @param newOwner the new owner of the factory.\n     */\n    function transferFactoryOwnership(address newOwner) external onlyOwner {\n        idFactory.transferOwnership(newOwner);\n    }\n\n    /**\n     *  @dev Call a function on the factory. Only the owner of the Gateway can call this method.\n     *  @param data the data to call on the factory.\n     */\n    function callFactory(bytes memory data) external onlyOwner {\n        (bool success,) = address(idFactory).call(data);\n        require(success, \"Gateway: call to factory failed\");\n    }\n}"
    },
    "src/Identity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IIdentity.sol\";\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./version/Version.sol\";\nimport \"./storage/Storage.sol\";\n\n/**\n * @dev Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces\n * into a common Identity Contract.\n * This implementation has a separate contract were it declares all storage,\n * allowing for it to be used as an upgradable logic contract.\n */\ncontract Identity is Storage, IIdentity, Version {\n\t/**\n\t * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\n\t */\n\tmodifier delegatedOnly() {\n\t\trequire(_canInteract == true, \"Interacting with the library contract is forbidden.\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice requires management key to call this function, or internal call\n\t */\n\tmodifier onlyManager() {\n\t\trequire(\n\t\t\tmsg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 1),\n\t\t\t\"Permissions: Sender does not have management key\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice requires claim key to call this function, or internal call\n\t */\n\tmodifier onlyClaimKey() {\n\t\trequire(\n\t\t\tmsg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 3),\n\t\t\t\"Permissions: Sender does not have claim signer key\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice constructor of the Identity contract\n\t * @param initialManagementKey the address of the management key at deployment\n\t * @param _isLibrary boolean value stating if the contract is library or not\n\t * calls __Identity_init if contract is not library\n\t */\n\tconstructor(address initialManagementKey, bool _isLibrary) {\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\n\t\tif (!_isLibrary) {\n\t\t\t__Identity_init(initialManagementKey);\n\t\t} else {\n\t\t\t_initialized = true;\n\t\t}\n\t}\n\n\t/**\n\t * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\n\t *\n\t * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n\t */\n\tfunction initialize(address initialManagementKey) external {\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\t\t__Identity_init(initialManagementKey);\n\t}\n\n\t/**\n\t * @dev See {IERC734-execute}.\n\t * @notice Passes an execution instruction to the keymanager.\n\t * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n\t * execution is immediately approved and performed.\n\t * If the destination address is the identity itself, then the execution would be performed immediately only if\n\t * the sender is a MANAGEMENT key.\n\t * Otherwise the execution request must be approved via the `approve` method.\n\t * @return executionId to use in the approve function, to approve or reject this execution.\n\t */\n\tfunction execute(\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tbytes memory _data\n\t) external payable override delegatedOnly returns (uint256 executionId) {\n\t\tuint256 _executionId = _executionNonce;\n\t\t_executions[_executionId].to = _to;\n\t\t_executions[_executionId].value = _value;\n\t\t_executions[_executionId].data = _data;\n\t\t_executionNonce++;\n\n\t\temit ExecutionRequested(_executionId, _to, _value, _data);\n\n\t\tif (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\n\t\t\tapprove(_executionId, true);\n\t\t} else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)) {\n\t\t\tapprove(_executionId, true);\n\t\t}\n\n\t\treturn _executionId;\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKey}.\n\t * @notice Implementation of the getKey function from the ERC-734 standard\n\t * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n\t * @return purposes Returns the full key data, if present in the identity.\n\t * @return keyType Returns the full key data, if present in the identity.\n\t * @return key Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(\n\t\tbytes32 _key\n\t) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n\t\treturn (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKeyPurposes}.\n\t * @notice gets the purposes of a key\n\t * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n\t * @return _purposes Returns the purposes of the specified key\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n\t\treturn (_keys[_key].purposes);\n\t}\n\n\t/**\n\t * @dev See {IERC734-getKeysByPurpose}.\n\t * @notice gets all the keys with a specific purpose from an identity\n\t * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n\t * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory keys) {\n\t\treturn _keysByPurpose[_purpose];\n\t}\n\n\t/**\n\t * @dev See {IERC735-getClaimIdsByTopic}.\n\t * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\n\t * used to get all the claims from the specified topic\n\t * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t * @return claimIds Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds) {\n\t\treturn _claimsByTopic[_topic];\n\t}\n\n\t/**\n\t * @notice implementation of the addKey function of the ERC-734 standard\n\t * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\n\t * 1: MANAGEMENT keys, which can manage the identity\n\t * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n\t * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n\t * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n\t * MUST only be done by keys of purpose 1, or the identity itself.\n\t * If its the identity itself, the approval process will determine its approval.\n\t * @param _key keccak256 representation of an ethereum address\n\t * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n\t * @return success Returns TRUE if the addition was successful and FALSE if not\n\t */\n\tfunction addKey(\n\t\tbytes32 _key,\n\t\tuint256 _purpose,\n\t\tuint256 _type\n\t) public override delegatedOnly onlyManager returns (bool success) {\n\t\tif (_keys[_key].key == _key) {\n\t\t\tuint256[] memory _purposes = _keys[_key].purposes;\n\t\t\tfor (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\n\t\t\t\tuint256 purpose = _purposes[keyPurposeIndex];\n\n\t\t\t\tif (purpose == _purpose) {\n\t\t\t\t\trevert(\"Conflict: Key already has purpose\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_keys[_key].purposes.push(_purpose);\n\t\t} else {\n\t\t\t_keys[_key].key = _key;\n\t\t\t_keys[_key].purposes = [_purpose];\n\t\t\t_keys[_key].keyType = _type;\n\t\t}\n\n\t\t_keysByPurpose[_purpose].push(_key);\n\n\t\temit KeyAdded(_key, _purpose, _type);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *  @dev See {IERC734-approve}.\n\t *  @notice Approves an execution.\n\t *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n\t *  approval is authorized and the operation would be performed.\n\t *  If the destination address is the identity itself, then the execution would be authorized and performed only\n\t *  if the sender is a MANAGEMENT key.\n\t */\n\tfunction approve(uint256 _id, bool _approve) public override delegatedOnly returns (bool success) {\n\t\trequire(_id < _executionNonce, \"Cannot approve a non-existing execution\");\n\t\trequire(!_executions[_id].executed, \"Request already executed\");\n\n\t\tif (_executions[_id].to == address(this)) {\n\t\t\trequire(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), \"Sender does not have management key\");\n\t\t} else {\n\t\t\trequire(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), \"Sender does not have action key\");\n\t\t}\n\n\t\temit Approved(_id, _approve);\n\n\t\tif (_approve == true) {\n\t\t\t_executions[_id].approved = true;\n\n\t\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t\t(success, ) = _executions[_id].to.call{value: (_executions[_id].value)}(_executions[_id].data);\n\n\t\t\tif (success) {\n\t\t\t\t_executions[_id].executed = true;\n\n\t\t\t\temit Executed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\temit ExecutionFailed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t_executions[_id].approved = false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev See {IERC734-removeKey}.\n\t * @notice Remove the purpose from a key.\n\t */\n\tfunction removeKey(\n\t\tbytes32 _key,\n\t\tuint256 _purpose\n\t) public override delegatedOnly onlyManager returns (bool success) {\n\t\trequire(_keys[_key].key == _key, \"NonExisting: Key isn't registered\");\n\t\tuint256[] memory _purposes = _keys[_key].purposes;\n\n\t\tuint purposeIndex = 0;\n\t\twhile (_purposes[purposeIndex] != _purpose) {\n\t\t\tpurposeIndex++;\n\n\t\t\tif (purposeIndex == _purposes.length) {\n\t\t\t\trevert(\"NonExisting: Key doesn't have such purpose\");\n\t\t\t}\n\t\t}\n\n\t\t_purposes[purposeIndex] = _purposes[_purposes.length - 1];\n\t\t_keys[_key].purposes = _purposes;\n\t\t_keys[_key].purposes.pop();\n\n\t\tuint keyIndex = 0;\n\t\tuint arrayLength = _keysByPurpose[_purpose].length;\n\n\t\twhile (_keysByPurpose[_purpose][keyIndex] != _key) {\n\t\t\tkeyIndex++;\n\n\t\t\tif (keyIndex >= arrayLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t_keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\n\t\t_keysByPurpose[_purpose].pop();\n\n\t\tuint keyType = _keys[_key].keyType;\n\n\t\tif (_purposes.length - 1 == 0) {\n\t\t\tdelete _keys[_key];\n\t\t}\n\n\t\temit KeyRemoved(_key, _purpose, keyType);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC735-addClaim}.\n\t * @notice Implementation of the addClaim function from the ERC-735 standard\n\t *  Require that the msg.sender has claim signer key.\n\t *\n\t * @param _topic The type of claim\n\t * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\n\t * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\n\t * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\n\t * it MUST be a signed message of the following structure:\n\t * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\n\t * @param _data The hash of the claim data, sitting in another\n\t * location, a bit-mask, call data, or actual data based on the claim scheme.\n\t * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t *\n\t * @return claimRequestId Returns claimRequestId: COULD be\n\t * send to the approve function, to approve or reject this claim.\n\t * triggers ClaimAdded event.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) public override delegatedOnly onlyClaimKey returns (bytes32 claimRequestId) {\n\t\tif (_issuer != address(this)) {\n\t\t\trequire(\n\t\t\t\tIClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data),\n\t\t\t\t\"invalid claim\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 claimId = keccak256(abi.encode(_issuer, _topic));\n\t\t_claims[claimId].topic = _topic;\n\t\t_claims[claimId].scheme = _scheme;\n\t\t_claims[claimId].signature = _signature;\n\t\t_claims[claimId].data = _data;\n\t\t_claims[claimId].uri = _uri;\n\n\t\tif (_claims[claimId].issuer != _issuer) {\n\t\t\t_claimsByTopic[_topic].push(claimId);\n\t\t\t_claims[claimId].issuer = _issuer;\n\n\t\t\t// Call Factory, Get Bridge\n\t\t\t// Call Bridge, Send Claim\n\n\t\t\temit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\t\t} else {\n\t\t\temit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\t\t}\n\t\treturn claimId;\n\t}\n\n\t/**\n\t * @dev See {IERC735-removeClaim}.\n\t * @notice Implementation of the removeClaim function from the ERC-735 standard\n\t * Require that the msg.sender has management key.\n\t * Can only be removed by the claim issuer, or the claim holder itself.\n\t *\n\t * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t *\n\t * @return success Returns TRUE when the claim was removed.\n\t * triggers ClaimRemoved event\n\t */\n\tfunction removeClaim(bytes32 _claimId) public override delegatedOnly onlyClaimKey returns (bool success) {\n\t\tuint256 _topic = _claims[_claimId].topic;\n\t\tif (_topic == 0) {\n\t\t\trevert(\"NonExisting: There is no claim with this ID\");\n\t\t}\n\n\t\tuint claimIndex = 0;\n\t\tuint arrayLength = _claimsByTopic[_topic].length;\n\t\twhile (_claimsByTopic[_topic][claimIndex] != _claimId) {\n\t\t\tclaimIndex++;\n\n\t\t\tif (claimIndex >= arrayLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t_claimsByTopic[_topic][claimIndex] = _claimsByTopic[_topic][arrayLength - 1];\n\t\t_claimsByTopic[_topic].pop();\n\n\t\temit ClaimRemoved(\n\t\t\t_claimId,\n\t\t\t_topic,\n\t\t\t_claims[_claimId].scheme,\n\t\t\t_claims[_claimId].issuer,\n\t\t\t_claims[_claimId].signature,\n\t\t\t_claims[_claimId].data,\n\t\t\t_claims[_claimId].uri\n\t\t);\n\n\t\tdelete _claims[_claimId];\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC735-getClaim}.\n\t * @notice Implementation of the getClaim function from the ERC-735 standard.\n\t *\n\t * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n\t *\n\t * @return topic Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return scheme Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return issuer Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return signature Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return data Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t * @return uri Returns all the parameters of the claim for the\n\t * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t)\n\t{\n\t\treturn (\n\t\t\t_claims[_claimId].topic,\n\t\t\t_claims[_claimId].scheme,\n\t\t\t_claims[_claimId].issuer,\n\t\t\t_claims[_claimId].signature,\n\t\t\t_claims[_claimId].data,\n\t\t\t_claims[_claimId].uri\n\t\t);\n\t}\n\n\t/**\n\t * @dev See {IERC734-keyHasPurpose}.\n\t * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) public view override returns (bool result) {\n\t\tKey memory key = _keys[_key];\n\t\tif (key.key == 0) return false;\n\n\t\tfor (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\n\t\t\tuint256 purpose = key.purposes[keyPurposeIndex];\n\n\t\t\tif (purpose == 1 || purpose == _purpose) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\n\t * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\n\t * stored by the identity contract.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes memory sig,\n\t\tbytes memory data\n\t) public view virtual override returns (bool claimValid) {\n\t\tbytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n\t\t// Use abi.encodePacked to concatenate the message prefix and the message to sign.\n\t\tbytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n\t\t// Recover address of data signer\n\t\taddress recovered = getRecoveredAddress(sig, prefixedHash);\n\n\t\t// Take hash of recovered address\n\t\tbytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n\t\t// Does the trusted identifier have they key which signed the user's claim?\n\t\t//  && (isClaimRevoked(_claimId) == false)\n\t\tif (keyHasPurpose(hashedAddr, 3)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev returns the address that signed the given data\n\t * @param sig the signature of the data\n\t * @param dataHash the data that was signed\n\t * returns the address that signed dataHash and created the signature sig\n\t */\n\tfunction getRecoveredAddress(bytes memory sig, bytes32 dataHash) public pure returns (address addr) {\n\t\tbytes32 ra;\n\t\tbytes32 sa;\n\t\tuint8 va;\n\n\t\t// Check the signature length\n\t\tif (sig.length != 65) {\n\t\t\treturn address(0);\n\t\t}\n\n\t\t// Divide the signature in r, s and v variables\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tra := mload(add(sig, 32))\n\t\t\tsa := mload(add(sig, 64))\n\t\t\tva := byte(0, mload(add(sig, 96)))\n\t\t}\n\n\t\tif (va < 27) {\n\t\t\tva += 27;\n\t\t}\n\n\t\taddress recoveredAddress = ecrecover(dataHash, va, ra, sa);\n\n\t\treturn (recoveredAddress);\n\t}\n\n\t/**\n\t * @notice Initializer internal function for the Identity contract.\n\t *\n\t * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n\t */\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __Identity_init(address initialManagementKey) internal {\n\t\trequire(!_initialized || _isConstructor(), \"Initial key was already setup.\");\n\t\t_initialized = true;\n\t\t_canInteract = true;\n\n\t\tbytes32 _key = keccak256(abi.encode(initialManagementKey));\n\t\t_keys[_key].key = _key;\n\t\t_keys[_key].purposes = [1];\n\t\t_keys[_key].keyType = 1;\n\t\t_keysByPurpose[1].push(_key);\n\t\temit KeyAdded(_key, 1, 1);\n\t}\n\n\t/**\n\t * @notice Computes if the context in which the function is called is a constructor or not.\n\t *\n\t * @return true if the context is a constructor.\n\t */\n\tfunction _isConstructor() private view returns (bool) {\n\t\taddress self = address(this);\n\t\tuint256 cs;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcs := extcodesize(self)\n\t\t}\n\t\treturn cs == 0;\n\t}\n}\n"
    },
    "src/interface/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\t/**\n\t * @dev Emitted when a claim is revoked.\n\t *\n\t * Specification: MUST be triggered when revoking a claim.\n\t */\n\tevent ClaimRevoked(bytes indexed signature);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @notice will fetch the claim from the identity contract (unsafe).\n\t * @param _claimId the id of the claim\n\t * @param _identity the address of the identity contract\n\t * @return isRevoked true when the claim is revoked\n\t */\n\tfunction revokeClaim(bytes32 _claimId, address _identity) external returns (bool);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @param signature the signature of the claim\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external;\n\n\t/**\n\t * @dev Returns revocation status of a claim.\n\t * @param _sig the signature of the claim\n\t * @return isRevoked true if the claim is revoked and false otherwise\n\t */\n\tfunction isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\t/**\n\t * @dev Emitted when an execution request was approved.\n\t *\n\t * Specification: MUST be triggered when approve was successfully called.\n\t */\n\tevent Approved(uint256 indexed executionId, bool approved);\n\n\t/**\n\t * @dev Emitted when an execute operation was approved and successfully performed.\n\t *\n\t * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n\t */\n\tevent Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execution request was performed via `execute`.\n\t *\n\t * Specification: MUST be triggered when execute was successfully called.\n\t */\n\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execute operation was called and failed\n\t *\n\t * Specification: MUST be triggered when execute call failed\n\t */\n\tevent ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when a key was added to the Identity.\n\t *\n\t * Specification: MUST be triggered when addKey was successfully called.\n\t */\n\tevent KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Emitted when a key was removed from the Identity.\n\t *\n\t * Specification: MUST be triggered when removeKey was successfully called.\n\t */\n\tevent KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n\t *\n\t * Triggers Event: `KeyAdded`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity\n\t * itself. If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n\t/**\n\t * @dev Approves an execution.\n\t *\n\t * Triggers Event: `Approved`\n\t * Triggers on execution successful Event: `Executed`\n\t * Triggers on execution failure Event: `ExecutionFailed`\n\t */\n\tfunction approve(uint256 _id, bool _approve) external returns (bool success);\n\n\t/**\n\t * @dev Removes _purpose for _key from the identity.\n\t *\n\t * Triggers Event: `KeyRemoved`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n\t * If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n\t/**\n\t * @dev Passes an execution instruction to an ERC734 identity.\n\t * How the execution is handled is up to the identity implementation:\n\t * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n\t * approve this execution.\n\t * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n\t *\n\t * Triggers Event: ExecutionRequested\n\t * Triggers on direct execution Event: Executed\n\t */\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n\t/**\n\t * @dev Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n\t/**\n\t * @dev Returns the list of purposes associated with a key.\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view returns (uint256[] memory _purposes);\n\n\t/**\n\t * @dev Returns an array of public key bytes32 held by this identity.\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n\t/**\n\t * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"
    },
    "src/interface/IERC735.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\t/**\n\t * @dev Emitted when a claim was added.\n\t *\n\t * Specification: MUST be triggered when a claim was successfully added.\n\t */\n\tevent ClaimAdded(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was removed.\n\t *\n\t * Specification: MUST be triggered when removeClaim was successfully called.\n\t */\n\tevent ClaimRemoved(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was changed.\n\t *\n\t * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n\t */\n\tevent ClaimChanged(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Add or update a claim.\n\t *\n\t * Triggers Event: `ClaimAdded`, `ClaimChanged`\n\t *\n\t * Specification: Add or update a claim from an issuer.\n\t *\n\t * _signature is a signed message of the following structure:\n\t * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress issuer,\n\t\tbytes calldata _signature,\n\t\tbytes calldata _data,\n\t\tstring calldata _uri\n\t) external returns (bytes32 claimRequestId);\n\n\t/**\n\t * @dev Removes a claim.\n\t *\n\t * Triggers Event: `ClaimRemoved`\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction removeClaim(bytes32 _claimId) external returns (bool success);\n\n\t/**\n\t * @dev Get a claim by its ID.\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t);\n\n\t/**\n\t * @dev Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view returns (bytes32[] memory claimIds);\n}\n"
    },
    "src/interface/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IImplementationAuthority {\n\t// event emitted when the implementation contract is updated\n\tevent UpdatedImplementation(address newAddress);\n\n\t/**\n\t * @dev updates the address used as implementation by the proxies linked\n\t * to this ImplementationAuthority contract\n\t * @param _newImplementation the address of the new implementation contract\n\t * only Owner can call\n\t */\n\tfunction updateImplementation(address _newImplementation) external;\n\n\t/**\n\t * @dev returns the address of the implementation\n\t */\n\tfunction getImplementation() external view returns (address);\n}\n"
    },
    "src/proxy/IdentityProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"../interface/IImplementationAuthority.sol\";\n\ncontract IdentityProxy {\n\t/**\n\t *  @dev constructor of the proxy Identity contract\n\t *  @param _implementationAuthority the implementation Authority contract address\n\t *  @param initialManagementKey the management key at deployment\n\t *  the proxy is going to use the logic deployed on the implementation contract\n\t *  deployed at an address listed in the ImplementationAuthority contract\n\t */\n\tconstructor(address _implementationAuthority, address initialManagementKey) {\n\t\trequire(_implementationAuthority != address(0), \"invalid argument - zero address\");\n\t\trequire(initialManagementKey != address(0), \"invalid argument - zero address\");\n\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tsstore(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc, _implementationAuthority)\n\t\t}\n\n\t\taddress logic = IImplementationAuthority(_implementationAuthority).getImplementation();\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, ) = logic.delegatecall(abi.encodeWithSignature(\"initialize(address)\", initialManagementKey));\n\t\trequire(success, \"Initialization failed.\");\n\t}\n\n\t/**\n\t *  @dev fallback proxy function used for any transaction call that is made using\n\t *  the Identity contract ABI and called on the proxy contract\n\t *  The proxy will update its local storage depending on the behaviour requested\n\t *  by the implementation contract given by the Implementation Authority\n\t */\n\t// solhint-disable-next-line no-complex-fallback\n\tfallback() external payable {\n\t\taddress logic = IImplementationAuthority(implementationAuthority()).getImplementation();\n\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tcalldatacopy(0x0, 0x0, calldatasize())\n\t\t\tlet success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\n\t\t\tlet retSz := returndatasize()\n\t\t\treturndatacopy(0, 0, retSz)\n\t\t\tswitch success\n\t\t\tcase 0 {\n\t\t\t\trevert(0, retSz)\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, retSz)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction implementationAuthority() public view returns (address) {\n\t\taddress implemAuth;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\timplemAuth := sload(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc)\n\t\t}\n\t\treturn implemAuth;\n\t}\n}\n"
    },
    "src/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\nimport \"./Structs.sol\";\n\ncontract Storage is Structs {\n\t// nonce used by the execute/approve function\n\tuint256 internal _executionNonce;\n\n\t// keys as defined by IERC734\n\tmapping(bytes32 => Key) internal _keys;\n\n\t// keys for a given purpose\n\t// purpose 1 = MANAGEMENT\n\t// purpose 2 = ACTION\n\t// purpose 3 = CLAIM\n\tmapping(uint256 => bytes32[]) internal _keysByPurpose;\n\n\t// execution data\n\tmapping(uint256 => Execution) internal _executions;\n\n\t// claims held by the ONCHAINID\n\tmapping(bytes32 => Claim) internal _claims;\n\n\t// array of claims for a given topic\n\tmapping(uint256 => bytes32[]) internal _claimsByTopic;\n\n\t// status on initialization\n\tbool internal _initialized = false;\n\n\t// status on potential interactions with the contract\n\tbool internal _canInteract = false;\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "src/storage/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract Structs {\n\t/**\n\t *  @dev Definition of the structure of a Key.\n\t *\n\t *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\n\t *  The structure should be as follows:\n\t *  key: A public key owned by this identity\n\t *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\n\t *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  key: bytes32 The public key. // Its the Keccak256 hash of the key\n\t */\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of an Execution\n\t *\n\t *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\n\t *  to: address of contract to interact with, can be address(this)\n\t *  value: ETH to transfer with the transaction\n\t *  data: payload of the transaction to execute\n\t *  approved: approval status of the Execution\n\t *  executed: execution status of the Execution (set as false when the Execution is created\n\t *  and updated to true when the Execution is processed)\n\t */\n\tstruct Execution {\n\t\taddress to;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool approved;\n\t\tbool executed;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of a Claim.\n\t *\n\t *  Specification: Claims are information an issuer has about the identity holder.\n\t *  The structure should be as follows:\n\t *  claim: A claim published for the Identity.\n\t *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\n\t *  number schemes, sub topics based on number ranges??))\n\t *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\n\t *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\n\t *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  (ToBeDefined)\n\t *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\n\t *  identity contract, it should hold the key with which the above message was signed, if the key is not present\n\t *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\n\t *  claim can be verified using the call data.\n\t *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\n\t *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\n\t *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\n\t *  the claim scheme.\n\t *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t */\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n}\n"
    },
    "src/version/Version.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\n/**\n * @dev Version contract gives the versioning information of the implementation contract\n */\ncontract Version {\n\t/**\n\t * @dev Returns the string of the current version.\n\t */\n\tfunction version() external pure returns (string memory) {\n\t\t// version 2.2.0\n\t\treturn \"2.2.1\";\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}