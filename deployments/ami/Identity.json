{
  "address": "0xC029b88e083348859263C26DAbC1F4Fb576142Bf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialManagementKey",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_isLibrary",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "idFactoryAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "executionId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "Approved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "claimId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "topic",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "scheme",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "name": "ClaimAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "claimId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "topic",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "scheme",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "name": "ClaimChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "claimId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "topic",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "scheme",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "name": "ClaimRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "executionId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "Executed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "executionId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ExecutionFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "executionId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ExecutionRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "purpose",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "keyType",
          "type": "uint256"
        }
      ],
      "name": "KeyAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "purpose",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "keyType",
          "type": "uint256"
        }
      ],
      "name": "KeyRemoved",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_topic",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_scheme",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_issuer",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "internalType": "string",
          "name": "_uri",
          "type": "string"
        }
      ],
      "name": "addClaim",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "claimRequestId",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_purpose",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        }
      ],
      "name": "addKey",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_approve",
          "type": "bool"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "executionId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_claimId",
          "type": "bytes32"
        }
      ],
      "name": "getClaim",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "topic",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "scheme",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_topic",
          "type": "uint256"
        }
      ],
      "name": "getClaimIdsByTopic",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "claimIds",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        }
      ],
      "name": "getKey",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "purposes",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "keyType",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        }
      ],
      "name": "getKeyPurposes",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "_purposes",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_purpose",
          "type": "uint256"
        }
      ],
      "name": "getKeysByPurpose",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "keys",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "sig",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        }
      ],
      "name": "getRecoveredAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "idFactory",
      "outputs": [
        {
          "internalType": "contract IdFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialManagementKey",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_idFactoryAddress",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IIdentity",
          "name": "_identity",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "claimTopic",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "sig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "isClaimValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "claimValid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_purpose",
          "type": "uint256"
        }
      ],
      "name": "keyHasPurpose",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_claimId",
          "type": "bytes32"
        }
      ],
      "name": "removeClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_purpose",
          "type": "uint256"
        }
      ],
      "name": "removeKey",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xf8f129b6404de233d1b6df104e48086d9288cd0b55d5ed6ccd31bcf418054d5c",
  "receipt": {
    "to": null,
    "from": "0x7fE5651a316608DDA2cf0F896e3dbD403670172B",
    "contractAddress": "0xC029b88e083348859263C26DAbC1F4Fb576142Bf",
    "transactionIndex": 3,
    "gasUsed": "3385570",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000040200000000000000000000000000008008000000000000000000440000000000000000000000000100000000800000000000040000000100001000000000000000000000000000000000000000000000000000000080000000000000000000020000000000000000000000001000000800000000000000000000000000200100000000000000000000000000000000000000000000000000000080004010000000000000000001000000000200000000080000000000100000000040000000000000000000000000000000008000000000000000000000000000100000",
    "blockHash": "0x352bd1c68a9c52cd292c2be20f83b0f5afbc1c3047661b3ec799c214963acefd",
    "transactionHash": "0xf8f129b6404de233d1b6df104e48086d9288cd0b55d5ed6ccd31bcf418054d5c",
    "logs": [
      {
        "transactionIndex": 3,
        "blockNumber": 11352093,
        "transactionHash": "0xf8f129b6404de233d1b6df104e48086d9288cd0b55d5ed6ccd31bcf418054d5c",
        "address": "0xC029b88e083348859263C26DAbC1F4Fb576142Bf",
        "topics": [
          "0x480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e9",
          "0xc66333e9ea17ed09607dd26ab650b4a56298db4790839d8ac528010db1a702fc",
          "0x0000000000000000000000000000000000000000000000000000000000000001",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        "data": "0x",
        "logIndex": 207,
        "blockHash": "0x352bd1c68a9c52cd292c2be20f83b0f5afbc1c3047661b3ec799c214963acefd"
      },
      {
        "transactionIndex": 3,
        "blockNumber": 11352093,
        "transactionHash": "0xf8f129b6404de233d1b6df104e48086d9288cd0b55d5ed6ccd31bcf418054d5c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000007fe5651a316608dda2cf0f896e3dbd403670172b",
          "0x0000000000000000000000004ad84f7014b7b44f723f284a85b1662337971439"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000168d6bd445dd80000000000000000000000000000000000000000000000000012f9de639696bf850000000000000000000000000000000000000000000002571451bb52b84638fb000000000000000000000000000000000000000000000000119107a65238e78500000000000000000000000000000000000000000000025715ba920ffca410fb",
        "logIndex": 208,
        "blockHash": "0x352bd1c68a9c52cd292c2be20f83b0f5afbc1c3047661b3ec799c214963acefd"
      }
    ],
    "blockNumber": 11352093,
    "cumulativeGasUsed": "4758038",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x7fE5651a316608DDA2cf0F896e3dbD403670172B",
    false,
    "0xEFa926EBba3BE32fe2E6938717B21a6B0c7f7Cdc"
  ],
  "numDeployments": 1,
  "solcInputHash": "f40cd65ea153a6f9f0fcb574d5694131",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialManagementKey\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLibrary\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"idFactoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purpose\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"}],\"name\":\"KeyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purpose\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"}],\"name\":\"KeyRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_topic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scheme\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"addClaim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"claimRequestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"addKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_claimId\",\"type\":\"bytes32\"}],\"name\":\"getClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_topic\",\"type\":\"uint256\"}],\"name\":\"getClaimIdsByTopic\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"claimIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"purposes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getKeyPurposes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_purposes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"getKeysByPurpose\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"keys\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"getRecoveredAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idFactory\",\"outputs\":[{\"internalType\":\"contract IdFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialManagementKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_idFactoryAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimTopic\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isClaimValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"keyHasPurpose\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_claimId\",\"type\":\"bytes32\"}],\"name\":\"removeClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"removeKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the `IERC734` \\\"KeyHolder\\\" and the `IERC735` \\\"ClaimHolder\\\" interfaces into a common Identity Contract. This implementation has a separate contract were it declares all storage, allowing for it to be used as an upgradable logic contract.\",\"kind\":\"dev\",\"methods\":{\"addClaim(uint256,uint256,address,bytes,bytes,string)\":{\"details\":\"See {IERC735-addClaim}.\",\"params\":{\"_data\":\"The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.\",\"_issuer\":\"The issuers identity contract address, or the address used to sign the above signature.\",\"_scheme\":\"The scheme with which this claim SHOULD be verified or how it should be processed.\",\"_signature\":\"Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\",\"_topic\":\"The type of claim\",\"_uri\":\"The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\"},\"returns\":{\"claimRequestId\":\"Returns claimRequestId: COULD be send to the approve function, to approve or reject this claim. triggers ClaimAdded event.\"}},\"addKey(bytes32,uint256,uint256)\":{\"params\":{\"_key\":\"keccak256 representation of an ethereum address\",\"_purpose\":\"a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\",\"_type\":\"type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\"},\"returns\":{\"success\":\"Returns TRUE if the addition was successful and FALSE if not\"}},\"approve(uint256,bool)\":{\"details\":\"See {IERC734-approve}.\"},\"constructor\":{\"params\":{\"_isLibrary\":\"boolean value stating if the contract is library or not calls __Identity_init if contract is not library\",\"initialManagementKey\":\"the address of the management key at deployment\"}},\"execute(address,uint256,bytes)\":{\"details\":\"See {IERC734-execute}.\",\"returns\":{\"executionId\":\"to use in the approve function, to approve or reject this execution.\"}},\"getClaim(bytes32)\":{\"details\":\"See {IERC735-getClaim}.\",\"params\":{\"_claimId\":\"The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\"},\"returns\":{\"data\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\",\"issuer\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\",\"scheme\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\",\"signature\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\",\"topic\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\",\"uri\":\"Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .\"}},\"getClaimIdsByTopic(uint256)\":{\"details\":\"See {IERC735-getClaimIdsByTopic}.\",\"params\":{\"_topic\":\"The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\"},\"returns\":{\"claimIds\":\"Returns an array of claim IDs by topic.\"}},\"getKey(bytes32)\":{\"details\":\"See {IERC734-getKey}.\",\"params\":{\"_key\":\"The public key.  for non-hex and long keys, its the Keccak256 hash of the key\"},\"returns\":{\"key\":\"Returns the full key data, if present in the identity.\",\"keyType\":\"Returns the full key data, if present in the identity.\",\"purposes\":\"Returns the full key data, if present in the identity.\"}},\"getKeyPurposes(bytes32)\":{\"details\":\"See {IERC734-getKeyPurposes}.\",\"params\":{\"_key\":\"The public key.  for non-hex and long keys, its the Keccak256 hash of the key\"},\"returns\":{\"_purposes\":\"Returns the purposes of the specified key\"}},\"getKeysByPurpose(uint256)\":{\"details\":\"See {IERC734-getKeysByPurpose}.\",\"params\":{\"_purpose\":\"a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\"},\"returns\":{\"keys\":\"Returns an array of public key bytes32 hold by this identity and having the specified purpose\"}},\"getRecoveredAddress(bytes,bytes32)\":{\"details\":\"returns the address that signed the given data\",\"params\":{\"dataHash\":\"the data that was signed returns the address that signed dataHash and created the signature sig\",\"sig\":\"the signature of the data\"}},\"initialize(address,address)\":{\"params\":{\"initialManagementKey\":\"The ethereum address to be set as the management key of the ONCHAINID.\"}},\"isClaimValid(address,uint256,bytes,bytes)\":{\"details\":\"Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a built-in revocation mechanism and are considered valid as long as their signature is valid and they are still stored by the identity contract.\",\"params\":{\"_identity\":\"the identity contract related to the claim\",\"claimTopic\":\"the claim topic of the claim\",\"data\":\"the data field of the claim\",\"sig\":\"the signature of the claim\"},\"returns\":{\"claimValid\":\"true if the claim is valid, false otherwise\"}},\"keyHasPurpose(bytes32,uint256)\":{\"details\":\"See {IERC734-keyHasPurpose}.\"},\"removeClaim(bytes32)\":{\"details\":\"See {IERC735-removeClaim}.\",\"params\":{\"_claimId\":\"The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\"},\"returns\":{\"success\":\"Returns TRUE when the claim was removed. triggers ClaimRemoved event\"}},\"removeKey(bytes32,uint256)\":{\"details\":\"See {IERC734-removeKey}.\"},\"version()\":{\"details\":\"Returns the string of the current version.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addClaim(uint256,uint256,address,bytes,bytes,string)\":{\"notice\":\"Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.\"},\"addKey(bytes32,uint256,uint256)\":{\"notice\":\"implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.\"},\"approve(uint256,bool)\":{\"notice\":\"Approves an execution.  If the sender is an ACTION key and the destination address is not the identity contract itself, then the  approval is authorized and the operation would be performed.  If the destination address is the identity itself, then the execution would be authorized and performed only  if the sender is a MANAGEMENT key.\"},\"constructor\":{\"notice\":\"constructor of the Identity contract\"},\"execute(address,uint256,bytes)\":{\"notice\":\"Passes an execution instruction to the keymanager. If the sender is an ACTION key and the destination address is not the identity contract itself, then the execution is immediately approved and performed. If the destination address is the identity itself, then the execution would be performed immediately only if the sender is a MANAGEMENT key. Otherwise the execution request must be approved via the `approve` method.\"},\"getClaim(bytes32)\":{\"notice\":\"Implementation of the getClaim function from the ERC-735 standard.\"},\"getClaimIdsByTopic(uint256)\":{\"notice\":\"Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic\"},\"getKey(bytes32)\":{\"notice\":\"Implementation of the getKey function from the ERC-734 standard\"},\"getKeyPurposes(bytes32)\":{\"notice\":\"gets the purposes of a key\"},\"getKeysByPurpose(uint256)\":{\"notice\":\"gets all the keys with a specific purpose from an identity\"},\"initialize(address,address)\":{\"notice\":\"When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\"},\"keyHasPurpose(bytes32,uint256)\":{\"notice\":\"Returns true if the key has MANAGEMENT purpose or the specified purpose.\"},\"removeClaim(bytes32)\":{\"notice\":\"Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.\"},\"removeKey(bytes32,uint256)\":{\"notice\":\"Remove the purpose from a key.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/Identity.sol\":\"Identity\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"../interfaces/IAny2EVMMessageReceiver.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\nimport {IERC165} from \\\"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\\n  address internal immutable i_ccipRouter;\\n\\n  constructor(address router) {\\n    if (router == address(0)) revert InvalidRouter(address(0));\\n    i_ccipRouter = router;\\n  }\\n\\n  /// @notice IERC165 supports an interfaceId\\n  /// @param interfaceId The interfaceId to check\\n  /// @return true if the interfaceId is supported\\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\\n  /// This allows CCIP to check if ccipReceive is available before calling it.\\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\\n  /// Additionally, if the receiver address does not have code associated with\\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc IAny2EVMMessageReceiver\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\\n    _ccipReceive(message);\\n  }\\n\\n  /// @notice Override this function in your implementation.\\n  /// @param message Any2EVMMessage\\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  // Plumbing\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Return the current router\\n  /// @return CCIP router address\\n  function getRouter() public view returns (address) {\\n    return address(i_ccipRouter);\\n  }\\n\\n  error InvalidRouter(address router);\\n\\n  /// @dev only calls from the set router are accepted.\\n  modifier onlyRouter() {\\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x23827b8b1cd9f1d7886720ab0347d34891c4a584dc9ee048b85a41dc2241917f\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from\\n/// the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message.\\n  /// If this reverts, any token transfers also revert. The message\\n  /// will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\\n}\\n\",\"keccak256\":\"0xd2a05a4f58a453cbf8cfa6aa78f58cb8e42091b3a025f711a0aa51f584e16b48\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param chainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\\n\\n  /// @notice Gets a list of all supported tokens which can be sent or received\\n  /// to/from a given chain id.\\n  /// @param chainSelector The chainSelector.\\n  /// @return tokens The addresses of all tokens that are supported.\\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\\n\\n  /// @param destinationChainSelector The destination chainSelector\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return fee returns execution fee for the message\\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain\\n  /// @param destinationChainSelector The destination chain ID\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return messageId The message ID\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\\n  /// the overpayment with no refund.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\",\"keccak256\":\"0x7f2fdd93e516b7476c6fab099f6806adf5ceaf399b0cc415f6b9ede890f2379b\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\",\"keccak256\":\"0x8af3ac1085c87342373772fb1a0107c7b90258e6bfed318ab2a601a14477e679\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\",\"keccak256\":\"0xa36a31b4bb17fad88d023474893b3b895fa421650543b1ce5aefc78efbd43244\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xa535a5df777d44e945dd24aa43a11e44b024140fc340ad0dfe42acf4002aade1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"src/Identity.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport './interface/IIdentity.sol';\\nimport './interface/IClaimIssuer.sol';\\nimport './version/Version.sol';\\nimport './storage/Storage.sol';\\nimport { CrossChainBridge } from './bridge/Bridge.sol';\\n\\n/**\\n * @dev Implementation of the `IERC734` \\\"KeyHolder\\\" and the `IERC735` \\\"ClaimHolder\\\" interfaces\\n * into a common Identity Contract.\\n * This implementation has a separate contract were it declares all storage,\\n * allowing for it to be used as an upgradable logic contract.\\n */\\ncontract Identity is Storage, IIdentity, Version {\\n  /**\\n   * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\\n   */\\n  modifier delegatedOnly() {\\n    require(_canInteract == true, 'Interacting with the library contract is forbidden.');\\n    _;\\n  }\\n\\n  /**\\n   * @notice requires management key to call this function, or internal call\\n   */\\n  modifier onlyManager() {\\n    require(\\n      msg.sender == address(this) ||\\n        msg.sender == idFactory.getBridge() ||\\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 1),\\n      'Permissions: Sender does not have management key'\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @notice requires claim key to call this function, or internal call\\n   */\\n  modifier onlyClaimKey() {\\n    require(\\n      msg.sender == address(this) ||\\n        msg.sender == idFactory.getBridge() ||\\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 3),\\n      'Permissions: Sender does not have claim signer key'\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @notice constructor of the Identity contract\\n   * @param initialManagementKey the address of the management key at deployment\\n   * @param _isLibrary boolean value stating if the contract is library or not\\n   * calls __Identity_init if contract is not library\\n   */\\n  constructor(address initialManagementKey, bool _isLibrary, address idFactoryAddress) {\\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\\n\\n    if (!_isLibrary) {\\n      __Identity_init(initialManagementKey, idFactoryAddress);\\n    } else {\\n      _initialized = true;\\n    }\\n\\n    idFactory = IdFactory(idFactoryAddress);\\n  }\\n\\n  /**\\n   * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\\n   *\\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\\n   */\\n  function initialize(address initialManagementKey, address _idFactoryAddress) external {\\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\\n    __Identity_init(initialManagementKey, _idFactoryAddress);\\n  }\\n\\n  /**\\n   * @dev See {IERC734-execute}.\\n   * @notice Passes an execution instruction to the keymanager.\\n   * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\\n   * execution is immediately approved and performed.\\n   * If the destination address is the identity itself, then the execution would be performed immediately only if\\n   * the sender is a MANAGEMENT key.\\n   * Otherwise the execution request must be approved via the `approve` method.\\n   * @return executionId to use in the approve function, to approve or reject this execution.\\n   */\\n  function execute(\\n    address _to,\\n    uint256 _value,\\n    bytes memory _data\\n  ) external payable override delegatedOnly returns (uint256 executionId) {\\n    uint256 _executionId = _executionNonce;\\n    _executions[_executionId].to = _to;\\n    _executions[_executionId].value = _value;\\n    _executions[_executionId].data = _data;\\n    _executionNonce++;\\n\\n    emit ExecutionRequested(_executionId, _to, _value, _data);\\n\\n    if (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\\n      approve(_executionId, true);\\n    } else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)) {\\n      approve(_executionId, true);\\n    }\\n\\n    return _executionId;\\n  }\\n\\n  /**\\n   * @dev See {IERC734-getKey}.\\n   * @notice Implementation of the getKey function from the ERC-734 standard\\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\\n   * @return purposes Returns the full key data, if present in the identity.\\n   * @return keyType Returns the full key data, if present in the identity.\\n   * @return key Returns the full key data, if present in the identity.\\n   */\\n  function getKey(\\n    bytes32 _key\\n  ) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\\n    return (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\\n  }\\n\\n  /**\\n   * @dev See {IERC734-getKeyPurposes}.\\n   * @notice gets the purposes of a key\\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\\n   * @return _purposes Returns the purposes of the specified key\\n   */\\n  function getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\\n    return (_keys[_key].purposes);\\n  }\\n\\n  /**\\n   * @dev See {IERC734-getKeysByPurpose}.\\n   * @notice gets all the keys with a specific purpose from an identity\\n   * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\\n   * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\\n   */\\n  function getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory keys) {\\n    return _keysByPurpose[_purpose];\\n  }\\n\\n  /**\\n   * @dev See {IERC735-getClaimIdsByTopic}.\\n   * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\\n   * used to get all the claims from the specified topic\\n   * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n   * @return claimIds Returns an array of claim IDs by topic.\\n   */\\n  function getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds) {\\n    return _claimsByTopic[_topic];\\n  }\\n\\n  /**\\n   * @notice implementation of the addKey function of the ERC-734 standard\\n   * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\\n   * 1: MANAGEMENT keys, which can manage the identity\\n   * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\\n   * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\\n   * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\\n   * MUST only be done by keys of purpose 1, or the identity itself.\\n   * If its the identity itself, the approval process will determine its approval.\\n   * @param _key keccak256 representation of an ethereum address\\n   * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\\n   * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\\n   * @return success Returns TRUE if the addition was successful and FALSE if not\\n   */\\n  function addKey(\\n    bytes32 _key,\\n    uint256 _purpose,\\n    uint256 _type\\n  ) public override delegatedOnly onlyManager returns (bool success) {\\n    if (_keys[_key].key == _key) {\\n      uint256[] memory _purposes = _keys[_key].purposes;\\n      for (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\\n        uint256 purpose = _purposes[keyPurposeIndex];\\n\\n        if (purpose == _purpose) {\\n          revert('Conflict: Key already has purpose');\\n        }\\n      }\\n\\n      _keys[_key].purposes.push(_purpose);\\n    } else {\\n      _keys[_key].key = _key;\\n      _keys[_key].purposes = [_purpose];\\n      _keys[_key].keyType = _type;\\n    }\\n\\n    _keysByPurpose[_purpose].push(_key);\\n\\n    emit KeyAdded(_key, _purpose, _type);\\n\\n    bool isHomeChain = idFactory._isHomeChain();\\n    if (isHomeChain) {\\n      address bridgeAddress = idFactory.getBridge();\\n      // Explicit conversion to payable address and then to CrossChainBridge\\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\\n\\n      // Get Destination Chain Selectors and their receivers\\n      address[] memory receivers = idFactory.getReceivers();\\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\\n\\n      // Send message to the bridge\\n      for (uint i = 0; i < receivers.length; i++) {\\n        bridge.sendAddKey(chainSelectors[i], receivers[i], _key, _purpose, _type);\\n      }\\n    } else {}\\n\\n    return true;\\n  }\\n\\n  /**\\n   *  @dev See {IERC734-approve}.\\n   *  @notice Approves an execution.\\n   *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\\n   *  approval is authorized and the operation would be performed.\\n   *  If the destination address is the identity itself, then the execution would be authorized and performed only\\n   *  if the sender is a MANAGEMENT key.\\n   */\\n  function approve(uint256 _id, bool _approve) public override delegatedOnly returns (bool success) {\\n    require(_id < _executionNonce, 'Cannot approve a non-existing execution');\\n    require(!_executions[_id].executed, 'Request already executed');\\n\\n    if (_executions[_id].to == address(this)) {\\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), 'Sender does not have management key');\\n    } else {\\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), 'Sender does not have action key');\\n    }\\n\\n    emit Approved(_id, _approve);\\n\\n    if (_approve == true) {\\n      _executions[_id].approved = true;\\n\\n      // solhint-disable-next-line avoid-low-level-calls\\n      (success, ) = _executions[_id].to.call{ value: (_executions[_id].value) }(_executions[_id].data);\\n\\n      if (success) {\\n        _executions[_id].executed = true;\\n\\n        emit Executed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\\n\\n        return true;\\n      } else {\\n        emit ExecutionFailed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\\n\\n        return false;\\n      }\\n    } else {\\n      _executions[_id].approved = false;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @dev See {IERC734-removeKey}.\\n   * @notice Remove the purpose from a key.\\n   */\\n  function removeKey(bytes32 _key, uint256 _purpose) public override delegatedOnly onlyManager returns (bool success) {\\n    require(_keys[_key].key == _key, \\\"NonExisting: Key isn't registered\\\");\\n    uint256[] memory _purposes = _keys[_key].purposes;\\n\\n    uint purposeIndex = 0;\\n    while (_purposes[purposeIndex] != _purpose) {\\n      purposeIndex++;\\n\\n      if (purposeIndex == _purposes.length) {\\n        revert(\\\"NonExisting: Key doesn't have such purpose\\\");\\n      }\\n    }\\n\\n    _purposes[purposeIndex] = _purposes[_purposes.length - 1];\\n    _keys[_key].purposes = _purposes;\\n    _keys[_key].purposes.pop();\\n\\n    uint keyIndex = 0;\\n    uint arrayLength = _keysByPurpose[_purpose].length;\\n\\n    while (_keysByPurpose[_purpose][keyIndex] != _key) {\\n      keyIndex++;\\n\\n      if (keyIndex >= arrayLength) {\\n        break;\\n      }\\n    }\\n\\n    _keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\\n    _keysByPurpose[_purpose].pop();\\n\\n    uint keyType = _keys[_key].keyType;\\n\\n    if (_purposes.length - 1 == 0) {\\n      delete _keys[_key];\\n    }\\n\\n    emit KeyRemoved(_key, _purpose, keyType);\\n\\n    bool isHomeChain = idFactory._isHomeChain();\\n    if (isHomeChain) {\\n      address bridgeAddress = idFactory.getBridge();\\n      // Explicit conversion to payable address and then to CrossChainBridge\\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\\n\\n      // Get Destination Chain Selectors and their receivers\\n      address[] memory receivers = idFactory.getReceivers();\\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\\n\\n      // Send message to the bridge\\n      for (uint i = 0; i < receivers.length; i++) {\\n        if (receivers[i] != address(bridge)) {\\n          bridge.sendRemoveKey(chainSelectors[i], receivers[i], address(this), _key, _purpose);\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC735-addClaim}.\\n   * @notice Implementation of the addClaim function from the ERC-735 standard\\n   *  Require that the msg.sender has claim signer key.\\n   *\\n   * @param _topic The type of claim\\n   * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\\n   * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\\n   * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\\n   * it MUST be a signed message of the following structure:\\n   * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\\n   * @param _data The hash of the claim data, sitting in another\\n   * location, a bit-mask, call data, or actual data based on the claim scheme.\\n   * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\\n   *\\n   * @return claimRequestId Returns claimRequestId: COULD be\\n   * send to the approve function, to approve or reject this claim.\\n   * triggers ClaimAdded event.\\n   */\\n  function addClaim(\\n    uint256 _topic,\\n    uint256 _scheme,\\n    address _issuer,\\n    bytes memory _signature,\\n    bytes memory _data,\\n    string memory _uri\\n  ) public override delegatedOnly onlyClaimKey returns (bytes32 claimRequestId) {\\n    if (_issuer != address(this)) {\\n      require(IClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data), 'invalid claim');\\n    }\\n\\n    bytes32 claimId = keccak256(abi.encode(_issuer, _topic));\\n    _claims[claimId].topic = _topic;\\n    _claims[claimId].scheme = _scheme;\\n    _claims[claimId].signature = _signature;\\n    _claims[claimId].data = _data;\\n    _claims[claimId].uri = _uri;\\n\\n    if (_claims[claimId].issuer != _issuer) {\\n      _claimsByTopic[_topic].push(claimId);\\n      _claims[claimId].issuer = _issuer;\\n\\n      // Call Factory, Get Bridge\\n      // Call Bridge, Send Claim\\n\\n      emit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\\n    } else {\\n      emit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\\n    }\\n\\n    bool isHomeChain = idFactory._isHomeChain();\\n    if (isHomeChain) {\\n      address bridgeAddress = idFactory.getBridge();\\n      // Explicit conversion to payable address and then to CrossChainBridge\\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\\n\\n      // Get Destination Chain Selectors and their receivers\\n      address[] memory receivers = idFactory.getReceivers();\\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\\n\\n      // Send message to the bridge\\n      for (uint i = 0; i < receivers.length; i++) {\\n        if (receivers[i] != address(bridge)) {\\n          bridge.sendAddClaim(\\n            chainSelectors[i],\\n            receivers[i],\\n            address(this),\\n            _topic,\\n            _scheme,\\n            _issuer,\\n            _signature,\\n            _data,\\n            _uri\\n          );\\n        }\\n      }\\n    }\\n\\n    return claimId;\\n  }\\n\\n  /**\\n   * @dev See {IERC735-removeClaim}.\\n   * @notice Implementation of the removeClaim function from the ERC-735 standard\\n   * Require that the msg.sender has management key.\\n   * Can only be removed by the claim issuer, or the claim holder itself.\\n   *\\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n   *\\n   * @return success Returns TRUE when the claim was removed.\\n   * triggers ClaimRemoved event\\n   */\\n  function removeClaim(bytes32 _claimId) public override delegatedOnly onlyClaimKey returns (bool success) {\\n    uint256 _topic = _claims[_claimId].topic;\\n    if (_topic == 0) {\\n      revert('NonExisting: There is no claim with this ID');\\n    }\\n\\n    uint claimIndex = 0;\\n    uint arrayLength = _claimsByTopic[_topic].length;\\n    while (_claimsByTopic[_topic][claimIndex] != _claimId) {\\n      claimIndex++;\\n\\n      if (claimIndex >= arrayLength) {\\n        break;\\n      }\\n    }\\n\\n    _claimsByTopic[_topic][claimIndex] = _claimsByTopic[_topic][arrayLength - 1];\\n    _claimsByTopic[_topic].pop();\\n\\n    emit ClaimRemoved(\\n      _claimId,\\n      _topic,\\n      _claims[_claimId].scheme,\\n      _claims[_claimId].issuer,\\n      _claims[_claimId].signature,\\n      _claims[_claimId].data,\\n      _claims[_claimId].uri\\n    );\\n\\n    delete _claims[_claimId];\\n\\n    bool isHomeChain = idFactory._isHomeChain();\\n    if (isHomeChain) {\\n      address bridgeAddress = idFactory.getBridge();\\n      // Explicit conversion to payable address and then to CrossChainBridge\\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\\n\\n      // Get Destination Chain Selectors and their receivers\\n      address[] memory receivers = idFactory.getReceivers();\\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\\n\\n      // Send message to the bridge\\n      for (uint i = 0; i < receivers.length; i++) {\\n        if (receivers[i] != address(bridge)) {\\n          bridge.sendRemoveClaim(chainSelectors[i], receivers[i], address(this), _claimId);\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC735-getClaim}.\\n   * @notice Implementation of the getClaim function from the ERC-735 standard.\\n   *\\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n   *\\n   * @return topic Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   * @return scheme Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   * @return issuer Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   * @return signature Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   * @return data Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   * @return uri Returns all the parameters of the claim for the\\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n   */\\n  function getClaim(\\n    bytes32 _claimId\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      uint256 topic,\\n      uint256 scheme,\\n      address issuer,\\n      bytes memory signature,\\n      bytes memory data,\\n      string memory uri\\n    )\\n  {\\n    return (\\n      _claims[_claimId].topic,\\n      _claims[_claimId].scheme,\\n      _claims[_claimId].issuer,\\n      _claims[_claimId].signature,\\n      _claims[_claimId].data,\\n      _claims[_claimId].uri\\n    );\\n  }\\n\\n  /**\\n   * @dev See {IERC734-keyHasPurpose}.\\n   * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\\n   */\\n  function keyHasPurpose(bytes32 _key, uint256 _purpose) public view override returns (bool result) {\\n    Key memory key = _keys[_key];\\n    if (key.key == 0) return false;\\n\\n    for (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\\n      uint256 purpose = key.purposes[keyPurposeIndex];\\n\\n      if (purpose == 1 || purpose == _purpose) return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\\n   * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\\n   * stored by the identity contract.\\n   * @param _identity the identity contract related to the claim\\n   * @param claimTopic the claim topic of the claim\\n   * @param sig the signature of the claim\\n   * @param data the data field of the claim\\n   * @return claimValid true if the claim is valid, false otherwise\\n   */\\n  function isClaimValid(\\n    IIdentity _identity,\\n    uint256 claimTopic,\\n    bytes memory sig,\\n    bytes memory data\\n  ) public view virtual override returns (bool claimValid) {\\n    bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\\n    // Use abi.encodePacked to concatenate the message prefix and the message to sign.\\n    bytes32 prefixedHash = keccak256(abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n32', dataHash));\\n\\n    // Recover address of data signer\\n    address recovered = getRecoveredAddress(sig, prefixedHash);\\n\\n    // Take hash of recovered address\\n    bytes32 hashedAddr = keccak256(abi.encode(recovered));\\n\\n    // Does the trusted identifier have they key which signed the user's claim?\\n    //  && (isClaimRevoked(_claimId) == false)\\n    if (keyHasPurpose(hashedAddr, 3)) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * @dev returns the address that signed the given data\\n   * @param sig the signature of the data\\n   * @param dataHash the data that was signed\\n   * returns the address that signed dataHash and created the signature sig\\n   */\\n  function getRecoveredAddress(bytes memory sig, bytes32 dataHash) public pure returns (address addr) {\\n    bytes32 ra;\\n    bytes32 sa;\\n    uint8 va;\\n\\n    // Check the signature length\\n    if (sig.length != 65) {\\n      return address(0);\\n    }\\n\\n    // Divide the signature in r, s and v variables\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      ra := mload(add(sig, 32))\\n      sa := mload(add(sig, 64))\\n      va := byte(0, mload(add(sig, 96)))\\n    }\\n\\n    if (va < 27) {\\n      va += 27;\\n    }\\n\\n    address recoveredAddress = ecrecover(dataHash, va, ra, sa);\\n\\n    return (recoveredAddress);\\n  }\\n\\n  /**\\n   * @notice Initializer internal function for the Identity contract.\\n   *\\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function __Identity_init(address initialManagementKey, address _idFactoryAddress) internal {\\n    require(!_initialized || _isConstructor(), 'Initial key was already setup.');\\n    _initialized = true;\\n    _canInteract = true;\\n\\n    idFactory = IdFactory(_idFactoryAddress);\\n\\n    bytes32 _key = keccak256(abi.encode(initialManagementKey));\\n    _keys[_key].key = _key;\\n    _keys[_key].purposes = [1];\\n    _keys[_key].keyType = 1;\\n    _keysByPurpose[1].push(_key);\\n    emit KeyAdded(_key, 1, 1);\\n  }\\n\\n  /**\\n   * @notice Computes if the context in which the function is called is a constructor or not.\\n   *\\n   * @return true if the context is a constructor.\\n   */\\n  function _isConstructor() private view returns (bool) {\\n    address self = address(this);\\n    uint256 cs;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      cs := extcodesize(self)\\n    }\\n    return cs == 0;\\n  }\\n}\\n\",\"keccak256\":\"0xf4ad8d5384dcec98025ce56c7595750b71075f6ff7f376344773a8b4e54a1173\",\"license\":\"GPL-3.0\"},\"src/bridge/Bridge.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n// Chainlink\\nimport { IRouterClient } from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol';\\nimport { CCIPReceiver } from '@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol';\\nimport { Client } from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\\n// OpenZeppelin\\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n// Interfaces\\nimport { IIdentity } from '../interface/IIdentity.sol';\\nimport { Gateway } from '../gateway/Gateway.sol';\\nimport '../factory/IIdFactory.sol';\\n\\n/// @notice REmOVE in PROD\\nimport 'hardhat/console.sol';\\n\\ncontract CrossChainBridge is CCIPReceiver, ReentrancyGuard {\\n  /// @notice REMOVE for prod\\n  string public ccipMessage;\\n\\n  address immutable i_router;\\n  address public idFactoryAddress;\\n\\n  // Map to store the messageIds of the messages sent\\n  mapping(bytes32 => bool) public messageIds;\\n\\n  // Map to store allowedContracts\\n  mapping(address => bool) public isAllowedContract;\\n\\n  // Map to store onlyManagers\\n  mapping(address => bool) public isManager;\\n\\n  // Define the enum\\n  enum AccessAddressTypes {\\n    CONTRACT,\\n    MANAGER\\n  }\\n\\n  modifier onlyAllowedSender() {\\n    require(\\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\\n      'Permissions: Sender is not a allowed'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyAllowedContract() {\\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\\n    _;\\n  }\\n\\n  modifier onlyAllowedIdentity(address _identity) {\\n    IIdFactory idFactory = IIdFactory(idFactoryAddress);\\n    require(idFactory.identityIsCreated(_identity), 'Permissions: idFactory marks this address as not identity');\\n    _;\\n  }\\n\\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\\n\\n  event MessageSent(bytes32 indexed messageId);\\n  event MessageReceived(\\n    bytes32 messageId,\\n    uint64 indexed sourceChainSelector,\\n    address indexed sender,\\n    string indexed action\\n  );\\n  event IdFactoryUpdated(address indexed sender, address indexed newAddress);\\n\\n  constructor(address _router) CCIPReceiver(_router) {\\n    i_router = _router;\\n    isManager[msg.sender] = true;\\n    emit AllowedAddress(msg.sender, uint64(AccessAddressTypes.MANAGER), true);\\n  }\\n\\n  receive() external payable {}\\n\\n  function setFactoryAddress(address _idFactoryAddress) external onlyManager {\\n    idFactoryAddress = _idFactoryAddress;\\n    emit IdFactoryUpdated(msg.sender, _idFactoryAddress);\\n  }\\n\\n  function sendAddClaim(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    address identity,\\n    uint256 topic,\\n    uint256 scheme,\\n    address issuer,\\n    bytes memory signature,\\n    bytes memory data,\\n    string memory uri\\n  ) external onlyAllowedSender {\\n    bytes memory _payload = abi.encode(msg.sender, identity, topic, scheme, issuer, signature, data, uri);\\n    bytes memory metaPayload = abi.encode('AddClaim', _payload);\\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\\n  }\\n\\n  function sendRemoveClaim(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    address identity,\\n    bytes32 claimId\\n  ) external onlyAllowedSender {\\n    bytes memory payload = abi.encode('RemoveClaim', identity, claimId);\\n    _sendMessage(destinationChainSelector, receiver, payload);\\n  }\\n\\n  function sendAddKey(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    bytes32 key,\\n    uint256 purpose,\\n    uint256 keyType\\n  ) external onlyAllowedIdentity(msg.sender) {\\n    bytes memory _payload = abi.encode(msg.sender, key, purpose, keyType);\\n    bytes memory metaPayload = abi.encode('AddKey', _payload);\\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\\n  }\\n\\n  function sendRemoveKey(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    address identity,\\n    bytes32 key,\\n    uint256 purpose\\n  ) external onlyAllowedSender {\\n    bytes memory payload = abi.encode('RemoveKey', identity, key, purpose);\\n    _sendMessage(destinationChainSelector, receiver, payload);\\n  }\\n\\n  function sendCreateIdentity(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    address gateway,\\n    address identityOwner,\\n    string memory salt,\\n    bytes32[] calldata managementKeys\\n  ) external onlyAllowedSender {\\n    bytes memory _payload = abi.encode(gateway, identityOwner, salt, managementKeys);\\n    bytes memory metaPayload = abi.encode('CreateIdentity', _payload);\\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\\n  }\\n\\n  function _sendMessage(uint64 destinationChainSelector, address receiver, bytes memory payload) internal nonReentrant {\\n    (uint256 fee, Client.EVM2AnyMessage memory message) = calculateFeeAndMessage(\\n      destinationChainSelector,\\n      receiver,\\n      payload\\n    );\\n\\n    bytes32 messageId = IRouterClient(i_router).ccipSend{ value: fee }(destinationChainSelector, message);\\n\\n    emit MessageSent(messageId);\\n  }\\n\\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal override {\\n    // Check if the message was already processed\\n    require(!messageIds[message.messageId], 'Message already processed');\\n    messageIds[message.messageId] = true;\\n    // Decode the message data\\n    (string memory action, bytes memory _payload) = abi.decode(message.data, (string, bytes));\\n    if (keccak256(bytes(action)) == keccak256(bytes('AddClaim'))) {\\n        (\\n          address targetIdentity,\\n          uint256 topic,\\n          uint256 scheme,\\n          address issuer,\\n          bytes memory signature,\\n          bytes memory decodedData,\\n          string memory uri\\n        ) = abi.decode(_payload, (address, uint256, uint256, address, bytes, bytes, string));\\n        IIdentity(targetIdentity).addClaim(topic, scheme, issuer, signature, decodedData, uri);\\n      // } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveClaim'))) {\\n      //   bytes32 claimId = abi.decode(data, (bytes32));\\n      //   IIdentity(targetContract).removeClaim(claimId);\\n    } else if (keccak256(bytes(action)) == keccak256(bytes('AddKey'))) {\\n      (address targetIdentity, bytes32 key, uint256 purpose, uint256 keyType) = abi.decode(\\n        _payload,\\n        (address, bytes32, uint256, uint256)\\n      );\\n      IIdentity(targetIdentity).addKey(key, purpose, keyType);\\n      // } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveKey'))) {\\n      //   (bytes32 key, uint256 purpose) = abi.decode(data, (bytes32, uint256));\\n      //   IIdentity(targetContract).removeKey(key, purpose);\\n    } else if (keccak256(bytes(action)) == keccak256(bytes('CreateIdentity'))) {\\n      (address targetContract, address identityOwner, string memory salt, bytes32[] memory managementKeys) = abi.decode(\\n        _payload,\\n        (address, address, string, bytes32[])\\n      );\\n      Gateway(targetContract).deployIdentity(identityOwner, salt, managementKeys);\\n    } else {\\n      revert('Unknown action');\\n    }\\n    emit MessageReceived(message.messageId, message.sourceChainSelector, abi.decode(message.sender, (address)), action);\\n  }\\n\\n  // Function to set allowed contracts\\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\\n    if (_status == true) {\\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\\n    }\\n    isAllowedContract[_contract] = _status;\\n\\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\\n  }\\n\\n  // Function to set manager status\\n  function setManager(address _manager, bool _status) external onlyManager {\\n    isManager[_manager] = _status;\\n\\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\\n  }\\n\\n  /// @notice REMOVE for prod\\n  function testSendMessage(\\n    uint64 _destinationChainSelector,\\n    address _receiver,\\n    string memory _message\\n  ) public onlyAllowedSender {\\n    bytes memory payload = abi.encode(_message);\\n    _sendMessage(_destinationChainSelector, _receiver, payload);\\n  }\\n\\n  /// @notice REMOVE for prod\\n  function _testRecieveMessage(Client.Any2EVMMessage memory any2EvmMessage) internal {\\n    bytes32 s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\\n    ccipMessage = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\\n    emit MessageReceived(s_lastReceivedMessageId, 0, msg.sender, ccipMessage);\\n  }\\n\\n  function calculateFeeAndMessage(\\n    uint64 destinationChainSelector,\\n    address receiver,\\n    bytes memory payload\\n  ) public view returns (uint256 fee, Client.EVM2AnyMessage memory message) {\\n    message = Client.EVM2AnyMessage({\\n      receiver: abi.encode(receiver),\\n      data: payload,\\n      tokenAmounts: new Client.EVMTokenAmount[](0),\\n      extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: 1000000 })),\\n      feeToken: address(0) // Use native token\\n    });\\n    fee = IRouterClient(i_router).getFee(destinationChainSelector, message);\\n    return (fee, message);\\n  }\\n\\n  // Function to withdraw native token from the contract\\n  function withdraw(address _to, uint256 _amount) external onlyManager nonReentrant {\\n    require(address(this).balance >= _amount, 'Insufficient balance');\\n    Address.sendValue(payable(_to), _amount);\\n  }\\n}\\n\",\"keccak256\":\"0x836d611ea1513652b4baf1d15fbe60a92d526112028a0e0c24260553086a6101\",\"license\":\"GPL-3.0\"},\"src/factory/IIdFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ninterface IIdFactory {\\n  /// events\\n\\n  // event emitted whenever a single contract is deployed by the factory\\n  event Deployed(address indexed _addr);\\n\\n  // event emitted when a wallet is linked to an ONCHAINID contract\\n  event WalletLinked(address indexed wallet, address indexed identity);\\n\\n  // event emitted when a token is linked to an ONCHAINID contract\\n  event TokenLinked(address indexed token, address indexed identity);\\n\\n  // event emitted when a wallet is unlinked from an ONCHAINID contract\\n  event WalletUnlinked(address indexed wallet, address indexed identity);\\n\\n  // event emitted when an address is registered on the factory as a Token\\n  // factory address, granting this address the privilege to issue\\n  // Onchain identities for tokens\\n  event TokenFactoryAdded(address indexed factory);\\n\\n  // event emitted when a previously recorded token factory address is removed\\n  event TokenFactoryRemoved(address indexed factory);\\n\\n  // event emitted when a receiver is added for a chainSelector\\n  event ReceiverAdded(uint64 chainSelector, address receiver, address gateway);\\n\\n  // event emitted when a receiver is removed for a chainSelector\\n  event ReceiverRemoved(uint64 chainSelector);\\n\\n  /// functions\\n\\n  /**\\n   *  @dev function used to create a new Identity proxy from the factory\\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\\n   *  @param _salt the salt used by create2 to issue the contract\\n   *  requires a new salt for each deployment\\n   *  _wallet cannot be linked to another ONCHAINID\\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\\n   *  of the function, including calls to oracles for multichain\\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\\n   */\\n  function createIdentity(address _wallet, string memory _salt) external returns (address);\\n\\n  /**\\n   *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\\n   * MANAGEMENT keys.\\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\\n   *  @param _salt the salt used by create2 to issue the contract\\n   *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\\n   *  requires a new salt for each deployment\\n   *  _wallet cannot be linked to another ONCHAINID\\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\\n   *  of the function, including calls to oracles for multichain\\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\\n   */\\n  function createIdentityWithManagementKeys(\\n    address _wallet,\\n    string memory _salt,\\n    bytes32[] memory _managementKeys\\n  ) external returns (address);\\n\\n  /**\\n   *  @dev function used to create a new Token Identity proxy from the factory\\n   *  @param _token the address of the token contract\\n   *  @param _tokenOwner the owner address of the token\\n   *  @param _salt the salt used by create2 to issue the contract\\n   *  requires a new salt for each deployment\\n   *  _token cannot be linked to another ONCHAINID\\n   *  only Token factory or owner can call (owner should only use its privilege\\n   *  for tokens not issued by a Token factory onchain\\n   */\\n  function createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\\n\\n  /**\\n   * @dev function used to update bridge contract address\\n   * @param _bridge the address of the bridge contract\\n   * can be called only by Owner\\n   */\\n\\n  function setBridge(address _bridge) external;\\n\\n  /**\\n   *  @dev function used to link a new wallet to an existing identity\\n   *  @param _newWallet the address of the wallet to link\\n   *  requires msg.sender to be linked to an existing onchainid\\n   *  the _newWallet will be linked to the same OID contract as msg.sender\\n   *  _newWallet cannot be linked to an OID yet\\n   *  _newWallet cannot be address 0\\n   *  cannot link more than 100 wallets to an OID, for gas consumption reason\\n   */\\n  function linkWallet(address _newWallet) external;\\n\\n  /**\\n   *  @dev function used to unlink a wallet from an existing identity\\n   *  @param _oldWallet the address of the wallet to unlink\\n   *  requires msg.sender to be linked to the same onchainid as _oldWallet\\n   *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\\n   *  _oldWallet cannot be address 0\\n   */\\n  function unlinkWallet(address _oldWallet) external;\\n\\n  /**\\n   *  @dev function used to register an address as a token factory\\n   *  @param _factory the address of the token factory\\n   *  can be called only by Owner\\n   *  _factory cannot be registered yet\\n   *  once the factory has been registered it can deploy token identities\\n   */\\n  function addTokenFactory(address _factory) external;\\n\\n  /**\\n   *  @dev function used to unregister an address previously registered as a token factory\\n   *  @param _factory the address of the token factory\\n   *  can be called only by Owner\\n   *  _factory has to be registered previously\\n   *  once the factory has been unregistered it cannot deploy token identities anymore\\n   */\\n  function removeTokenFactory(address _factory) external;\\n\\n  /**\\n   *  @dev function used to add a receiver for a chainSelector\\n   *  @param _chainSelector the chainSelector for which the receiver is added\\n   *  @param _receiver the address of the receiver\\n   *  @param _gateway the address of the gateway\\n   *  can be called only by Owner\\n   *  _receiver cannot be registered yet\\n   *  once the receiver has been registered it can receive messages from the chainSelector\\n   */\\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external;\\n\\n  /**\\n   *  @dev function used to remove a receiver for a chainSelector\\n   *  @param _chainSelector the chainSelector for which the receiver is removed\\n   *  can be called only by Owner\\n   *  _receiver has to be registered previously\\n   *  once the receiver has been removed it cannot receive messages from the chainSelector anymore\\n   */\\n  function removeReceiver(uint64 _chainSelector) external;\\n\\n  /**\\n   *  @dev getter for OID contract corresponding to a wallet/token\\n   *  @param _wallet the wallet/token address\\n   */\\n  function getIdentity(address _wallet) external view returns (address);\\n\\n  /**\\n   *  @dev getter to fetch the array of wallets linked to an OID contract\\n   *  @param _identity the address of the OID contract\\n   *  returns an array of addresses linked to the OID\\n   */\\n  function getWallets(address _identity) external view returns (address[] memory);\\n\\n  /**\\n   *  @dev getter to fetch the token address linked to an OID contract\\n   *  @param _identity the address of the OID contract\\n   *  returns the address linked to the OID\\n   */\\n  function getToken(address _identity) external view returns (address);\\n\\n  /**\\n   *  @dev getter to know if an address is registered as token factory or not\\n   *  @param _factory the address of the factory\\n   *  returns true if the address corresponds to a registered factory\\n   */\\n  function isTokenFactory(address _factory) external view returns (bool);\\n\\n  /**\\n   *  @dev getter to know if a salt is taken for the create2 deployment\\n   *  @param _salt the salt used for deployment\\n   */\\n  function isSaltTaken(string calldata _salt) external view returns (bool);\\n\\n  /**\\n   * @dev getter for the implementation authority used by this factory.\\n   */\\n  function implementationAuthority() external view returns (address);\\n\\n  /**\\n   * @dev getter for the receiver of a chainSelector\\n   * @param _chainSelector the chainSelector for which the receiver is fetched\\n   */\\n  function getReceiver(uint64 _chainSelector) external view returns (address);\\n\\n  /**\\n   * @dev getter for the list of chainSelectors\\n   */\\n  function getChainSelectors() external view returns (uint64[] memory);\\n\\n  /**\\n   * @dev getter for the list of receivers\\n   */\\n  function getReceivers() external view returns (address[] memory);\\n\\n  /**\\n   * @dev getter for the bridge contract address\\n   */\\n  function bridge() external view returns (address);\\n\\n  /**\\n   * @dev getter for the created Identites\\n   */\\n  function identityIsCreated(address identity) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xd9d4887eb74df24e0ee2a0300d579b0b48ddab6f71316a3a21b3ab87b8a1a300\",\"license\":\"GPL-3.0\"},\"src/factory/IdFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport '../proxy/IdentityProxy.sol';\\nimport './IIdFactory.sol';\\nimport '../interface/IERC734.sol';\\nimport { CrossChainBridge } from '../bridge/Bridge.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\\n/// @notice REMOVE in prod\\nimport 'hardhat/console.sol';\\n\\ncontract IdFactory is IIdFactory, Ownable {\\n  mapping(address => bool) private _tokenFactories;\\n\\n  // address of the _implementationAuthority contract making the link to the implementation contract\\n  address private immutable _implementationAuthority;\\n\\n  // as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\\n  // salt is taken and which is not\\n  mapping(string => bool) private _saltTaken;\\n\\n  // ONCHAINID of the wallet owner\\n  mapping(address => address) private _userIdentity;\\n\\n  // wallets currently linked to an ONCHAINID\\n  mapping(address => address[]) private _wallets;\\n\\n  // ONCHAINID of the token\\n  mapping(address => address) private _tokenIdentity;\\n\\n  // token linked to an ONCHAINID\\n  mapping(address => address) private _tokenAddress;\\n\\n  // flag to check if the contract is on the home chain\\n  bool public _isHomeChain;\\n\\n  // DetinationChainSelectors and Receivers address (Receiver is the Bridge contract on the destination chain)\\n  mapping(uint64 => address) public destinationChainSelectorToReceiver;\\n  mapping(uint64 => address) public destinationChainSelectorToGateway;\\n  uint64[] private chainSelectors;\\n\\n  // CrossChainBridge address\\n  address public bridge;\\n\\n  // Map to store allowedContracts\\n  mapping(address => bool) public isAllowedContract;\\n\\n  // Map to store onlyManagers\\n  mapping(address => bool) public isManager;\\n\\n  // Map to store created identities\\n  mapping(address => bool) public isCreatedIdentity;\\n\\n  // Define the enum\\n  enum AccessAddressTypes {\\n    CONTRACT,\\n    MANAGER\\n  }\\n\\n  modifier onlyAllowedSender() {\\n    require(\\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\\n      'Permissions: Sender is not a allowed'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyAllowedContract() {\\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\\n    _;\\n  }\\n\\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\\n\\n  // setting\\n  constructor(address _owner, address implementationAuthority, bool isHomeChain) {\\n    require(implementationAuthority != address(0), 'invalid argument - zero address');\\n    require(_owner != address(0), 'invalid argument - zero address');\\n\\n    _implementationAuthority = implementationAuthority;\\n    _isHomeChain = isHomeChain;\\n    isManager[_owner] = true;\\n    _transferOwnership(_owner);\\n    emit AllowedAddress(_owner, uint64(AccessAddressTypes.MANAGER), true);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-addTokenFactory}.\\n   */\\n  function addTokenFactory(address _factory) external override onlyOwner {\\n    require(_factory != address(0), 'invalid argument - zero address');\\n    require(!isTokenFactory(_factory), 'already a factory');\\n    _tokenFactories[_factory] = true;\\n    emit TokenFactoryAdded(_factory);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-removeTokenFactory}.\\n   */\\n  function removeTokenFactory(address _factory) external override onlyOwner {\\n    require(_factory != address(0), 'invalid argument - zero address');\\n    require(isTokenFactory(_factory), 'not a factory');\\n    _tokenFactories[_factory] = false;\\n    emit TokenFactoryRemoved(_factory);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-createIdentity}.\\n   */\\n  function createIdentity(\\n    address _wallet,\\n    string memory _salt\\n  ) external override onlyAllowedSender returns (address identity) {\\n    require(_wallet != address(0), 'invalid argument - zero address');\\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\\n    require(!_saltTaken[_salt], 'salt already taken');\\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\\n    identity = _deployIdentity(_salt, _implementationAuthority, _wallet);\\n    _saltTaken[_salt] = true;\\n    _userIdentity[_wallet] = identity;\\n    _wallets[identity].push(_wallet);\\n    emit WalletLinked(_wallet, identity);\\n\\n    isCreatedIdentity[identity] = true;\\n    if (_isHomeChain == true) {\\n      bytes32[] memory _keys;\\n      _bridgeCreateIdentity(_wallet, _salt, _keys);\\n    }\\n    return identity;\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-createIdentityWithManagementKeys}.\\n   */\\n  function createIdentityWithManagementKeys(\\n    address _wallet,\\n    string memory _salt,\\n    bytes32[] memory _managementKeys\\n  ) external override onlyOwner returns (address) {\\n    require(_wallet != address(0), 'invalid argument - zero address');\\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\\n    string memory oidSalt = string.concat('OID', _salt);\\n    require(!_saltTaken[oidSalt], 'salt already taken');\\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\\n    require(_managementKeys.length > 0, 'invalid argument - empty list of keys');\\n\\n    address identity = _deployIdentity(oidSalt, _implementationAuthority, _wallet);\\n\\n    for (uint i = 0; i < _managementKeys.length; i++) {\\n      require(\\n        _managementKeys[i] != keccak256(abi.encode(_wallet)),\\n        'invalid argument - wallet is also listed in management keys'\\n      );\\n      IERC734(identity).addKey(_managementKeys[i], 1, 1);\\n    }\\n\\n    IERC734(identity).removeKey(keccak256(abi.encode(address(this))), 1);\\n\\n    _saltTaken[oidSalt] = true;\\n    _userIdentity[_wallet] = identity;\\n    _wallets[identity].push(_wallet);\\n    emit WalletLinked(_wallet, identity);\\n\\n    return identity;\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-createTokenIdentity}.\\n   */\\n  function createTokenIdentity(\\n    address _token,\\n    address _tokenOwner,\\n    string memory _salt\\n  ) external override returns (address) {\\n    require(isTokenFactory(msg.sender) || msg.sender == owner(), 'only Factory or owner can call');\\n    require(_token != address(0), 'invalid argument - zero address');\\n    require(_tokenOwner != address(0), 'invalid argument - zero address');\\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\\n    string memory tokenIdSalt = string.concat('Token', _salt);\\n    require(!_saltTaken[tokenIdSalt], 'salt already taken');\\n    require(_tokenIdentity[_token] == address(0), 'token already linked to an identity');\\n    address identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\\n    _saltTaken[tokenIdSalt] = true;\\n    _tokenIdentity[_token] = identity;\\n    _tokenAddress[identity] = _token;\\n    emit TokenLinked(_token, identity);\\n    return identity;\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-linkWallet}.\\n   */\\n  function linkWallet(address _newWallet) external override {\\n    require(_newWallet != address(0), 'invalid argument - zero address');\\n    require(_userIdentity[msg.sender] != address(0), 'wallet not linked to an identity contract');\\n    require(_userIdentity[_newWallet] == address(0), 'new wallet already linked');\\n    require(_tokenIdentity[_newWallet] == address(0), 'invalid argument - token address');\\n    address identity = _userIdentity[msg.sender];\\n    require(_wallets[identity].length < 101, 'max amount of wallets per ID exceeded');\\n    _userIdentity[_newWallet] = identity;\\n    _wallets[identity].push(_newWallet);\\n    emit WalletLinked(_newWallet, identity);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-unlinkWallet}.\\n   */\\n  function unlinkWallet(address _oldWallet) external override {\\n    require(_oldWallet != address(0), 'invalid argument - zero address');\\n    require(_oldWallet != msg.sender, 'cannot be called on sender address');\\n    require(_userIdentity[msg.sender] == _userIdentity[_oldWallet], 'only a linked wallet can unlink');\\n    address _identity = _userIdentity[_oldWallet];\\n    delete _userIdentity[_oldWallet];\\n    uint256 length = _wallets[_identity].length;\\n    for (uint256 i = 0; i < length; i++) {\\n      if (_wallets[_identity][i] == _oldWallet) {\\n        _wallets[_identity][i] = _wallets[_identity][length - 1];\\n        _wallets[_identity].pop();\\n        break;\\n      }\\n    }\\n    emit WalletUnlinked(_oldWallet, _identity);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-addReceiver}.\\n   */\\n\\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external override onlyOwner {\\n    require(_receiver != address(0), 'invalid argument - zero address');\\n    require(destinationChainSelectorToReceiver[_chainSelector] == address(0), 'receiver already added');\\n    require(destinationChainSelectorToGateway[_chainSelector] == address(0), 'gateway already added');\\n\\n    destinationChainSelectorToReceiver[_chainSelector] = _receiver;\\n    destinationChainSelectorToGateway[_chainSelector] = _gateway;\\n\\n    chainSelectors.push(_chainSelector);\\n    emit ReceiverAdded(_chainSelector, _receiver, _gateway);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-removeReceiver}.\\n   */\\n\\n  function removeReceiver(uint64 _chainSelector) external override onlyOwner {\\n    require(destinationChainSelectorToReceiver[_chainSelector] != address(0), 'receiver not added');\\n    delete destinationChainSelectorToReceiver[_chainSelector];\\n    delete destinationChainSelectorToGateway[_chainSelector];\\n\\n    uint256 length = chainSelectors.length;\\n    for (uint256 i = 0; i < length; i++) {\\n      if (chainSelectors[i] == _chainSelector) {\\n        chainSelectors[i] = chainSelectors[length - 1];\\n        chainSelectors.pop();\\n        break;\\n      }\\n    }\\n    emit ReceiverRemoved(_chainSelector);\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getChainSelectors}.\\n   */\\n\\n  function getChainSelectors() external view override returns (uint64[] memory) {\\n    return chainSelectors;\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getReceiver}.\\n   */\\n\\n  function getReceiver(uint64 _chainSelector) external view override returns (address) {\\n    return destinationChainSelectorToReceiver[_chainSelector];\\n  }\\n\\n  function getGateway(uint64 _chainSelector) external view returns (address) {\\n    return destinationChainSelectorToGateway[_chainSelector];\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getReceivers}.\\n   */\\n\\n  function getReceivers() external view override returns (address[] memory) {\\n    address[] memory receivers = new address[](chainSelectors.length);\\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\\n      receivers[i] = destinationChainSelectorToReceiver[chainSelectors[i]];\\n    }\\n    return receivers;\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getIdentity}.\\n   */\\n  function getIdentity(address _wallet) external view override returns (address) {\\n    if (_tokenIdentity[_wallet] != address(0)) {\\n      return _tokenIdentity[_wallet];\\n    } else {\\n      return _userIdentity[_wallet];\\n    }\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-isSaltTaken}.\\n   */\\n  function isSaltTaken(string calldata _salt) external view override returns (bool) {\\n    return _saltTaken[_salt];\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getWallets}.\\n   */\\n  function getWallets(address _identity) external view override returns (address[] memory) {\\n    return _wallets[_identity];\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-getToken}.\\n   */\\n  function getToken(address _identity) external view override returns (address) {\\n    return _tokenAddress[_identity];\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-isTokenFactory}.\\n   */\\n  function isTokenFactory(address _factory) public view override returns (bool) {\\n    return _tokenFactories[_factory];\\n  }\\n\\n  /**\\n   *  @dev See {IdFactory-implementationAuthority}.\\n   */\\n  function implementationAuthority() public view override returns (address) {\\n    return _implementationAuthority;\\n  }\\n\\n  /**\\n   *\\n   * @param _bridge the address of the bridge contract\\n   */\\n  function setBridge(address _bridge) external onlyOwner {\\n    require(_bridge != address(0), 'invalid argument - zero address');\\n    bridge = _bridge;\\n  }\\n\\n  /**\\n   *  @dev get bridge address\\n   */\\n  function getBridge() external view returns (address) {\\n    return bridge;\\n  }\\n\\n  // deploy function with create2 opcode call\\n  // returns the address of the contract created\\n  function _deploy(string memory salt, bytes memory bytecode) private returns (address) {\\n    bytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\\n    address addr;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      let encoded_data := add(0x20, bytecode) // load initialization code.\\n      let encoded_size := mload(bytecode) // load init code's length.\\n      addr := create2(0, encoded_data, encoded_size, saltBytes)\\n      if iszero(extcodesize(addr)) {\\n        revert(0, 0)\\n      }\\n    }\\n    emit Deployed(addr);\\n    return addr;\\n  }\\n\\n  // function used to deploy an identity using CREATE2\\n  function _deployIdentity(\\n    string memory _salt,\\n    address implementationAuthority,\\n    address _wallet\\n  ) private returns (address) {\\n    bytes memory _code = type(IdentityProxy).creationCode;\\n    bytes memory _constructData = abi.encode(implementationAuthority, _wallet, address(this));\\n    bytes memory bytecode = abi.encodePacked(_code, _constructData);\\n    return _deploy(_salt, bytecode);\\n  }\\n\\n  function _bridgeCreateIdentity(\\n    address _wallet,\\n    string memory oidSalt,\\n    bytes32[] memory managementKeys // uint256 signatureExpiry, // bytes calldata signature\\n  ) internal {\\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\\n      CrossChainBridge bridgeContract = CrossChainBridge(payable(bridge));\\n      bridgeContract.sendCreateIdentity(\\n        chainSelectors[i],\\n        destinationChainSelectorToReceiver[chainSelectors[i]],\\n        destinationChainSelectorToGateway[chainSelectors[i]],\\n        _wallet,\\n        oidSalt,\\n        managementKeys\\n        // signatureExpiry,\\n        // signature\\n      );\\n    }\\n  }\\n\\n  // Function to set allowed contracts\\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\\n    if (_status == true) {\\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\\n    }\\n    isAllowedContract[_contract] = _status;\\n\\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\\n  }\\n\\n  // Function to set manager status\\n  function setManager(address _manager, bool _status) external onlyManager {\\n    isManager[_manager] = _status;\\n\\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\\n  }\\n\\n  function identityIsCreated(address _identity) external view returns (bool) {\\n    return isCreatedIdentity[_identity];\\n  }\\n}\\n\",\"keccak256\":\"0x7842a479a5e93ff1cbef790929f31429bf092b77ef3a3eaf7be2bf3646ca552e\",\"license\":\"GPL-3.0\"},\"src/gateway/Gateway.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\nimport '../factory/IdFactory.sol';\\n// import '../bridge/Bridge.sol';\\n\\nusing ECDSA for bytes32;\\n\\n/// A required parameter was set to the Zero address.\\nerror ZeroAddress();\\n/// The maximum number of signers was reached at deployment.\\nerror TooManySigners();\\n/// The signed attempted to add was already approved.\\nerror SignerAlreadyApproved(address signer);\\n/// The signed attempted to remove was not approved.\\nerror SignerAlreadyNotApproved(address signer);\\n/// A requested ONCHAINID deployment was requested without a valid signature while the Gateway requires one.\\nerror UnsignedDeployment();\\n/// A requested ONCHAINID deployment was requested and signer by a non approved signer.\\nerror UnapprovedSigner(address signer);\\n/// A requested ONCHAINID deployment was requested with a signature revoked.\\nerror RevokedSignature(bytes signature);\\n/// A requested ONCHAINID deployment was requested with a signature that expired.\\nerror ExpiredSignature(bytes signature);\\n/// Attempted to revoke a signature that was already revoked.\\nerror SignatureAlreadyRevoked(bytes signature);\\n/// Attempted to approve a signature that was not revoked.\\nerror SignatureNotRevoked(bytes signature);\\n\\ncontract Gateway is Ownable {\\n  IdFactory public idFactory;\\n  mapping(address => bool) public approvedSigners;\\n  mapping(bytes => bool) public revokedSignatures;\\n\\n  event SignerApproved(address indexed signer);\\n  event SignerRevoked(address indexed signer);\\n  event SignatureRevoked(bytes indexed signature);\\n  event SignatureApproved(bytes indexed signature);\\n\\n  /**\\n   *  @dev Constructor for the ONCHAINID Factory Gateway.\\n   *  @param idFactoryAddress the address of the factory to operate (the Gateway must be owner of the Factory).\\n   */\\n  constructor(address idFactoryAddress, address[] memory signersToApprove) Ownable() {\\n    if (idFactoryAddress == address(0)) {\\n      revert ZeroAddress();\\n    }\\n    if (signersToApprove.length > 10) {\\n      revert TooManySigners();\\n    }\\n\\n    for (uint i = 0; i < signersToApprove.length; i++) {\\n      approvedSigners[signersToApprove[i]] = true;\\n    }\\n\\n    idFactory = IdFactory(idFactoryAddress);\\n  }\\n\\n  /**\\n   *  @dev Approve a signer to sign ONCHAINID deployments. If the Gateway is setup to require signature, only\\n   *  deployments requested with a valid signature from an approved signer will be accepted.\\n   *  If the gateway does not require a signature,\\n   *  @param signer the signer address to approve.\\n   */\\n  function approveSigner(address signer) external onlyOwner {\\n    if (signer == address(0)) {\\n      revert ZeroAddress();\\n    }\\n\\n    if (approvedSigners[signer]) {\\n      revert SignerAlreadyApproved(signer);\\n    }\\n\\n    approvedSigners[signer] = true;\\n\\n    emit SignerApproved(signer);\\n  }\\n\\n  /**\\n   *  @dev Revoke a signer to sign ONCHAINID deployments.\\n   *  @param signer the signer address to revoke.\\n   */\\n  function revokeSigner(address signer) external onlyOwner {\\n    if (signer == address(0)) {\\n      revert ZeroAddress();\\n    }\\n\\n    if (!approvedSigners[signer]) {\\n      revert SignerAlreadyNotApproved(signer);\\n    }\\n\\n    delete approvedSigners[signer];\\n\\n    emit SignerRevoked(signer);\\n  }\\n\\n  function deployIdentity(\\n    address identityOwner,\\n    string memory salt,\\n    bytes32[] calldata managementKeys\\n  ) public returns (address) {\\n    if (managementKeys.length == 0) {\\n      return deployIdentityWithSalt(identityOwner, salt);\\n    } else {\\n      return deployIdentityWithSaltAndManagementKeys(identityOwner, salt, managementKeys);\\n    }\\n  }\\n\\n  /**\\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt.\\n   *  @param identityOwner the address to set as a management key.\\n   *  @param salt to use for the deployment.\\n   */\\n  function deployIdentityWithSalt(address identityOwner, string memory salt) public returns (address) {\\n    if (identityOwner == address(0)) {\\n      revert ZeroAddress();\\n    }\\n\\n    if (!approvedSigners[msg.sender]) {\\n      revert UnapprovedSigner(msg.sender);\\n    }\\n\\n    return idFactory.createIdentity(identityOwner, salt);\\n  }\\n\\n  /**\\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt and a custom list of\\n   *  management keys. Note that the identity Owner address won't be added as a management keys, if this is desired,\\n   *  the key hash must be listed in the managementKeys array.\\n   *  @param identityOwner the address to set as a management key.\\n   *  @param salt to use for the deployment.\\n   *  @param managementKeys the list of management keys to add to the ONCHAINID.\\n   */\\n  function deployIdentityWithSaltAndManagementKeys(\\n    address identityOwner,\\n    string memory salt,\\n    bytes32[] calldata managementKeys\\n  ) public returns (address) {\\n    if (identityOwner == address(0)) {\\n      revert ZeroAddress();\\n    }\\n\\n    if (!approvedSigners[msg.sender]) {\\n      revert UnapprovedSigner(msg.sender);\\n    }\\n\\n    address identity = idFactory.createIdentityWithManagementKeys(identityOwner, salt, managementKeys);\\n\\n    // bool isHomeChain = idFactory._isHomeChain();\\n\\n    // if (isHomeChain) {\\n    //   address bridgeAddress = idFactory.getBridge();\\n    //   // Explicit conversion to payable address and then to CrossChainBridge\\n    //   CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\\n    //   // Get Destination Chain Selectors and their receivers\\n    //   address[] memory receivers = idFactory.getReceivers();\\n    //   uint64[] memory chainSelectors = idFactory.getChainSelectors();\\n    // Send the CreateIdentity message to the bridge\\n    //   for (uint i = 0; i < receivers.length; i++) {\\n    //     if (receivers[i] != address(bridge)) {\\n    //       bridge.sendCreateIdentity(\\n    //         chainSelectors[i],\\n    //         receivers[i],\\n    //         address(this),\\n    //         identityOwner,\\n    //         salt,\\n    //         managementKeys,\\n    //         signatureExpiry,\\n    //         signature\\n    //       );\\n    //     }\\n    //   }\\n    // }\\n\\n    return identity;\\n  }\\n\\n  /**\\n   *  @dev Deploy an ONCHAINID using a factory using the identityOwner address as salt.\\n   *  @param identityOwner the address to set as a management key.\\n   */\\n  function deployIdentityForWallet(address identityOwner) external returns (address) {\\n    if (identityOwner == address(0)) {\\n      revert ZeroAddress();\\n    }\\n\\n    return idFactory.createIdentity(identityOwner, Strings.toHexString(identityOwner));\\n  }\\n\\n  /**\\n   *  @dev Revoke a signature, if the signature is used to deploy an ONCHAINID, the deployment would be rejected.\\n   *  @param signature the signature to revoke.\\n   */\\n  function revokeSignature(bytes calldata signature) external onlyOwner {\\n    if (revokedSignatures[signature]) {\\n      revert SignatureAlreadyRevoked(signature);\\n    }\\n\\n    revokedSignatures[signature] = true;\\n\\n    emit SignatureRevoked(signature);\\n  }\\n\\n  /**\\n   *  @dev Remove a signature from the revoke list.\\n   *  @param signature the signature to approve.\\n   */\\n  function approveSignature(bytes calldata signature) external onlyOwner {\\n    if (!revokedSignatures[signature]) {\\n      revert SignatureNotRevoked(signature);\\n    }\\n\\n    delete revokedSignatures[signature];\\n\\n    emit SignatureApproved(signature);\\n  }\\n\\n  /**\\n   *  @dev Transfer the ownership of the factory to a new owner.\\n   *  @param newOwner the new owner of the factory.\\n   */\\n  function transferFactoryOwnership(address newOwner) external onlyOwner {\\n    idFactory.transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   *  @dev Call a function on the factory. Only the owner of the Gateway can call this method.\\n   *  @param data the data to call on the factory.\\n   */\\n  function callFactory(bytes memory data) external onlyOwner {\\n    (bool success, ) = address(idFactory).call(data);\\n    require(success, 'Gateway: call to factory failed');\\n  }\\n}\\n\",\"keccak256\":\"0x832a8f2d69c1a7f736f00e156983a3515de8495ff1146301fd6d667ebd4e0d3c\",\"license\":\"GPL-3.0\"},\"src/interface/IClaimIssuer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./IIdentity.sol\\\";\\n\\ninterface IClaimIssuer is IIdentity {\\n\\t/**\\n\\t * @dev Emitted when a claim is revoked.\\n\\t *\\n\\t * Specification: MUST be triggered when revoking a claim.\\n\\t */\\n\\tevent ClaimRevoked(bytes indexed signature);\\n\\n\\t/**\\n\\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\\n\\t * @notice will fetch the claim from the identity contract (unsafe).\\n\\t * @param _claimId the id of the claim\\n\\t * @param _identity the address of the identity contract\\n\\t * @return isRevoked true when the claim is revoked\\n\\t */\\n\\tfunction revokeClaim(bytes32 _claimId, address _identity) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\\n\\t * @param signature the signature of the claim\\n\\t */\\n\\tfunction revokeClaimBySignature(bytes calldata signature) external;\\n\\n\\t/**\\n\\t * @dev Returns revocation status of a claim.\\n\\t * @param _sig the signature of the claim\\n\\t * @return isRevoked true if the claim is revoked and false otherwise\\n\\t */\\n\\tfunction isClaimRevoked(bytes calldata _sig) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev Checks if a claim is valid.\\n\\t * @param _identity the identity contract related to the claim\\n\\t * @param claimTopic the claim topic of the claim\\n\\t * @param sig the signature of the claim\\n\\t * @param data the data field of the claim\\n\\t * @return claimValid true if the claim is valid, false otherwise\\n\\t */\\n\\tfunction isClaimValid(\\n\\t\\tIIdentity _identity,\\n\\t\\tuint256 claimTopic,\\n\\t\\tbytes calldata sig,\\n\\t\\tbytes calldata data\\n\\t) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2500d5d63e8509796c5fe4130628df40aff0b3a5c905893eb38782b080fdaa7\",\"license\":\"GPL-3.0\"},\"src/interface/IERC734.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\\n */\\ninterface IERC734 {\\n\\t/**\\n\\t * @dev Emitted when an execution request was approved.\\n\\t *\\n\\t * Specification: MUST be triggered when approve was successfully called.\\n\\t */\\n\\tevent Approved(uint256 indexed executionId, bool approved);\\n\\n\\t/**\\n\\t * @dev Emitted when an execute operation was approved and successfully performed.\\n\\t *\\n\\t * Specification: MUST be triggered when approve was called and the execution was successfully approved.\\n\\t */\\n\\tevent Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n\\t/**\\n\\t * @dev Emitted when an execution request was performed via `execute`.\\n\\t *\\n\\t * Specification: MUST be triggered when execute was successfully called.\\n\\t */\\n\\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n\\t/**\\n\\t * @dev Emitted when an execute operation was called and failed\\n\\t *\\n\\t * Specification: MUST be triggered when execute call failed\\n\\t */\\n\\tevent ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n\\t/**\\n\\t * @dev Emitted when a key was added to the Identity.\\n\\t *\\n\\t * Specification: MUST be triggered when addKey was successfully called.\\n\\t */\\n\\tevent KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n\\t/**\\n\\t * @dev Emitted when a key was removed from the Identity.\\n\\t *\\n\\t * Specification: MUST be triggered when removeKey was successfully called.\\n\\t */\\n\\tevent KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n\\t/**\\n\\t * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\\n\\t *\\n\\t * Triggers Event: `KeyAdded`\\n\\t *\\n\\t * Specification: MUST only be done by keys of purpose 1, or the identity\\n\\t * itself. If it's the identity itself, the approval process will determine its approval.\\n\\t */\\n\\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\\n\\n\\t/**\\n\\t * @dev Approves an execution.\\n\\t *\\n\\t * Triggers Event: `Approved`\\n\\t * Triggers on execution successful Event: `Executed`\\n\\t * Triggers on execution failure Event: `ExecutionFailed`\\n\\t */\\n\\tfunction approve(uint256 _id, bool _approve) external returns (bool success);\\n\\n\\t/**\\n\\t * @dev Removes _purpose for _key from the identity.\\n\\t *\\n\\t * Triggers Event: `KeyRemoved`\\n\\t *\\n\\t * Specification: MUST only be done by keys of purpose 1, or the identity itself.\\n\\t * If it's the identity itself, the approval process will determine its approval.\\n\\t */\\n\\tfunction removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\\n\\n\\t/**\\n\\t * @dev Passes an execution instruction to an ERC734 identity.\\n\\t * How the execution is handled is up to the identity implementation:\\n\\t * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\\n\\t * approve this execution.\\n\\t * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\\n\\t *\\n\\t * Triggers Event: ExecutionRequested\\n\\t * Triggers on direct execution Event: Executed\\n\\t */\\n\\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\\n\\n\\t/**\\n\\t * @dev Returns the full key data, if present in the identity.\\n\\t */\\n\\tfunction getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\\n\\n\\t/**\\n\\t * @dev Returns the list of purposes associated with a key.\\n\\t */\\n\\tfunction getKeyPurposes(bytes32 _key) external view returns (uint256[] memory _purposes);\\n\\n\\t/**\\n\\t * @dev Returns an array of public key bytes32 held by this identity.\\n\\t */\\n\\tfunction getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\\n\\n\\t/**\\n\\t * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\\n\\t */\\n\\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\\n}\\n\",\"keccak256\":\"0xf409f08bfdd6b283a6bcdaf2fc1780f43815d3ed9b25baaad16133cc64b072ae\",\"license\":\"GPL-3.0\"},\"src/interface/IERC735.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\\n */\\ninterface IERC735 {\\n\\t/**\\n\\t * @dev Emitted when a claim was added.\\n\\t *\\n\\t * Specification: MUST be triggered when a claim was successfully added.\\n\\t */\\n\\tevent ClaimAdded(\\n\\t\\tbytes32 indexed claimId,\\n\\t\\tuint256 indexed topic,\\n\\t\\tuint256 scheme,\\n\\t\\taddress indexed issuer,\\n\\t\\tbytes signature,\\n\\t\\tbytes data,\\n\\t\\tstring uri\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted when a claim was removed.\\n\\t *\\n\\t * Specification: MUST be triggered when removeClaim was successfully called.\\n\\t */\\n\\tevent ClaimRemoved(\\n\\t\\tbytes32 indexed claimId,\\n\\t\\tuint256 indexed topic,\\n\\t\\tuint256 scheme,\\n\\t\\taddress indexed issuer,\\n\\t\\tbytes signature,\\n\\t\\tbytes data,\\n\\t\\tstring uri\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted when a claim was changed.\\n\\t *\\n\\t * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\\n\\t */\\n\\tevent ClaimChanged(\\n\\t\\tbytes32 indexed claimId,\\n\\t\\tuint256 indexed topic,\\n\\t\\tuint256 scheme,\\n\\t\\taddress indexed issuer,\\n\\t\\tbytes signature,\\n\\t\\tbytes data,\\n\\t\\tstring uri\\n\\t);\\n\\n\\t/**\\n\\t * @dev Add or update a claim.\\n\\t *\\n\\t * Triggers Event: `ClaimAdded`, `ClaimChanged`\\n\\t *\\n\\t * Specification: Add or update a claim from an issuer.\\n\\t *\\n\\t * _signature is a signed message of the following structure:\\n\\t * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\\n\\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\\n\\t */\\n\\tfunction addClaim(\\n\\t\\tuint256 _topic,\\n\\t\\tuint256 _scheme,\\n\\t\\taddress issuer,\\n\\t\\tbytes calldata _signature,\\n\\t\\tbytes calldata _data,\\n\\t\\tstring calldata _uri\\n\\t) external returns (bytes32 claimRequestId);\\n\\n\\t/**\\n\\t * @dev Removes a claim.\\n\\t *\\n\\t * Triggers Event: `ClaimRemoved`\\n\\t *\\n\\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\\n\\t */\\n\\tfunction removeClaim(bytes32 _claimId) external returns (bool success);\\n\\n\\t/**\\n\\t * @dev Get a claim by its ID.\\n\\t *\\n\\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\\n\\t */\\n\\tfunction getClaim(\\n\\t\\tbytes32 _claimId\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 topic,\\n\\t\\t\\tuint256 scheme,\\n\\t\\t\\taddress issuer,\\n\\t\\t\\tbytes memory signature,\\n\\t\\t\\tbytes memory data,\\n\\t\\t\\tstring memory uri\\n\\t\\t);\\n\\n\\t/**\\n\\t * @dev Returns an array of claim IDs by topic.\\n\\t */\\n\\tfunction getClaimIdsByTopic(uint256 _topic) external view returns (bytes32[] memory claimIds);\\n}\\n\",\"keccak256\":\"0xbbe0f6eec226d7d425ad7765f6791a8b46a725526837fd404529077749e27282\",\"license\":\"GPL-3.0\"},\"src/interface/IIdentity.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC734.sol\\\";\\nimport \\\"./IERC735.sol\\\";\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface IIdentity is IERC734, IERC735 {\\n\\t/**\\n\\t * @dev Checks if a claim is valid.\\n\\t * @param _identity the identity contract related to the claim\\n\\t * @param claimTopic the claim topic of the claim\\n\\t * @param sig the signature of the claim\\n\\t * @param data the data field of the claim\\n\\t * @return claimValid true if the claim is valid, false otherwise\\n\\t */\\n\\tfunction isClaimValid(\\n\\t\\tIIdentity _identity,\\n\\t\\tuint256 claimTopic,\\n\\t\\tbytes calldata sig,\\n\\t\\tbytes calldata data\\n\\t) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xec87b3d3cb3a2e7cfd75fec5dd80521a286676536de59568f408580ffd8ed26e\",\"license\":\"GPL-3.0\"},\"src/interface/IImplementationAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\ninterface IImplementationAuthority {\\n\\t// event emitted when the implementation contract is updated\\n\\tevent UpdatedImplementation(address newAddress);\\n\\n\\t/**\\n\\t * @dev updates the address used as implementation by the proxies linked\\n\\t * to this ImplementationAuthority contract\\n\\t * @param _newImplementation the address of the new implementation contract\\n\\t * only Owner can call\\n\\t */\\n\\tfunction updateImplementation(address _newImplementation) external;\\n\\n\\t/**\\n\\t * @dev returns the address of the implementation\\n\\t */\\n\\tfunction getImplementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x949a5f9238b5e95797eeef34e34c05ad9546d41b17be5be54acb5859a3c99918\",\"license\":\"GPL-3.0\"},\"src/proxy/IdentityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\nimport '../interface/IImplementationAuthority.sol';\\n\\ncontract IdentityProxy {\\n  /**\\n   *  @dev constructor of the proxy Identity contract\\n   *  @param _implementationAuthority the implementation Authority contract address\\n   *  @param initialManagementKey the management key at deployment\\n   *  @param _idFactoryAddress the _idFactoryAddress at deployment\\n   *  the proxy is going to use the logic deployed on the implementation contract\\n   *  deployed at an address listed in the ImplementationAuthority contract\\n   */\\n  constructor(address _implementationAuthority, address initialManagementKey, address _idFactoryAddress) {\\n    require(_implementationAuthority != address(0), 'invalid argument - zero address');\\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      sstore(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc, _implementationAuthority)\\n    }\\n\\n    address logic = IImplementationAuthority(_implementationAuthority).getImplementation();\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = logic.delegatecall(\\n      abi.encodeWithSignature('initialize(address,address)', initialManagementKey, _idFactoryAddress)\\n    );\\n    require(success, 'Initialization failed.');\\n  }\\n\\n  /**\\n   *  @dev fallback proxy function used for any transaction call that is made using\\n   *  the Identity contract ABI and called on the proxy contract\\n   *  The proxy will update its local storage depending on the behaviour requested\\n   *  by the implementation contract given by the Implementation Authority\\n   */\\n  // solhint-disable-next-line no-complex-fallback\\n  fallback() external payable {\\n    address logic = IImplementationAuthority(implementationAuthority()).getImplementation();\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      calldatacopy(0x0, 0x0, calldatasize())\\n      let success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\\n      let retSz := returndatasize()\\n      returndatacopy(0, 0, retSz)\\n      switch success\\n      case 0 {\\n        revert(0, retSz)\\n      }\\n      default {\\n        return(0, retSz)\\n      }\\n    }\\n  }\\n\\n  function implementationAuthority() public view returns (address) {\\n    address implemAuth;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      implemAuth := sload(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc)\\n    }\\n    return implemAuth;\\n  }\\n}\\n\",\"keccak256\":\"0xc820d53d36131569fd96bc21683b324fc93ce3090af74166b3029113025e71bb\",\"license\":\"GPL-3.0\"},\"src/storage/Storage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\nimport \\\"./Structs.sol\\\";\\nimport {IdFactory} from \\\"../factory/IdFactory.sol\\\";\\n\\ncontract Storage is Structs {\\n\\t// factory address\\n\\tIdFactory public idFactory;\\n\\n\\t// nonce used by the execute/approve function\\n\\tuint256 internal _executionNonce;\\n\\n\\t// keys as defined by IERC734\\n\\tmapping(bytes32 => Key) internal _keys;\\n\\n\\t// keys for a given purpose\\n\\t// purpose 1 = MANAGEMENT\\n\\t// purpose 2 = ACTION\\n\\t// purpose 3 = CLAIM\\n\\tmapping(uint256 => bytes32[]) internal _keysByPurpose;\\n\\n\\t// execution data\\n\\tmapping(uint256 => Execution) internal _executions;\\n\\n\\t// claims held by the ONCHAINID\\n\\tmapping(bytes32 => Claim) internal _claims;\\n\\n\\t// array of claims for a given topic\\n\\tmapping(uint256 => bytes32[]) internal _claimsByTopic;\\n\\n\\t// status on initialization\\n\\tbool internal _initialized = false;\\n\\n\\t// status on potential interactions with the contract\\n\\tbool internal _canInteract = false;\\n\\n\\t/**\\n\\t * @dev This empty reserved space is put in place to allow future versions to add new\\n\\t * variables without shifting down storage in the inheritance chain.\\n\\t */\\n\\tuint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x5b67125bd86c0c8eabb3c4e5d7a759a824ea0cad34f59584d4c27e2d9cfaec13\",\"license\":\"GPL-3.0\"},\"src/storage/Structs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ncontract Structs {\\n\\t/**\\n\\t *  @dev Definition of the structure of a Key.\\n\\t *\\n\\t *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\\n\\t *  The structure should be as follows:\\n\\t *  key: A public key owned by this identity\\n\\t *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\\n\\t *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\\n\\t *  key: bytes32 The public key. // Its the Keccak256 hash of the key\\n\\t */\\n\\tstruct Key {\\n\\t\\tuint256[] purposes;\\n\\t\\tuint256 keyType;\\n\\t\\tbytes32 key;\\n\\t}\\n\\n\\t/**\\n\\t *  @dev Definition of the structure of an Execution\\n\\t *\\n\\t *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\\n\\t *  to: address of contract to interact with, can be address(this)\\n\\t *  value: ETH to transfer with the transaction\\n\\t *  data: payload of the transaction to execute\\n\\t *  approved: approval status of the Execution\\n\\t *  executed: execution status of the Execution (set as false when the Execution is created\\n\\t *  and updated to true when the Execution is processed)\\n\\t */\\n\\tstruct Execution {\\n\\t\\taddress to;\\n\\t\\tuint256 value;\\n\\t\\tbytes data;\\n\\t\\tbool approved;\\n\\t\\tbool executed;\\n\\t}\\n\\n\\t/**\\n\\t *  @dev Definition of the structure of a Claim.\\n\\t *\\n\\t *  Specification: Claims are information an issuer has about the identity holder.\\n\\t *  The structure should be as follows:\\n\\t *  claim: A claim published for the Identity.\\n\\t *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\\n\\t *  number schemes, sub topics based on number ranges??))\\n\\t *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\\n\\t *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\\n\\t *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\\n\\t *  (ToBeDefined)\\n\\t *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\\n\\t *  identity contract, it should hold the key with which the above message was signed, if the key is not present\\n\\t *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\\n\\t *  claim can be verified using the call data.\\n\\t *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\\n\\t *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\\n\\t *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\\n\\t *  the claim scheme.\\n\\t *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\\n\\t */\\n\\tstruct Claim {\\n\\t\\tuint256 topic;\\n\\t\\tuint256 scheme;\\n\\t\\taddress issuer;\\n\\t\\tbytes signature;\\n\\t\\tbytes data;\\n\\t\\tstring uri;\\n\\t}\\n}\\n\",\"keccak256\":\"0x5fa44654ac0a36e5b960b241e7391a44318545b72cd1fcb52d9aa88478f42f97\",\"license\":\"GPL-3.0\"},\"src/version/Version.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Version contract gives the versioning information of the implementation contract\\n */\\ncontract Version {\\n\\t/**\\n\\t * @dev Returns the string of the current version.\\n\\t */\\n\\tfunction version() external pure returns (string memory) {\\n\\t\\t// version 2.2.0\\n\\t\\treturn \\\"2.2.1\\\";\\n\\t}\\n}\\n\",\"keccak256\":\"0x7891cc7f1b412df1058aea2affa83be52e1c5d9e3b27fb74c52f95b0bfd38c03\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608034620002f457601f62003c0338819003918201601f1916830192916001600160401b039182851184861017620002f9578160609285926040978852833981010312620002f45762000052826200030f565b916020918282015191821592831503620002f457856200007391016200030f565b9261ffff199081600754168060075560018060a01b03809716948515620002b057156200029f57506007549160ff9283811615801562000295575b1562000251571661010117600755600080546001600160a01b031916868816178155875182810195865282815280890195909491939190818711868810176200023d57868a528551902080855260028085528a8620018190559460600190811186821017620001ea5788526001948581528484526002835288842090815487835580881062000213575b5090845282842086855b818110620001fe57505050505082825283808884200155838252600381528682209081549168010000000000000000831015620001ea57858301808255831015620001d65783528220018290558291907f480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e99080a45b1660018060a01b03196000541617600055516138de9081620003258239f35b634e487b7160e01b84526032600452602484fd5b634e487b7160e01b84526041600452602484fd5b85858551169401938184015501879062000142565b828652878086882092830192015b8281106200023157505062000138565b87815501889062000221565b634e487b7160e01b85526041600452602485fd5b885162461bcd60e51b815260048101849052601e60248201527f496e697469616c206b65792077617320616c72656164792073657475702e00006044820152606490fd5b50303b15620000ae565b60011760075550620001b792505050565b885162461bcd60e51b815260048101849052601f60248201527f696e76616c696420617267756d656e74202d207a65726f2061646472657373006044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b0382168203620002f45756fe60806040526004361015610013575b600080fd5b60003560e01c806312aaac70146101675780631d3812401461015e578063485cc955146101555780634eee424a1461014c57806353d413c51461014357806354fd4d501461013a578063747442d31461013157806378e751a61461012857806380e9e9e11461011f5780639010f72614610116578063b1a34e0d1461010d578063b61d27f614610104578063c0969a6e146100fb578063c3b129e3146100f2578063c9100bcb146100e9578063d202158d146100e05763fb307b34146100d857600080fd5b61000e610ece565b5061000e610eac565b5061000e610e22565b5061000e610d7f565b5061000e610d17565b5061000e610b52565b5061000e610aae565b5061000e61092c565b5061000e6108b5565b5061000e610852565b5061000e610807565b5061000e61077f565b5061000e61063e565b5061000e610543565b5061000e610356565b5061000e610208565b5061000e6101a4565b90815180825260208080930193019160005b828110610190575050505090565b835185529381019392810192600101610182565b503461000e57602060031936011261000e5760043560005260026020526101f960406000206001604060002001546101e460026040600020015492611158565b91604051938493606085526060850190610170565b91602084015260408301520390f35b503461000e57606060031936011261000e57610230600160ff60075460081c16151514610f0f565b30331480156102b0575b8015610274575b61024a906111c9565b61027061025e60443560243560043561148e565b60405190151581529081906020820190565b0390f35b5060408051336020820190815261024a926102a992906102a190829081015b03601f1981018352826109eb565b5190206133ca565b9050610241565b506001600160a01b03600460206102de6102d26000546001600160a01b031690565b6001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610338575b60009161030a575b5016331461023a565b61032b915060203d8111610331575b61032381836109eb565b8101906111a7565b38610301565b503d610319565b6103406111bc565b6102f9565b6001600160a01b0381160361000e57565b503461000e57604060031936011261000e5760043561037481610345565b6024359061038182610345565b6001600160a01b0390818116156104ff5761040e6001939284936103ae6103aa60075460ff1690565b1590565b80156104f6575b6103be90613822565b6103d0600160ff196007541617600755565b6103e461010061ff00196007541617600755565b166001600160a01b031673ffffffffffffffffffffffffffffffffffffffff196000541617600055565b604051610433816102936020820194859190916001600160a01b036020820193169052565b51902080600261044d826000526002602052604060002090565b015561047761045a610a0e565b60018152610472836000526002602052604060002090565b61386d565b6104968261048f836000526002602052604060002090565b0160019055565b600160005260036020526104cf817fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c6112fb565b6112fb565b7f480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e9600080a4005b50303b156103b5565b606460405162461bcd60e51b815260206004820152601f60248201527f696e76616c696420617267756d656e74202d207a65726f2061646472657373006044820152fd5b503461000e57602060031936011261000e5761056b600160ff60075460081c16151514610f0f565b30331480156105c5575b8015610593575b6105859061281d565b61027061025e600435612f3c565b50604080513360208201908152610585926105be92906105b69082908101610293565b519020613467565b905061057c565b506001600160a01b03600460206105e76102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610631575b600091610613575b50163314610575565b61062b915060203d81116103315761032381836109eb565b3861060a565b6106396111bc565b610602565b503461000e57604060031936011261000e57610666600160ff60075460081c16151514610f0f565b30331480156106bb575b8015610691575b610680906111c9565b61027061025e60243560043561224f565b50604080513360208201908152610680926106b492906102a19082908101610293565b9050610677565b506001600160a01b03600460206106dd6102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610727575b600091610709575b50163314610670565b610721915060203d81116103315761032381836109eb565b38610700565b61072f6111bc565b6106f8565b600091031261000e57565b919082519283825260005b84811061076b575050601f19601f8460006020809697860101520116010190565b60208183018101518483018201520161074a565b503461000e57600060031936011261000e576102706040516040810181811067ffffffffffffffff8211176107f0575b604052600581527f322e322e31000000000000000000000000000000000000000000000000000000602082015260405191829160208352602083019061073f565b6107f8610997565b6107af565b8015150361000e57565b503461000e57604060031936011261000e57602061084860243561082a816107fd565b610840600160ff60075460081c16151514610f0f565b600435611e6c565b6040519015158152f35b503461000e57600060031936011261000e5760206001600160a01b0360005416604051908152f35b6020908160408183019282815285518094520193019160005b8281106108a1575050505090565b835185529381019392810192600101610893565b503461000e5760208060031936011261000e5760043560005260068152604060002090604051908181845491828152019360005281600020916000905b8282106109155761027085610909818903826109eb565b6040519182918261087a565b8354865294850194600193840193909101906108f2565b503461000e5760208060031936011261000e5760043560005260038152604060002090604051908181845491828152019360005281600020916000905b8282106109805761027085610909818903826109eb565b835486529485019460019384019390910190610969565b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116109c257604052565b6109ca610997565b604052565b6060810190811067ffffffffffffffff8211176109c257604052565b90601f601f19910116810190811067ffffffffffffffff8211176109c257604052565b604051906020820182811067ffffffffffffffff8211176109c257604052565b601f19601f60209267ffffffffffffffff8111610a4c575b01160190565b610a54610997565b610a46565b929192610a6582610a2e565b91610a7360405193846109eb565b82948184528183011161000e578281602093846000960137010152565b9080601f8301121561000e57816020610aab93359101610a59565b90565b503461000e5760c060031936011261000e57604435610acc81610345565b67ffffffffffffffff60643581811161000e57610aed903690600401610a90565b9160843582811161000e57610b06903690600401610a90565b60a43592831161000e573660238401121561000e5761027093610b36610b42943690602481600401359101610a59565b9260243560043561273c565b6040519081529081906020820190565b50606060031936011261000e57600435610b6b81610345565b6024359060443567ffffffffffffffff811161000e57610270926001600160a01b0392610b9f610c79933690600401610a90565b90610bb6600160ff60075460081c16151514610f0f565b7f8afcfabcb00e47a53a8fc3e9f23ff47ee1926194bb1350dd007c50b412a6cee86001549582610c1d8894610bf5866000526004602052604060002090565b906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b856001610c34866000526004602052604060002090565b0155610c56856002610c50876000526004602052604060002090565b01611038565b610c69610c6460015461112b565b600155565b1694859360405191829182611147565b0390a4604080513360208083019182528252601f199392610c9f92906102a190826109eb565b15610cc0575050610caf816118b6565b506040519081529081906020820190565b3014159081610cdf575b5015610b4257610cd9816118b6565b50610b42565b604080513360208201908152610d119450929091610d099190839081015b039081018352826109eb565b5190206134f9565b38610cca565b503461000e57608060031936011261000e57600435610d3581610345565b67ffffffffffffffff60443581811161000e57610d56903690600401610a90565b9160643591821161000e57602092610d75610848933690600401610a90565b91602435906136c9565b503461000e57604060031936011261000e5760043567ffffffffffffffff811161000e57610dbf610db66020923690600401610a90565b6024359061379e565b6001600160a01b0360405191168152f35b9491936001600160a01b03610e1494610aab9896610e06948952602089015216604087015260c0606087015260c086019061073f565b90848203608086015261073f565b9160a081840391015261073f565b503461000e57602060031936011261000e5760048035600090815260056020819052604091829020805460018201546002830154909591946102709490936003810193610e8f936001600160a01b031692610ea192610e9b92810191610e96910196885196878092611b00565b03866109eb565b6133af565b936133af565b935196879687610dd0565b503461000e57604060031936011261000e576020610848602435600435613633565b503461000e57602060031936011261000e576004356000526002602052610270610efb6040600020611158565b604051918291602083526020830190610170565b15610f1657565b608460405162461bcd60e51b815260206004820152603360248201527f496e746572616374696e67207769746820746865206c69627261727920636f6e60448201527f747261637420697320666f7262696464656e2e000000000000000000000000006064820152fd5b90600182811c92168015610fb0575b6020831014610f9a57565b634e487b7160e01b600052602260045260246000fd5b91607f1691610f8f565b91610fd69183549060031b600019811b9283911b169119161790565b9055565b818110610fe5575050565b60008155600101610fda565b9190601f811161100057505050565b61102c926000526020600020906020601f840160051c8301931061102e575b601f0160051c0190610fda565b565b909150819061101f565b919091825167ffffffffffffffff8111611107575b6110618161105b8454610f80565b84610ff1565b602080601f831160011461109c575081929394600092611091575b50506000198260011b9260031b1c1916179055565b01519050388061107c565b90601f198316956110b285600052602060002090565b926000905b8882106110ef575050836001959697106110d6575b505050811b019055565b015160001960f88460031b161c191690553880806110cc565b806001859682949686015181550195019301906110b7565b61110f610997565b61104d565b50634e487b7160e01b600052601160045260246000fd5b600190600019811461113b570190565b611143611114565b0190565b906020610aab92818152019061073f565b9060405191828154918282526020928383019160005283600020936000905b82821061118d5750505061102c925003836109eb565b855484526001958601958895509381019390910190611177565b9081602091031261000e5751610aab81610345565b506040513d6000823e3d90fd5b156111d057565b608460405162461bcd60e51b815260206004820152603060248201527f5065726d697373696f6e733a2053656e64657220646f6573206e6f742068617660448201527f65206d616e6167656d656e74206b6579000000000000000000000000000000006064820152fd5b8054600182558060011061124c575050565b61102c91600052600160206000209182019101610fda565b9061126e8261123a565b906000526020908160002060005b6001811061128a5750505050565b8251828201559183019160010161127c565b50634e487b7160e01b600052603260045260246000fd5b60209181518110156112c8575b60051b010190565b6112d061129c565b6112c0565b80548210156112ee575b60005260206000200190600090565b6112f661129c565b6112df565b611322610fd6918054906801000000000000000082101561133b575b6001820181556112d5565b819391549060031b600019811b9283911b169119161790565b611343610997565b611317565b9081602091031261000e5751610aab816107fd565b60209067ffffffffffffffff8111611377575b60051b0190565b61137f610997565b611370565b602090818184031261000e5780519067ffffffffffffffff821161000e57019180601f8401121561000e5782516113ba8161135d565b936113c860405195866109eb565b818552838086019260051b82010192831161000e578301905b8282106113ef575050505090565b83809183516113fd81610345565b8152019101906113e1565b90602090818382031261000e57825167ffffffffffffffff9384821161000e57019281601f8501121561000e5783516114408161135d565b9461144e60405196876109eb565b818652848087019260051b82010193841161000e578401905b83821061147657505050505090565b8151838116810361000e578152908401908401611467565b9091928160026114a8826000526002602052604060002090565b015403611856576114cb6114c6836000526002602052604060002090565b611158565b9160005b835181101561156257846114e382866112b3565b51146114f7576114f29061112b565b6114cf565b60405162461bcd60e51b815260206004820152602160248201527f436f6e666c6963743a204b657920616c72656164792068617320707572706f7360448201527f65000000000000000000000000000000000000000000000000000000000000006064820152608490fd5b509150919261157f846104ca846000526002602052604060002090565b611597826104ca866000526003602052604060002090565b60408051946000928082867f480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e98780a46115da6102d285546001600160a01b031690565b90631645536f60e11b8852602060049881818b81875afa908115611849575b879161181c575b501561180f576001600160a01b03908551630fffbaf360e01b815281818c81885afa918215611802575b88926117e5575b50501692888686519463e061646b60e01b865281868481845afa9586156117d8575b82966117b4575b50875192838092637b6b91c760e01b82525afa9081156117a7575b8791611785575b50865b8451811015611776576116a361169582846112b3565b5167ffffffffffffffff1690565b6116bd6116b083886112b3565b516001600160a01b031690565b90873b156117725788517f9dd323a000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff909116818e019081526001600160a01b039092166020830152604082018b9052606082018590526080820186905261174792918a908290819060a0010381838c5af18015611765575b61174c575b5061112b565b61167f565b8061175961175f926109ae565b80610734565b38611741565b61176d6111bc565b61173c565b8980fd5b50600199505050505050505050565b6117a191503d8089833e61179981836109eb565b810190611408565b3861167c565b6117af6111bc565b611675565b6117d19196503d8084833e6117c981836109eb565b810190611384565b943861165a565b6117e06111bc565b611653565b6117fb9250803d106103315761032381836109eb565b3880611631565b61180a6111bc565b61162a565b5060019750505050505050565b61183c9150823d8411611842575b61183481836109eb565b810190611348565b38611600565b503d61182a565b6118516111bc565b6115f9565b919281600261186f826000526002602052604060002090565b015561189861187c610a0e565b858152611893846000526002602052604060002090565b611264565b8060016118af846000526002602052604060002090565b015561157f565b610aab906118d0600160ff60075460081c16151514610f0f565b611ba7565b156118dc57565b608460405162461bcd60e51b815260206004820152602760248201527f43616e6e6f7420617070726f76652061206e6f6e2d6578697374696e6720657860448201527f65637574696f6e000000000000000000000000000000000000000000000000006064820152fd5b1561194d57565b606460405162461bcd60e51b815260206004820152601860248201527f5265717565737420616c726561647920657865637574656400000000000000006044820152fd5b1561199857565b606460405162461bcd60e51b815260206004820152601f60248201527f53656e64657220646f6573206e6f74206861766520616374696f6e206b6579006044820152fd5b156119e357565b608460405162461bcd60e51b815260206004820152602360248201527f53656e64657220646f6573206e6f742068617665206d616e6167656d656e742060448201527f6b657900000000000000000000000000000000000000000000000000000000006064820152fd5b600092918154611a5c81610f80565b92600191808316908115611ab55750600114611a79575b50505050565b90919293945060005260209081600020906000915b858310611aa45750505050019038808080611a73565b805485840152918301918101611a8e565b60ff1916845250505081151590910201915038808080611a73565b3d15611afb573d90611ae182610a2e565b91611aef60405193846109eb565b82523d6000602084013e565b606090565b9060009291805491611b1183610f80565b918282526001938481169081600014611b725750600114611b325750505050565b90919394506000526020928360002092846000945b838610611b5e575050505001019038808080611a73565b805485870183015294019385908201611b47565b915050602094955060ff199193501683830152151560051b01019038808080611a73565b906020610aab928181520190611b00565b611bb460015482106118d5565b611be3611bde6103aa6003611bd3856000526004602052604060002090565b015460081c60ff1690565b611946565b611c07611bfa826000526004602052604060002090565b546001600160a01b031690565b6001600160a01b03919082163003611e3857604080513360208201908152611c4092611c3b92906102a19082908101610293565b6119dc565b807fb3932da477fe5d6c8ff2eafef050c0f3a1af18fc07121001482600f36f3715d860405180611c7581906001602083019252565b0390a2611c9f6003611c91836000526004602052604060002090565b01600160ff19825416179055565b600080611cb9611bfa846000526004602052604060002090565b611cf76001611cd2866000526004602052604060002090565b01546002611cea876000526004602052604060002090565b0160405192838092611a4d565b03925af1611d03611ad0565b5015611db557611d326003611d22836000526004602052604060002090565b0161010061ff0019825416179055565b611d49611bfa826000526004602052604060002090565b907f1f920dbda597d7bf95035464170fa58d0a4b57f13a1c315ace6793b9f63688b86001611d81836000526004602052604060002090565b0154936002611d9a846000526004602052604060002090565b0193611dad604051928392169582611b96565b0390a4600190565b611dcc611bfa826000526004602052604060002090565b907fe10c49d9f7c71da23262367013434763cfdb2332267641728d25cd712c5c6a686001611e04836000526004602052604060002090565b0154936002611e1d846000526004602052604060002090565b0193611e30604051928392169582611b96565b0390a4600090565b604080513360208201908152611e6792611e629290611e5a9082908101610293565b51902061359d565b611991565b611c40565b90600191611e7c835482106118d5565b611e9b611bde6103aa6003611bd3856000526004602052604060002090565b82611eb3611bfa836000526004602052604060002090565b6001600160a01b0393908416300361209157604080513360208201908152611ee792611c3b92906102a19082908101610293565b604051811515815283907fb3932da477fe5d6c8ff2eafef050c0f3a1af18fc07121001482600f36f3715d890602090a215150361206457611f376003611c91836000526004602052604060002090565b600080611f51611bfa846000526004602052604060002090565b611f6986611cd2866000526004602052604060002090565b03925af1611f75611ad0565b501561201457611f946003611d22836000526004602052604060002090565b611fab611bfa826000526004602052604060002090565b907f1f920dbda597d7bf95035464170fa58d0a4b57f13a1c315ace6793b9f63688b884611fe2836000526004602052604060002090565b0154936002611ffb846000526004602052604060002090565b019361200e604051928392169582611b96565b0390a490565b7fe10c49d9f7c71da23262367013434763cfdb2332267641728d25cd712c5c6a6861204f611bfa839594956000526004602052604060002090565b92611e04836000526004602052604060002090565b61208c925060039150612081906000526004602052604060002090565b0160ff198154169055565b600090565b6040805133602082019081526120b392611e629290611e5a9082908101610293565b611ee7565b156120bf57565b608460405162461bcd60e51b815260206004820152602160248201527f4e6f6e4578697374696e673a204b65792069736e27742072656769737465726560448201527f64000000000000000000000000000000000000000000000000000000000000006064820152fd5b90600019820191821161213857565b61102c611114565b81519167ffffffffffffffff83116121ce575b6801000000000000000083116121c1575b81548383558084106121a3575b50602080910191600052806000209060005b848110612191575050505050565b83518382015592810192600101612183565b6121bb90836000528460206000209182019101610fda565b38612171565b6121c9610997565b612164565b6121d6610997565b612153565b805490811561220557600019809201916121f583836112d5565b909182549160031b1b1916905555565b634e487b7160e01b600052603160045260246000fd5b6002600091805483825580612236575b508260018201550155565b8184526020842061224991810190610fda565b3861222b565b9161227283600261226a826000526002602052604060002090565b0154146120b8565b6122896114c6846000526002602052604060002090565b9260005b8361229882876112b3565b5114612321576122a79061112b565b92838551146122b6579261228d565b60405162461bcd60e51b815260206004820152602a60248201527f4e6f6e4578697374696e673a204b657920646f65736e2774206861766520737560448201527f636820707572706f7365000000000000000000000000000000000000000000006064820152608490fd5b939092919361234461233c6123368451612129565b846112b3565b5191836112b3565b526123628161235d856000526002602052604060002090565b612140565b61237e612379846000526002602052604060002090565b6121db565b600082815260036020526040812054905b846123ba6123b0836123ab886000526003602052604060002090565b6112d5565b90549060031b1c90565b1461272a576123c89061112b565b81811061238f576124156124006123b061241b945b6123fa6123f4896000526003602052604060002090565b91612129565b906112d5565b916123ab866000526003602052604060002090565b90610fba565b612432612379836000526003602052604060002090565b60019283916124588361244f846000526002602052604060002090565b01549151612129565b15612709575b60409081519085847f585a4aef50f8267a92b32412b331b20f7f8b96f2245b253b9cc50dcc621d3397600080a46124a06102d26000546001600160a01b031690565b94631645536f60e11b82526020600492818185818b5afa9081156126fc575b6000916126df575b506124d7575b5050505050505090565b6001600160a01b03908451630fffbaf360e01b8152818186818c5afa9182156126d2575b6000926126b5575b5050169083519663e061646b60e01b88526000888581845afa9788156126a8575b600098612688575b5060008491865192838092637b6b91c760e01b82525afa90811561267b575b600091612662575b506000875b612564575b50506124cd565b885181101561265d578361257e6102d26116b0848d6112b3565b03612593575b61258d9061112b565b87612558565b96506125a261169588836112b3565b6125af6116b0898b6112b3565b97843b1561000e5786517ff82f1a4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092168287019081526001600160a01b0390991660208a01523060408a015260608901889052608089018490528a9861258d92906000908290819060a0010381838a5af18015612650575b61263d575b509050612584565b8061175961264a926109ae565b38612635565b6126586111bc565b612630565b61255d565b612675913d8091833e61179981836109eb565b38612553565b6126836111bc565b61254b565b6126a060009186939a3d8091833e6117c981836109eb565b98915061252c565b6126b06111bc565b612524565b6126cb9250803d106103315761032381836109eb565b3880612503565b6126da6111bc565b6124fb565b6126f69150823d84116118425761183481836109eb565b386124c7565b6127046111bc565b6124bf565b612725612720836000526002602052604060002090565b61221b565b61245e565b6124156124006123b061241b946123dd565b90610aab959493929161275b600160ff60075460081c16151514610f0f565b30331480156127a4575b801561277a575b6127759061281d565b6129b4565b506040805133602082019081526127759261279d92906105b69082908101610293565b905061276c565b506001600160a01b03600460206127c66102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115612810575b6000916127f2575b50163314612765565b61280a915060203d81116103315761032381836109eb565b386127e9565b6128186111bc565b6127e1565b1561282457565b608460405162461bcd60e51b815260206004820152603260248201527f5065726d697373696f6e733a2053656e64657220646f6573206e6f742068617660448201527f6520636c61696d207369676e6572206b657900000000000000000000000000006064820152fd5b92610aab94926001600160a01b036128b993168552602085015260806040850152608084019061073f565b91606081840391015261073f565b156128ce57565b606460405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420636c61696d000000000000000000000000000000000000006044820152fd5b92612932610aab95936128b993865260806020870152608086019061073f565b90848203604086015261073f565b979461299794610aab9a98949367ffffffffffffffff6129a59994168b526001600160a01b03948580921660208d01521660408b015260608a015260808901521660a08701526101208060c088015286019061073f565b9084820360e086015261073f565b9161010081840391015261073f565b919492946001600160a01b039182821694308603612ddb575b604080516001600160a01b038516602080830191825282840189905299929392916129fb8160608101610293565b519020998a9588612a16886000526005602052604060002090565b55600199868b612a308a6000526005602052604060002090565b0155612a4c836003610c508b6000526005602052604060002090565b8982600499612a6a878c610c50846000526005602052604060002090565b612a84886005610c50846000526005602052604060002090565b83612aaf6102d26002612aa1856000526005602052604060002090565b01546001600160a01b031690565b14612d9e57612ae581612ad56002936104ca612b0e976000526006602052604060002090565b6000526005602052604060002090565b01906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b898d7f46149b18aa084502c3f12bc75e19eda8bda8d102b82cce8474677a6d0d5f43c5858a612b438a8a8d5194859485612912565b0390a45b6000978b88612b606102d28c546001600160a01b031690565b9d8e895192838092631645536f60e11b82525afa908115612d91575b8b91612d74575b50612b99575b5050505050505050505050505090565b88818e895192838092630fffbaf360e01b82525afa918215612d67575b8b92612d4a575b5050169585519b63e061646b60e01b8d52898d8a81845afa9c8d15612d3d575b8a9d612d1d575b50898991885192838092637b6b91c760e01b82525afa908115612d10575b8a91612cf6575b50898c5b612c18575b50612b89565b8d51811015612cf15788612c338f6116b0846102d2926112b3565b03612c48575b612c429061112b565b8c612c0d565b8d612c636116b083612c5d61169582886112b3565b936112b3565b908a3b15612ced578c8c8f92612c429594838f928f8f8f8f8f8f612cb595519c8d9b8c9a8b997ffc6a55a2000000000000000000000000000000000000000000000000000000008b5230928b01612940565b03925af18015612ce0575b612ccd575b509050612c39565b80611759612cda926109ae565b38612cc5565b612ce86111bc565b612cc0565b8c80fd5b612c12565b612d0a91503d808c833e61179981836109eb565b38612c09565b612d186111bc565b612c02565b89919d50612d358b913d8084833e6117c981836109eb565b9d9150612be4565b612d456111bc565b612bdd565b612d609250803d106103315761032381836109eb565b3880612bbd565b612d6f6111bc565b612bb6565b612d8b9150823d84116118425761183481836109eb565b38612b83565b612d996111bc565b612b7c565b90507f3bab293fc00db832d7619a9299914251b8747c036867ec056cbd506f60135b13858a612dd38a8a8d5194859485612912565b0390a4612b47565b6040517fc0969a6e000000000000000000000000000000000000000000000000000000008152612e349060208180612e198c8e8c306004860161288e565b03818b5afa908115612e57575b600091612e39575b506128c7565b6129cd565b612e51915060203d81116118425761183481836109eb565b38612e2e565b612e5f6111bc565b612e26565b92612e84610aab9593612e92938652608060208701526080860190611b00565b908482036040860152611b00565b916060818403910152611b00565b612eaa8154610f80565b9081612eb4575050565b81601f60009311600114612ec6575055565b81835260208320612ee291601f0160051c810190600101610fda565b8160208120915555565b6005600091828155826001820155826002820155612f0c60038201612ea0565b612f1860048201612ea0565b01612f238154610f80565b80612f2d57505050565b601f8111600114612ec6575055565b612f50816000526005602052604060002090565b54801561334457600081815260066020526040812054905b83612f846123b0836123ab876000526006602052604060002090565b1461333257612f929061112b565b818110612f6857612415612fbe6123b0612fd3945b6123fa6123f4886000526006602052604060002090565b916123ab856000526006602052604060002090565b612fea612379826000526006602052604060002090565b6001828161300381956000526005602052604060002090565b01549261301f6002612aa1846000526005602052604060002090565b906003613036846000526005602052604060002090565b0194600491847f3cf57863a89432c61c4a27073c6ee39e8a764bff5a05aebfbcdcdc80b2e6130a84613072836000526005602052604060002090565b016005613089846000526005602052604060002090565b01996130a860409b8c519384936001600160a01b03809c169985612e64565b0390a46130c76130c2846000526005602052604060002090565b612eec565b6130dc6102d26000546001600160a01b031690565b918551631645536f60e11b815260209081818581885afa908115613325575b600091613308575b50613112575050505050505090565b8651630fffbaf360e01b815281818581885afa9182156132fb575b6000926132de575b50501685519263e061646b60e01b84526000848481845afa9384156132d1575b6000946132b1575b5060008391885192838092637b6b91c760e01b82525afa9081156132a4575b60009161328b575b506000865b613194575b506124cd565b845181101561328657826131ae6102d26116b084896112b3565b036131c3575b6131bd9061112b565b86613189565b95506131d261169587836112b3565b956131e06116b082876112b3565b90833b1561000e5788517f9f9b264100000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9098168589019081526001600160a01b0390921660208301523060408301526060820187905289976131bd9260009082908190608001038183895af18015613279575b613266575b5090506131b4565b80611759613273926109ae565b3861325e565b6132816111bc565b613259565b61318e565b61329e913d8091833e61179981836109eb565b38613184565b6132ac6111bc565b61317c565b6132c96000918593963d8091833e6117c981836109eb565b94915061315d565b6132d96111bc565b613155565b6132f49250803d106103315761032381836109eb565b3880613135565b6133036111bc565b61312d565b61331f9150823d84116118425761183481836109eb565b38613103565b61332d6111bc565b6130fb565b612415612fbe6123b0612fd394612fa7565b60405162461bcd60e51b815260206004820152602b60248201527f4e6f6e4578697374696e673a205468657265206973206e6f20636c61696d207760448201527f69746820746869732049440000000000000000000000000000000000000000006064820152608490fd5b9061102c6133c39260405193848092611b00565b03836109eb565b600052600260205260406000206040516133e3816109cf565b6133ec82611158565b8152600260019283810154602084015201548060408301521561346057600090825b61341b575b505050600090565b805191825181101561345a57836134338282956112b3565b51148015613455575b61344f576134499061112b565b9161340e565b50505090565b61343c565b50613413565b5050600090565b60005260026020526040600020604051613480816109cf565b61348982611158565b8152600260019283810154602084015201548060408301521561346057600090825b6134b757505050600090565b805191825181101561345a576134ce8185946112b3565b518381149081156134ee575b5061344f576134e89061112b565b916134ab565b6003915014386134da565b60005260028060205260406000209060405190613515826109cf565b61351e83611158565b82528060019384810154602085015201548060408401521561341357600091835b61354d575b50505050600090565b8051928351811015613597576135648186956112b3565b518385821491821561358d575b5050613586576135809061112b565b9261353f565b5050505090565b1490508338613571565b50613544565b600052600280602052604060002090604051906135b9826109cf565b6135c283611158565b82528060019384810154602085015201548060408401521561341357600091835b6135f05750505050600090565b8051928351811015613597576136078186956112b3565b5183858214918215613629575b5050613586576136239061112b565b926135e3565b1490508338613614565b60005260026020526040600020906040519061364e826109cf565b61365783611158565b8252600260019384810154602085015201548060408401521561341357600091835b6136865750505050600090565b80519283518110156135975761369d8186956112b3565b51838582149182156136bf575b5050613586576136b99061112b565b92613679565b14905083386136aa565b91613790939261376c926137016040519586926001600160a01b0360208501951685526040840152606080840152608083019061073f565b0393613715601f19958681018352826109eb565b51902060405161376381613757602082019485603c917f19457468657265756d205369676e6564204d6573736167653a0a3332000000008252601c8201520190565b038681018352826109eb565b5190209061379e565b604080516001600160a01b0390921660208301908152926105b69183908101610cfd565b61379957600090565b600190565b90600091604181510361381d576000918160209460ff8660809501519160606040850151940151901a601b8110613805575b60405194855216868401526040830152606082015282805260015afa156137f8575b60005190565b6138006111bc565b6137f2565b601b01818111156137d057613818611114565b6137d0565b505090565b1561382957565b606460405162461bcd60e51b815260206004820152601e60248201527f496e697469616c206b65792077617320616c72656164792073657475702e00006044820152fd5b906138778261123a565b906000526020908160002060005b600181106138935750505050565b825160ff16828201559183019160010161388556fea2646970667358221220e56ccc8b06a0470c4916659ad5cd101dd156e7b280bca4aa62dd59eef759b57b64736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c806312aaac70146101675780631d3812401461015e578063485cc955146101555780634eee424a1461014c57806353d413c51461014357806354fd4d501461013a578063747442d31461013157806378e751a61461012857806380e9e9e11461011f5780639010f72614610116578063b1a34e0d1461010d578063b61d27f614610104578063c0969a6e146100fb578063c3b129e3146100f2578063c9100bcb146100e9578063d202158d146100e05763fb307b34146100d857600080fd5b61000e610ece565b5061000e610eac565b5061000e610e22565b5061000e610d7f565b5061000e610d17565b5061000e610b52565b5061000e610aae565b5061000e61092c565b5061000e6108b5565b5061000e610852565b5061000e610807565b5061000e61077f565b5061000e61063e565b5061000e610543565b5061000e610356565b5061000e610208565b5061000e6101a4565b90815180825260208080930193019160005b828110610190575050505090565b835185529381019392810192600101610182565b503461000e57602060031936011261000e5760043560005260026020526101f960406000206001604060002001546101e460026040600020015492611158565b91604051938493606085526060850190610170565b91602084015260408301520390f35b503461000e57606060031936011261000e57610230600160ff60075460081c16151514610f0f565b30331480156102b0575b8015610274575b61024a906111c9565b61027061025e60443560243560043561148e565b60405190151581529081906020820190565b0390f35b5060408051336020820190815261024a926102a992906102a190829081015b03601f1981018352826109eb565b5190206133ca565b9050610241565b506001600160a01b03600460206102de6102d26000546001600160a01b031690565b6001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610338575b60009161030a575b5016331461023a565b61032b915060203d8111610331575b61032381836109eb565b8101906111a7565b38610301565b503d610319565b6103406111bc565b6102f9565b6001600160a01b0381160361000e57565b503461000e57604060031936011261000e5760043561037481610345565b6024359061038182610345565b6001600160a01b0390818116156104ff5761040e6001939284936103ae6103aa60075460ff1690565b1590565b80156104f6575b6103be90613822565b6103d0600160ff196007541617600755565b6103e461010061ff00196007541617600755565b166001600160a01b031673ffffffffffffffffffffffffffffffffffffffff196000541617600055565b604051610433816102936020820194859190916001600160a01b036020820193169052565b51902080600261044d826000526002602052604060002090565b015561047761045a610a0e565b60018152610472836000526002602052604060002090565b61386d565b6104968261048f836000526002602052604060002090565b0160019055565b600160005260036020526104cf817fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c6112fb565b6112fb565b7f480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e9600080a4005b50303b156103b5565b606460405162461bcd60e51b815260206004820152601f60248201527f696e76616c696420617267756d656e74202d207a65726f2061646472657373006044820152fd5b503461000e57602060031936011261000e5761056b600160ff60075460081c16151514610f0f565b30331480156105c5575b8015610593575b6105859061281d565b61027061025e600435612f3c565b50604080513360208201908152610585926105be92906105b69082908101610293565b519020613467565b905061057c565b506001600160a01b03600460206105e76102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610631575b600091610613575b50163314610575565b61062b915060203d81116103315761032381836109eb565b3861060a565b6106396111bc565b610602565b503461000e57604060031936011261000e57610666600160ff60075460081c16151514610f0f565b30331480156106bb575b8015610691575b610680906111c9565b61027061025e60243560043561224f565b50604080513360208201908152610680926106b492906102a19082908101610293565b9050610677565b506001600160a01b03600460206106dd6102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115610727575b600091610709575b50163314610670565b610721915060203d81116103315761032381836109eb565b38610700565b61072f6111bc565b6106f8565b600091031261000e57565b919082519283825260005b84811061076b575050601f19601f8460006020809697860101520116010190565b60208183018101518483018201520161074a565b503461000e57600060031936011261000e576102706040516040810181811067ffffffffffffffff8211176107f0575b604052600581527f322e322e31000000000000000000000000000000000000000000000000000000602082015260405191829160208352602083019061073f565b6107f8610997565b6107af565b8015150361000e57565b503461000e57604060031936011261000e57602061084860243561082a816107fd565b610840600160ff60075460081c16151514610f0f565b600435611e6c565b6040519015158152f35b503461000e57600060031936011261000e5760206001600160a01b0360005416604051908152f35b6020908160408183019282815285518094520193019160005b8281106108a1575050505090565b835185529381019392810192600101610893565b503461000e5760208060031936011261000e5760043560005260068152604060002090604051908181845491828152019360005281600020916000905b8282106109155761027085610909818903826109eb565b6040519182918261087a565b8354865294850194600193840193909101906108f2565b503461000e5760208060031936011261000e5760043560005260038152604060002090604051908181845491828152019360005281600020916000905b8282106109805761027085610909818903826109eb565b835486529485019460019384019390910190610969565b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116109c257604052565b6109ca610997565b604052565b6060810190811067ffffffffffffffff8211176109c257604052565b90601f601f19910116810190811067ffffffffffffffff8211176109c257604052565b604051906020820182811067ffffffffffffffff8211176109c257604052565b601f19601f60209267ffffffffffffffff8111610a4c575b01160190565b610a54610997565b610a46565b929192610a6582610a2e565b91610a7360405193846109eb565b82948184528183011161000e578281602093846000960137010152565b9080601f8301121561000e57816020610aab93359101610a59565b90565b503461000e5760c060031936011261000e57604435610acc81610345565b67ffffffffffffffff60643581811161000e57610aed903690600401610a90565b9160843582811161000e57610b06903690600401610a90565b60a43592831161000e573660238401121561000e5761027093610b36610b42943690602481600401359101610a59565b9260243560043561273c565b6040519081529081906020820190565b50606060031936011261000e57600435610b6b81610345565b6024359060443567ffffffffffffffff811161000e57610270926001600160a01b0392610b9f610c79933690600401610a90565b90610bb6600160ff60075460081c16151514610f0f565b7f8afcfabcb00e47a53a8fc3e9f23ff47ee1926194bb1350dd007c50b412a6cee86001549582610c1d8894610bf5866000526004602052604060002090565b906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b856001610c34866000526004602052604060002090565b0155610c56856002610c50876000526004602052604060002090565b01611038565b610c69610c6460015461112b565b600155565b1694859360405191829182611147565b0390a4604080513360208083019182528252601f199392610c9f92906102a190826109eb565b15610cc0575050610caf816118b6565b506040519081529081906020820190565b3014159081610cdf575b5015610b4257610cd9816118b6565b50610b42565b604080513360208201908152610d119450929091610d099190839081015b039081018352826109eb565b5190206134f9565b38610cca565b503461000e57608060031936011261000e57600435610d3581610345565b67ffffffffffffffff60443581811161000e57610d56903690600401610a90565b9160643591821161000e57602092610d75610848933690600401610a90565b91602435906136c9565b503461000e57604060031936011261000e5760043567ffffffffffffffff811161000e57610dbf610db66020923690600401610a90565b6024359061379e565b6001600160a01b0360405191168152f35b9491936001600160a01b03610e1494610aab9896610e06948952602089015216604087015260c0606087015260c086019061073f565b90848203608086015261073f565b9160a081840391015261073f565b503461000e57602060031936011261000e5760048035600090815260056020819052604091829020805460018201546002830154909591946102709490936003810193610e8f936001600160a01b031692610ea192610e9b92810191610e96910196885196878092611b00565b03866109eb565b6133af565b936133af565b935196879687610dd0565b503461000e57604060031936011261000e576020610848602435600435613633565b503461000e57602060031936011261000e576004356000526002602052610270610efb6040600020611158565b604051918291602083526020830190610170565b15610f1657565b608460405162461bcd60e51b815260206004820152603360248201527f496e746572616374696e67207769746820746865206c69627261727920636f6e60448201527f747261637420697320666f7262696464656e2e000000000000000000000000006064820152fd5b90600182811c92168015610fb0575b6020831014610f9a57565b634e487b7160e01b600052602260045260246000fd5b91607f1691610f8f565b91610fd69183549060031b600019811b9283911b169119161790565b9055565b818110610fe5575050565b60008155600101610fda565b9190601f811161100057505050565b61102c926000526020600020906020601f840160051c8301931061102e575b601f0160051c0190610fda565b565b909150819061101f565b919091825167ffffffffffffffff8111611107575b6110618161105b8454610f80565b84610ff1565b602080601f831160011461109c575081929394600092611091575b50506000198260011b9260031b1c1916179055565b01519050388061107c565b90601f198316956110b285600052602060002090565b926000905b8882106110ef575050836001959697106110d6575b505050811b019055565b015160001960f88460031b161c191690553880806110cc565b806001859682949686015181550195019301906110b7565b61110f610997565b61104d565b50634e487b7160e01b600052601160045260246000fd5b600190600019811461113b570190565b611143611114565b0190565b906020610aab92818152019061073f565b9060405191828154918282526020928383019160005283600020936000905b82821061118d5750505061102c925003836109eb565b855484526001958601958895509381019390910190611177565b9081602091031261000e5751610aab81610345565b506040513d6000823e3d90fd5b156111d057565b608460405162461bcd60e51b815260206004820152603060248201527f5065726d697373696f6e733a2053656e64657220646f6573206e6f742068617660448201527f65206d616e6167656d656e74206b6579000000000000000000000000000000006064820152fd5b8054600182558060011061124c575050565b61102c91600052600160206000209182019101610fda565b9061126e8261123a565b906000526020908160002060005b6001811061128a5750505050565b8251828201559183019160010161127c565b50634e487b7160e01b600052603260045260246000fd5b60209181518110156112c8575b60051b010190565b6112d061129c565b6112c0565b80548210156112ee575b60005260206000200190600090565b6112f661129c565b6112df565b611322610fd6918054906801000000000000000082101561133b575b6001820181556112d5565b819391549060031b600019811b9283911b169119161790565b611343610997565b611317565b9081602091031261000e5751610aab816107fd565b60209067ffffffffffffffff8111611377575b60051b0190565b61137f610997565b611370565b602090818184031261000e5780519067ffffffffffffffff821161000e57019180601f8401121561000e5782516113ba8161135d565b936113c860405195866109eb565b818552838086019260051b82010192831161000e578301905b8282106113ef575050505090565b83809183516113fd81610345565b8152019101906113e1565b90602090818382031261000e57825167ffffffffffffffff9384821161000e57019281601f8501121561000e5783516114408161135d565b9461144e60405196876109eb565b818652848087019260051b82010193841161000e578401905b83821061147657505050505090565b8151838116810361000e578152908401908401611467565b9091928160026114a8826000526002602052604060002090565b015403611856576114cb6114c6836000526002602052604060002090565b611158565b9160005b835181101561156257846114e382866112b3565b51146114f7576114f29061112b565b6114cf565b60405162461bcd60e51b815260206004820152602160248201527f436f6e666c6963743a204b657920616c72656164792068617320707572706f7360448201527f65000000000000000000000000000000000000000000000000000000000000006064820152608490fd5b509150919261157f846104ca846000526002602052604060002090565b611597826104ca866000526003602052604060002090565b60408051946000928082867f480000bb1edad8ca1470381cc334b1917fbd51c6531f3a623ea8e0ec7e38a6e98780a46115da6102d285546001600160a01b031690565b90631645536f60e11b8852602060049881818b81875afa908115611849575b879161181c575b501561180f576001600160a01b03908551630fffbaf360e01b815281818c81885afa918215611802575b88926117e5575b50501692888686519463e061646b60e01b865281868481845afa9586156117d8575b82966117b4575b50875192838092637b6b91c760e01b82525afa9081156117a7575b8791611785575b50865b8451811015611776576116a361169582846112b3565b5167ffffffffffffffff1690565b6116bd6116b083886112b3565b516001600160a01b031690565b90873b156117725788517f9dd323a000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff909116818e019081526001600160a01b039092166020830152604082018b9052606082018590526080820186905261174792918a908290819060a0010381838c5af18015611765575b61174c575b5061112b565b61167f565b8061175961175f926109ae565b80610734565b38611741565b61176d6111bc565b61173c565b8980fd5b50600199505050505050505050565b6117a191503d8089833e61179981836109eb565b810190611408565b3861167c565b6117af6111bc565b611675565b6117d19196503d8084833e6117c981836109eb565b810190611384565b943861165a565b6117e06111bc565b611653565b6117fb9250803d106103315761032381836109eb565b3880611631565b61180a6111bc565b61162a565b5060019750505050505050565b61183c9150823d8411611842575b61183481836109eb565b810190611348565b38611600565b503d61182a565b6118516111bc565b6115f9565b919281600261186f826000526002602052604060002090565b015561189861187c610a0e565b858152611893846000526002602052604060002090565b611264565b8060016118af846000526002602052604060002090565b015561157f565b610aab906118d0600160ff60075460081c16151514610f0f565b611ba7565b156118dc57565b608460405162461bcd60e51b815260206004820152602760248201527f43616e6e6f7420617070726f76652061206e6f6e2d6578697374696e6720657860448201527f65637574696f6e000000000000000000000000000000000000000000000000006064820152fd5b1561194d57565b606460405162461bcd60e51b815260206004820152601860248201527f5265717565737420616c726561647920657865637574656400000000000000006044820152fd5b1561199857565b606460405162461bcd60e51b815260206004820152601f60248201527f53656e64657220646f6573206e6f74206861766520616374696f6e206b6579006044820152fd5b156119e357565b608460405162461bcd60e51b815260206004820152602360248201527f53656e64657220646f6573206e6f742068617665206d616e6167656d656e742060448201527f6b657900000000000000000000000000000000000000000000000000000000006064820152fd5b600092918154611a5c81610f80565b92600191808316908115611ab55750600114611a79575b50505050565b90919293945060005260209081600020906000915b858310611aa45750505050019038808080611a73565b805485840152918301918101611a8e565b60ff1916845250505081151590910201915038808080611a73565b3d15611afb573d90611ae182610a2e565b91611aef60405193846109eb565b82523d6000602084013e565b606090565b9060009291805491611b1183610f80565b918282526001938481169081600014611b725750600114611b325750505050565b90919394506000526020928360002092846000945b838610611b5e575050505001019038808080611a73565b805485870183015294019385908201611b47565b915050602094955060ff199193501683830152151560051b01019038808080611a73565b906020610aab928181520190611b00565b611bb460015482106118d5565b611be3611bde6103aa6003611bd3856000526004602052604060002090565b015460081c60ff1690565b611946565b611c07611bfa826000526004602052604060002090565b546001600160a01b031690565b6001600160a01b03919082163003611e3857604080513360208201908152611c4092611c3b92906102a19082908101610293565b6119dc565b807fb3932da477fe5d6c8ff2eafef050c0f3a1af18fc07121001482600f36f3715d860405180611c7581906001602083019252565b0390a2611c9f6003611c91836000526004602052604060002090565b01600160ff19825416179055565b600080611cb9611bfa846000526004602052604060002090565b611cf76001611cd2866000526004602052604060002090565b01546002611cea876000526004602052604060002090565b0160405192838092611a4d565b03925af1611d03611ad0565b5015611db557611d326003611d22836000526004602052604060002090565b0161010061ff0019825416179055565b611d49611bfa826000526004602052604060002090565b907f1f920dbda597d7bf95035464170fa58d0a4b57f13a1c315ace6793b9f63688b86001611d81836000526004602052604060002090565b0154936002611d9a846000526004602052604060002090565b0193611dad604051928392169582611b96565b0390a4600190565b611dcc611bfa826000526004602052604060002090565b907fe10c49d9f7c71da23262367013434763cfdb2332267641728d25cd712c5c6a686001611e04836000526004602052604060002090565b0154936002611e1d846000526004602052604060002090565b0193611e30604051928392169582611b96565b0390a4600090565b604080513360208201908152611e6792611e629290611e5a9082908101610293565b51902061359d565b611991565b611c40565b90600191611e7c835482106118d5565b611e9b611bde6103aa6003611bd3856000526004602052604060002090565b82611eb3611bfa836000526004602052604060002090565b6001600160a01b0393908416300361209157604080513360208201908152611ee792611c3b92906102a19082908101610293565b604051811515815283907fb3932da477fe5d6c8ff2eafef050c0f3a1af18fc07121001482600f36f3715d890602090a215150361206457611f376003611c91836000526004602052604060002090565b600080611f51611bfa846000526004602052604060002090565b611f6986611cd2866000526004602052604060002090565b03925af1611f75611ad0565b501561201457611f946003611d22836000526004602052604060002090565b611fab611bfa826000526004602052604060002090565b907f1f920dbda597d7bf95035464170fa58d0a4b57f13a1c315ace6793b9f63688b884611fe2836000526004602052604060002090565b0154936002611ffb846000526004602052604060002090565b019361200e604051928392169582611b96565b0390a490565b7fe10c49d9f7c71da23262367013434763cfdb2332267641728d25cd712c5c6a6861204f611bfa839594956000526004602052604060002090565b92611e04836000526004602052604060002090565b61208c925060039150612081906000526004602052604060002090565b0160ff198154169055565b600090565b6040805133602082019081526120b392611e629290611e5a9082908101610293565b611ee7565b156120bf57565b608460405162461bcd60e51b815260206004820152602160248201527f4e6f6e4578697374696e673a204b65792069736e27742072656769737465726560448201527f64000000000000000000000000000000000000000000000000000000000000006064820152fd5b90600019820191821161213857565b61102c611114565b81519167ffffffffffffffff83116121ce575b6801000000000000000083116121c1575b81548383558084106121a3575b50602080910191600052806000209060005b848110612191575050505050565b83518382015592810192600101612183565b6121bb90836000528460206000209182019101610fda565b38612171565b6121c9610997565b612164565b6121d6610997565b612153565b805490811561220557600019809201916121f583836112d5565b909182549160031b1b1916905555565b634e487b7160e01b600052603160045260246000fd5b6002600091805483825580612236575b508260018201550155565b8184526020842061224991810190610fda565b3861222b565b9161227283600261226a826000526002602052604060002090565b0154146120b8565b6122896114c6846000526002602052604060002090565b9260005b8361229882876112b3565b5114612321576122a79061112b565b92838551146122b6579261228d565b60405162461bcd60e51b815260206004820152602a60248201527f4e6f6e4578697374696e673a204b657920646f65736e2774206861766520737560448201527f636820707572706f7365000000000000000000000000000000000000000000006064820152608490fd5b939092919361234461233c6123368451612129565b846112b3565b5191836112b3565b526123628161235d856000526002602052604060002090565b612140565b61237e612379846000526002602052604060002090565b6121db565b600082815260036020526040812054905b846123ba6123b0836123ab886000526003602052604060002090565b6112d5565b90549060031b1c90565b1461272a576123c89061112b565b81811061238f576124156124006123b061241b945b6123fa6123f4896000526003602052604060002090565b91612129565b906112d5565b916123ab866000526003602052604060002090565b90610fba565b612432612379836000526003602052604060002090565b60019283916124588361244f846000526002602052604060002090565b01549151612129565b15612709575b60409081519085847f585a4aef50f8267a92b32412b331b20f7f8b96f2245b253b9cc50dcc621d3397600080a46124a06102d26000546001600160a01b031690565b94631645536f60e11b82526020600492818185818b5afa9081156126fc575b6000916126df575b506124d7575b5050505050505090565b6001600160a01b03908451630fffbaf360e01b8152818186818c5afa9182156126d2575b6000926126b5575b5050169083519663e061646b60e01b88526000888581845afa9788156126a8575b600098612688575b5060008491865192838092637b6b91c760e01b82525afa90811561267b575b600091612662575b506000875b612564575b50506124cd565b885181101561265d578361257e6102d26116b0848d6112b3565b03612593575b61258d9061112b565b87612558565b96506125a261169588836112b3565b6125af6116b0898b6112b3565b97843b1561000e5786517ff82f1a4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092168287019081526001600160a01b0390991660208a01523060408a015260608901889052608089018490528a9861258d92906000908290819060a0010381838a5af18015612650575b61263d575b509050612584565b8061175961264a926109ae565b38612635565b6126586111bc565b612630565b61255d565b612675913d8091833e61179981836109eb565b38612553565b6126836111bc565b61254b565b6126a060009186939a3d8091833e6117c981836109eb565b98915061252c565b6126b06111bc565b612524565b6126cb9250803d106103315761032381836109eb565b3880612503565b6126da6111bc565b6124fb565b6126f69150823d84116118425761183481836109eb565b386124c7565b6127046111bc565b6124bf565b612725612720836000526002602052604060002090565b61221b565b61245e565b6124156124006123b061241b946123dd565b90610aab959493929161275b600160ff60075460081c16151514610f0f565b30331480156127a4575b801561277a575b6127759061281d565b6129b4565b506040805133602082019081526127759261279d92906105b69082908101610293565b905061276c565b506001600160a01b03600460206127c66102d26000546001600160a01b031690565b60405192838092630fffbaf360e01b82525afa908115612810575b6000916127f2575b50163314612765565b61280a915060203d81116103315761032381836109eb565b386127e9565b6128186111bc565b6127e1565b1561282457565b608460405162461bcd60e51b815260206004820152603260248201527f5065726d697373696f6e733a2053656e64657220646f6573206e6f742068617660448201527f6520636c61696d207369676e6572206b657900000000000000000000000000006064820152fd5b92610aab94926001600160a01b036128b993168552602085015260806040850152608084019061073f565b91606081840391015261073f565b156128ce57565b606460405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420636c61696d000000000000000000000000000000000000006044820152fd5b92612932610aab95936128b993865260806020870152608086019061073f565b90848203604086015261073f565b979461299794610aab9a98949367ffffffffffffffff6129a59994168b526001600160a01b03948580921660208d01521660408b015260608a015260808901521660a08701526101208060c088015286019061073f565b9084820360e086015261073f565b9161010081840391015261073f565b919492946001600160a01b039182821694308603612ddb575b604080516001600160a01b038516602080830191825282840189905299929392916129fb8160608101610293565b519020998a9588612a16886000526005602052604060002090565b55600199868b612a308a6000526005602052604060002090565b0155612a4c836003610c508b6000526005602052604060002090565b8982600499612a6a878c610c50846000526005602052604060002090565b612a84886005610c50846000526005602052604060002090565b83612aaf6102d26002612aa1856000526005602052604060002090565b01546001600160a01b031690565b14612d9e57612ae581612ad56002936104ca612b0e976000526006602052604060002090565b6000526005602052604060002090565b01906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b898d7f46149b18aa084502c3f12bc75e19eda8bda8d102b82cce8474677a6d0d5f43c5858a612b438a8a8d5194859485612912565b0390a45b6000978b88612b606102d28c546001600160a01b031690565b9d8e895192838092631645536f60e11b82525afa908115612d91575b8b91612d74575b50612b99575b5050505050505050505050505090565b88818e895192838092630fffbaf360e01b82525afa918215612d67575b8b92612d4a575b5050169585519b63e061646b60e01b8d52898d8a81845afa9c8d15612d3d575b8a9d612d1d575b50898991885192838092637b6b91c760e01b82525afa908115612d10575b8a91612cf6575b50898c5b612c18575b50612b89565b8d51811015612cf15788612c338f6116b0846102d2926112b3565b03612c48575b612c429061112b565b8c612c0d565b8d612c636116b083612c5d61169582886112b3565b936112b3565b908a3b15612ced578c8c8f92612c429594838f928f8f8f8f8f8f612cb595519c8d9b8c9a8b997ffc6a55a2000000000000000000000000000000000000000000000000000000008b5230928b01612940565b03925af18015612ce0575b612ccd575b509050612c39565b80611759612cda926109ae565b38612cc5565b612ce86111bc565b612cc0565b8c80fd5b612c12565b612d0a91503d808c833e61179981836109eb565b38612c09565b612d186111bc565b612c02565b89919d50612d358b913d8084833e6117c981836109eb565b9d9150612be4565b612d456111bc565b612bdd565b612d609250803d106103315761032381836109eb565b3880612bbd565b612d6f6111bc565b612bb6565b612d8b9150823d84116118425761183481836109eb565b38612b83565b612d996111bc565b612b7c565b90507f3bab293fc00db832d7619a9299914251b8747c036867ec056cbd506f60135b13858a612dd38a8a8d5194859485612912565b0390a4612b47565b6040517fc0969a6e000000000000000000000000000000000000000000000000000000008152612e349060208180612e198c8e8c306004860161288e565b03818b5afa908115612e57575b600091612e39575b506128c7565b6129cd565b612e51915060203d81116118425761183481836109eb565b38612e2e565b612e5f6111bc565b612e26565b92612e84610aab9593612e92938652608060208701526080860190611b00565b908482036040860152611b00565b916060818403910152611b00565b612eaa8154610f80565b9081612eb4575050565b81601f60009311600114612ec6575055565b81835260208320612ee291601f0160051c810190600101610fda565b8160208120915555565b6005600091828155826001820155826002820155612f0c60038201612ea0565b612f1860048201612ea0565b01612f238154610f80565b80612f2d57505050565b601f8111600114612ec6575055565b612f50816000526005602052604060002090565b54801561334457600081815260066020526040812054905b83612f846123b0836123ab876000526006602052604060002090565b1461333257612f929061112b565b818110612f6857612415612fbe6123b0612fd3945b6123fa6123f4886000526006602052604060002090565b916123ab856000526006602052604060002090565b612fea612379826000526006602052604060002090565b6001828161300381956000526005602052604060002090565b01549261301f6002612aa1846000526005602052604060002090565b906003613036846000526005602052604060002090565b0194600491847f3cf57863a89432c61c4a27073c6ee39e8a764bff5a05aebfbcdcdc80b2e6130a84613072836000526005602052604060002090565b016005613089846000526005602052604060002090565b01996130a860409b8c519384936001600160a01b03809c169985612e64565b0390a46130c76130c2846000526005602052604060002090565b612eec565b6130dc6102d26000546001600160a01b031690565b918551631645536f60e11b815260209081818581885afa908115613325575b600091613308575b50613112575050505050505090565b8651630fffbaf360e01b815281818581885afa9182156132fb575b6000926132de575b50501685519263e061646b60e01b84526000848481845afa9384156132d1575b6000946132b1575b5060008391885192838092637b6b91c760e01b82525afa9081156132a4575b60009161328b575b506000865b613194575b506124cd565b845181101561328657826131ae6102d26116b084896112b3565b036131c3575b6131bd9061112b565b86613189565b95506131d261169587836112b3565b956131e06116b082876112b3565b90833b1561000e5788517f9f9b264100000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9098168589019081526001600160a01b0390921660208301523060408301526060820187905289976131bd9260009082908190608001038183895af18015613279575b613266575b5090506131b4565b80611759613273926109ae565b3861325e565b6132816111bc565b613259565b61318e565b61329e913d8091833e61179981836109eb565b38613184565b6132ac6111bc565b61317c565b6132c96000918593963d8091833e6117c981836109eb565b94915061315d565b6132d96111bc565b613155565b6132f49250803d106103315761032381836109eb565b3880613135565b6133036111bc565b61312d565b61331f9150823d84116118425761183481836109eb565b38613103565b61332d6111bc565b6130fb565b612415612fbe6123b0612fd394612fa7565b60405162461bcd60e51b815260206004820152602b60248201527f4e6f6e4578697374696e673a205468657265206973206e6f20636c61696d207760448201527f69746820746869732049440000000000000000000000000000000000000000006064820152608490fd5b9061102c6133c39260405193848092611b00565b03836109eb565b600052600260205260406000206040516133e3816109cf565b6133ec82611158565b8152600260019283810154602084015201548060408301521561346057600090825b61341b575b505050600090565b805191825181101561345a57836134338282956112b3565b51148015613455575b61344f576134499061112b565b9161340e565b50505090565b61343c565b50613413565b5050600090565b60005260026020526040600020604051613480816109cf565b61348982611158565b8152600260019283810154602084015201548060408301521561346057600090825b6134b757505050600090565b805191825181101561345a576134ce8185946112b3565b518381149081156134ee575b5061344f576134e89061112b565b916134ab565b6003915014386134da565b60005260028060205260406000209060405190613515826109cf565b61351e83611158565b82528060019384810154602085015201548060408401521561341357600091835b61354d575b50505050600090565b8051928351811015613597576135648186956112b3565b518385821491821561358d575b5050613586576135809061112b565b9261353f565b5050505090565b1490508338613571565b50613544565b600052600280602052604060002090604051906135b9826109cf565b6135c283611158565b82528060019384810154602085015201548060408401521561341357600091835b6135f05750505050600090565b8051928351811015613597576136078186956112b3565b5183858214918215613629575b5050613586576136239061112b565b926135e3565b1490508338613614565b60005260026020526040600020906040519061364e826109cf565b61365783611158565b8252600260019384810154602085015201548060408401521561341357600091835b6136865750505050600090565b80519283518110156135975761369d8186956112b3565b51838582149182156136bf575b5050613586576136b99061112b565b92613679565b14905083386136aa565b91613790939261376c926137016040519586926001600160a01b0360208501951685526040840152606080840152608083019061073f565b0393613715601f19958681018352826109eb565b51902060405161376381613757602082019485603c917f19457468657265756d205369676e6564204d6573736167653a0a3332000000008252601c8201520190565b038681018352826109eb565b5190209061379e565b604080516001600160a01b0390921660208301908152926105b69183908101610cfd565b61379957600090565b600190565b90600091604181510361381d576000918160209460ff8660809501519160606040850151940151901a601b8110613805575b60405194855216868401526040830152606082015282805260015afa156137f8575b60005190565b6138006111bc565b6137f2565b601b01818111156137d057613818611114565b6137d0565b505090565b1561382957565b606460405162461bcd60e51b815260206004820152601e60248201527f496e697469616c206b65792077617320616c72656164792073657475702e00006044820152fd5b906138778261123a565b906000526020908160002060005b600181106138935750505050565b825160ff16828201559183019160010161388556fea2646970667358221220e56ccc8b06a0470c4916659ad5cd101dd156e7b280bca4aa62dd59eef759b57b64736f6c63430008110033",
  "devdoc": {
    "details": "Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces into a common Identity Contract. This implementation has a separate contract were it declares all storage, allowing for it to be used as an upgradable logic contract.",
    "kind": "dev",
    "methods": {
      "addClaim(uint256,uint256,address,bytes,bytes,string)": {
        "details": "See {IERC735-addClaim}.",
        "params": {
          "_data": "The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.",
          "_issuer": "The issuers identity contract address, or the address used to sign the above signature.",
          "_scheme": "The scheme with which this claim SHOULD be verified or how it should be processed.",
          "_signature": "Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))",
          "_topic": "The type of claim",
          "_uri": "The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such."
        },
        "returns": {
          "claimRequestId": "Returns claimRequestId: COULD be send to the approve function, to approve or reject this claim. triggers ClaimAdded event."
        }
      },
      "addKey(bytes32,uint256,uint256)": {
        "params": {
          "_key": "keccak256 representation of an ethereum address",
          "_purpose": "a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION",
          "_type": "type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc."
        },
        "returns": {
          "success": "Returns TRUE if the addition was successful and FALSE if not"
        }
      },
      "approve(uint256,bool)": {
        "details": "See {IERC734-approve}."
      },
      "constructor": {
        "params": {
          "_isLibrary": "boolean value stating if the contract is library or not calls __Identity_init if contract is not library",
          "initialManagementKey": "the address of the management key at deployment"
        }
      },
      "execute(address,uint256,bytes)": {
        "details": "See {IERC734-execute}.",
        "returns": {
          "executionId": "to use in the approve function, to approve or reject this execution."
        }
      },
      "getClaim(bytes32)": {
        "details": "See {IERC735-getClaim}.",
        "params": {
          "_claimId": "The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))"
        },
        "returns": {
          "data": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .",
          "issuer": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .",
          "scheme": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .",
          "signature": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .",
          "topic": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) .",
          "uri": "Returns all the parameters of the claim for the specified _claimId (topic, scheme, signature, issuer, data, uri) ."
        }
      },
      "getClaimIdsByTopic(uint256)": {
        "details": "See {IERC735-getClaimIdsByTopic}.",
        "params": {
          "_topic": "The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))"
        },
        "returns": {
          "claimIds": "Returns an array of claim IDs by topic."
        }
      },
      "getKey(bytes32)": {
        "details": "See {IERC734-getKey}.",
        "params": {
          "_key": "The public key.  for non-hex and long keys, its the Keccak256 hash of the key"
        },
        "returns": {
          "key": "Returns the full key data, if present in the identity.",
          "keyType": "Returns the full key data, if present in the identity.",
          "purposes": "Returns the full key data, if present in the identity."
        }
      },
      "getKeyPurposes(bytes32)": {
        "details": "See {IERC734-getKeyPurposes}.",
        "params": {
          "_key": "The public key.  for non-hex and long keys, its the Keccak256 hash of the key"
        },
        "returns": {
          "_purposes": "Returns the purposes of the specified key"
        }
      },
      "getKeysByPurpose(uint256)": {
        "details": "See {IERC734-getKeysByPurpose}.",
        "params": {
          "_purpose": "a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION"
        },
        "returns": {
          "keys": "Returns an array of public key bytes32 hold by this identity and having the specified purpose"
        }
      },
      "getRecoveredAddress(bytes,bytes32)": {
        "details": "returns the address that signed the given data",
        "params": {
          "dataHash": "the data that was signed returns the address that signed dataHash and created the signature sig",
          "sig": "the signature of the data"
        }
      },
      "initialize(address,address)": {
        "params": {
          "initialManagementKey": "The ethereum address to be set as the management key of the ONCHAINID."
        }
      },
      "isClaimValid(address,uint256,bytes,bytes)": {
        "details": "Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a built-in revocation mechanism and are considered valid as long as their signature is valid and they are still stored by the identity contract.",
        "params": {
          "_identity": "the identity contract related to the claim",
          "claimTopic": "the claim topic of the claim",
          "data": "the data field of the claim",
          "sig": "the signature of the claim"
        },
        "returns": {
          "claimValid": "true if the claim is valid, false otherwise"
        }
      },
      "keyHasPurpose(bytes32,uint256)": {
        "details": "See {IERC734-keyHasPurpose}."
      },
      "removeClaim(bytes32)": {
        "details": "See {IERC735-removeClaim}.",
        "params": {
          "_claimId": "The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))"
        },
        "returns": {
          "success": "Returns TRUE when the claim was removed. triggers ClaimRemoved event"
        }
      },
      "removeKey(bytes32,uint256)": {
        "details": "See {IERC734-removeKey}."
      },
      "version()": {
        "details": "Returns the string of the current version."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addClaim(uint256,uint256,address,bytes,bytes,string)": {
        "notice": "Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key."
      },
      "addKey(bytes32,uint256,uint256)": {
        "notice": "implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval."
      },
      "approve(uint256,bool)": {
        "notice": "Approves an execution.  If the sender is an ACTION key and the destination address is not the identity contract itself, then the  approval is authorized and the operation would be performed.  If the destination address is the identity itself, then the execution would be authorized and performed only  if the sender is a MANAGEMENT key."
      },
      "constructor": {
        "notice": "constructor of the Identity contract"
      },
      "execute(address,uint256,bytes)": {
        "notice": "Passes an execution instruction to the keymanager. If the sender is an ACTION key and the destination address is not the identity contract itself, then the execution is immediately approved and performed. If the destination address is the identity itself, then the execution would be performed immediately only if the sender is a MANAGEMENT key. Otherwise the execution request must be approved via the `approve` method."
      },
      "getClaim(bytes32)": {
        "notice": "Implementation of the getClaim function from the ERC-735 standard."
      },
      "getClaimIdsByTopic(uint256)": {
        "notice": "Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic"
      },
      "getKey(bytes32)": {
        "notice": "Implementation of the getKey function from the ERC-734 standard"
      },
      "getKeyPurposes(bytes32)": {
        "notice": "gets the purposes of a key"
      },
      "getKeysByPurpose(uint256)": {
        "notice": "gets all the keys with a specific purpose from an identity"
      },
      "initialize(address,address)": {
        "notice": "When using this contract as an implementation for a proxy, call this initializer with a delegatecall."
      },
      "keyHasPurpose(bytes32,uint256)": {
        "notice": "Returns true if the key has MANAGEMENT purpose or the specified purpose."
      },
      "removeClaim(bytes32)": {
        "notice": "Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself."
      },
      "removeKey(bytes32,uint256)": {
        "notice": "Remove the purpose from a key."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15851,
        "contract": "src/Identity.sol:Identity",
        "label": "idFactory",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IdFactory)14824"
      },
      {
        "astId": 15853,
        "contract": "src/Identity.sol:Identity",
        "label": "_executionNonce",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 15858,
        "contract": "src/Identity.sol:Identity",
        "label": "_keys",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_struct(Key)15900_storage)"
      },
      {
        "astId": 15863,
        "contract": "src/Identity.sol:Identity",
        "label": "_keysByPurpose",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_array(t_bytes32)dyn_storage)"
      },
      {
        "astId": 15868,
        "contract": "src/Identity.sol:Identity",
        "label": "_executions",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_struct(Execution)15911_storage)"
      },
      {
        "astId": 15873,
        "contract": "src/Identity.sol:Identity",
        "label": "_claims",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_bytes32,t_struct(Claim)15924_storage)"
      },
      {
        "astId": 15878,
        "contract": "src/Identity.sol:Identity",
        "label": "_claimsByTopic",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_array(t_bytes32)dyn_storage)"
      },
      {
        "astId": 15881,
        "contract": "src/Identity.sol:Identity",
        "label": "_initialized",
        "offset": 0,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 15884,
        "contract": "src/Identity.sol:Identity",
        "label": "_canInteract",
        "offset": 1,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 15889,
        "contract": "src/Identity.sol:Identity",
        "label": "__gap",
        "offset": 0,
        "slot": "8",
        "type": "t_array(t_uint256)49_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(IdFactory)14824": {
        "encoding": "inplace",
        "label": "contract IdFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_struct(Claim)15924_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct Structs.Claim)",
        "numberOfBytes": "32",
        "value": "t_struct(Claim)15924_storage"
      },
      "t_mapping(t_bytes32,t_struct(Key)15900_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct Structs.Key)",
        "numberOfBytes": "32",
        "value": "t_struct(Key)15900_storage"
      },
      "t_mapping(t_uint256,t_array(t_bytes32)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32[])",
        "numberOfBytes": "32",
        "value": "t_array(t_bytes32)dyn_storage"
      },
      "t_mapping(t_uint256,t_struct(Execution)15911_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Structs.Execution)",
        "numberOfBytes": "32",
        "value": "t_struct(Execution)15911_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Claim)15924_storage": {
        "encoding": "inplace",
        "label": "struct Structs.Claim",
        "members": [
          {
            "astId": 15913,
            "contract": "src/Identity.sol:Identity",
            "label": "topic",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 15915,
            "contract": "src/Identity.sol:Identity",
            "label": "scheme",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 15917,
            "contract": "src/Identity.sol:Identity",
            "label": "issuer",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 15919,
            "contract": "src/Identity.sol:Identity",
            "label": "signature",
            "offset": 0,
            "slot": "3",
            "type": "t_bytes_storage"
          },
          {
            "astId": 15921,
            "contract": "src/Identity.sol:Identity",
            "label": "data",
            "offset": 0,
            "slot": "4",
            "type": "t_bytes_storage"
          },
          {
            "astId": 15923,
            "contract": "src/Identity.sol:Identity",
            "label": "uri",
            "offset": 0,
            "slot": "5",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(Execution)15911_storage": {
        "encoding": "inplace",
        "label": "struct Structs.Execution",
        "members": [
          {
            "astId": 15902,
            "contract": "src/Identity.sol:Identity",
            "label": "to",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 15904,
            "contract": "src/Identity.sol:Identity",
            "label": "value",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 15906,
            "contract": "src/Identity.sol:Identity",
            "label": "data",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes_storage"
          },
          {
            "astId": 15908,
            "contract": "src/Identity.sol:Identity",
            "label": "approved",
            "offset": 0,
            "slot": "3",
            "type": "t_bool"
          },
          {
            "astId": 15910,
            "contract": "src/Identity.sol:Identity",
            "label": "executed",
            "offset": 1,
            "slot": "3",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(Key)15900_storage": {
        "encoding": "inplace",
        "label": "struct Structs.Key",
        "members": [
          {
            "astId": 15895,
            "contract": "src/Identity.sol:Identity",
            "label": "purposes",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 15897,
            "contract": "src/Identity.sol:Identity",
            "label": "keyType",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 15899,
            "contract": "src/Identity.sol:Identity",
            "label": "key",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}